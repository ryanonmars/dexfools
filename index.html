<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DexFools - Fake DEX Trading Simulator</title>
    <!-- Test commit to verify dexfools repo connection -->
    
    <!-- TradingView Advanced Chart Library -->
    <script type="text/javascript" src="charting_library.standalone.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #000000;
            color: #ffffff;
            line-height: 1.4;
            overflow-x: hidden;
        }

        /* Hide scrollbars but keep functionality */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }

        *::-webkit-scrollbar {
            display: none; /* WebKit */
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        /* Left Sidebar */
        .sidebar {
            width: 280px;
            background: #0a0a0a;
            border-right: 1px solid #1a1a1a;
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
            min-width: 200px;
            max-width: 400px;
        }

        .sidebar-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 4px;
            height: 100%;
            background: transparent;
            cursor: ew-resize;
            z-index: 1001;
        }

        .sidebar-resize-handle:hover {
            background: #00d4aa;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .sidebar-logo {
            font-size: 20px;
            font-weight: bold;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            width: 100%;
        }

        .sidebar-close-btn {
            display: none !important;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            width: 32px;
            height: 32px;
            align-items: center;
            justify-content: center;
        }

        .sidebar-close-btn:hover {
            background: #222;
            color: #fff;
        }

        .logo-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #00d4aa, #ff6b6b);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #000;
            position: relative;
            overflow: hidden;
        }

        .logo-icon::before {
            content: "üíé";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 12px 40px 12px 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-title {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            color: #ccc;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.2s;
        }

        .nav-item:hover {
            color: #fff;
        }

        .nav-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .blockchain-section {
            margin-bottom: 30px;
        }

        .blockchain-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .blockchain-item {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .blockchain-item:hover {
            background: #222;
        }

        .blockchain-icon {
            width: 24px;
            height: 24px;
            margin: 0 auto 8px;
            border-radius: 50%;
        }

        .blockchain-name {
            font-size: 12px;
            color: #ccc;
        }

        .watchlist-section {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 16px;
        }

        .watchlist-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .watchlist-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        .watchlist-content {
            color: #666;
            font-size: 12px;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            margin-left: 280px;
            margin-right: 320px;
            display: flex;
            flex-direction: column;
            max-width: calc(100vw - 280px - 320px);
        }

        /* Header */
        .header {
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .header-logo {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
        }

        .ad-container {
            display: flex;
            gap: 12px;
        }

        .ad-box {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 120px;
            text-align: center;
        }

        .ad-token {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
        }

        .ad-value {
            font-size: 14px;
            color: #00d4aa;
            margin: 2px 0;
        }

        .ad-change {
            font-size: 11px;
            color: #00d4aa;
        }

        .ad-time {
            font-size: 10px;
            color: #666;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .config-toggle-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            box-shadow: none;
            z-index: 1001;
            position: relative;
            flex-shrink: 0;
        }

        .config-toggle-btn:hover {
            background: #222;
            color: #26a69a;
            border-color: #26a69a;
            transform: none;
        }

        .config-toggle-btn.open {
            background: #26a69a;
            color: #000;
            border-color: #26a69a;
        }

        .config-toggle-btn.open:hover {
            background: #2bbbad;
            color: #000;
        }

        /* Mobile: Move config button to header */
        @media (max-width: 768px) {
            .sidebar-logo .config-toggle-btn {
                display: none;
            }
            
            .sidebar-logo {
                justify-content: flex-start;
            }
            
            .sidebar-header {
                justify-content: flex-start;
                position: relative;
            }
            
            .sidebar-close-btn {
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }
            
            /* Mobile header logo */
            .mobile-header-logo {
                display: flex;
                align-items: center;
                gap: 8px;
                font-size: 18px;
                font-weight: bold;
                color: #ffffff;
                margin-right: 15px;
            }
            
            .mobile-logo-icon {
                width: 24px;
                height: 24px;
                background: linear-gradient(45deg, #00d4aa, #ff6b6b);
                border-radius: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                font-weight: bold;
                color: #000;
                position: relative;
            }
            
            .mobile-logo-icon::before {
                content: "üíé";
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 12px;
            }
        }
        
        /* Hide mobile header logo on desktop */
        .mobile-header-logo {
            display: none;
        }
        
        /* Mobile: Show header logo and move config button */
        @media (max-width: 768px) {
            .mobile-header-logo {
                display: flex;
            }
            
            .header-right .config-toggle-btn {
                display: flex !important;
                background: #1a1a1a;
                border: 1px solid #333;
                color: #ccc;
                padding: 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                width: 28px;
                height: 28px;
                align-items: center;
                justify-content: center;
                transition: all 0.3s;
                z-index: 999;
                position: relative;
                flex-shrink: 0;
            }
            
            .header-right .config-toggle-btn:hover {
                background: #222;
                color: #26a69a;
                border-color: #26a69a;
            }
            
            .header-right .config-toggle-btn.open {
                background: #26a69a;
                color: #000;
                border-color: #26a69a;
            }
            
            .header-right .config-toggle-btn.open:hover {
                background: #2bbbad;
                color: #000;
            }
        }

        .user-profile {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-size: 14px;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            background: #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-icons {
            display: flex;
            gap: 12px;
        }

        .header-icon {
            width: 32px;
            height: 32px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #ccc;
        }

        /* Chart Section */
        .chart-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0a0a0a;
            position: relative;
            z-index: 1;
            padding: 0 24px;
        }

        @media (max-width: 768px) {
            .chart-section {
                padding: 0 16px 0 16px;
                margin-right: 16px;
            }
        }

        .chart-header {
            padding: 16px 0;
            border-bottom: 1px solid #1a1a1a;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chart-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }

        .timeframe-buttons {
            display: flex;
            gap: 4px;
        }

        .timeframe-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .timeframe-btn:hover {
            background: #222;
        }

        .timeframe-btn.active {
            background: #00d4aa;
            color: #000;
            border-color: #00d4aa;
        }

        .timeframe-dropdown {
            display: flex;
            align-items: center;
        }

        .timeframe-select {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            min-width: 60px;
        }

        .timeframe-select:hover {
            background: #222;
            border-color: #00d4aa;
        }

        .timeframe-select:focus {
            outline: none;
            border-color: #00d4aa;
            box-shadow: 0 0 0 2px rgba(0, 212, 170, 0.2);
        }

        .timeframe-select option {
            background: #1a1a1a;
            color: #ccc;
        }

        .token-price-display {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
        }

        .token-price-label {
            color: #666;
            font-size: 12px;
        }

        .token-price-value {
            color: #00d4aa;
            font-weight: 600;
            font-size: 12px;
        }

        .price-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .volume-comparison, .txns-comparison, .makers-comparison {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
        }

        .volume-item, .txns-item, .makers-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .combined-progress-bar {
            display: flex;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .combined-progress-bar .progress-fill {
            transition: width 0.3s ease;
        }

        .combined-progress-bar .progress-green {
            background: linear-gradient(90deg, #00d4aa, #00b894);
        }

        .combined-progress-bar .progress-red {
            background: linear-gradient(90deg, #ff6b6b, #e74c3c);
        }

        .combined-progress-bar .progress-blue {
            background: linear-gradient(90deg, #3498db, #2980b9);
        }

        .combined-progress-bar .progress-orange {
            background: linear-gradient(90deg, #f39c12, #e67e22);
        }


        .chart-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .token-pair {
            font-size: 14px;
            color: #fff;
        }

        .chart-container {
            background: #0a0a0a;
            position: relative;
            width: 100%;
            max-width: 100%;
            height: 500px; /* Fixed height instead of aspect ratio */
            margin: 16px 0;
            overflow: hidden;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            z-index: 2;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            background: #333;
            cursor: ns-resize;
            transition: background 0.2s;
            z-index: 10;
        }

        .resize-handle:hover {
            background: #00d4aa;
        }

        .resize-handle::after {
            content: "‚ãÆ‚ãÆ";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 12px;
            line-height: 1;
        }

        .chart-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 16px;
        }

        /* Config Panel Styles */
        #config-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 400px;
            height: 100vh;
            background: #1a1a1a;
            border-right: 1px solid #333;
            color: #d1d4dc;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 2000;
            transition: left 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #config-panel.open {
            left: 0;
        }

        .config-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 20px 0 20px;
            border-bottom: 1px solid #333;
            margin-bottom: 15px;
        }

        .config-close-btn {
            background: #ef5350;
            border: none;
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .config-close-btn:hover {
            background: #d32f2f;
            transform: scale(1.1);
        }

        .config-content {
            flex: 1;
            overflow-y: auto;
            padding: 0 20px 20px 20px;
        }

        .config-button-container {
            flex-shrink: 0;
            padding: 20px;
            border-top: 1px solid #333;
            background: #1a1a1a;
        }

        #config-panel h3 {
            margin: 0 0 15px 0;
            color: #26a69a;
            font-size: 16px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        .config-group {
            margin-bottom: 20px;
        }

        .config-group h4 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 14px;
        }

        .config-item {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .config-item label {
            flex: 1;
            margin-right: 10px;
        }

        .config-item input, .config-item select {
            width: 100px;
            padding: 4px 6px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #d1d4dc;
            font-size: 11px;
        }

        .config-item input[type="checkbox"] {
            width: auto;
        }

        .config-item input[type="number"] {
            width: 120px;
        }

        .config-item input[type="text"] {
            width: 120px;
            padding: 4px 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #d1d4dc;
            font-size: 12px;
        }

        .config-item input[type="text"]:focus {
            outline: none;
            border-color: #26a69a;
            box-shadow: 0 0 0 2px rgba(38, 166, 154, 0.2);
        }

        /* Collapsible styles */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s ease;
        }

        .collapsible-header:hover {
            color: #26a69a;
        }

        .collapsible-icon {
            transition: transform 0.2s ease;
            font-size: 12px;
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* Marker section styles */
        .marker-section {
            margin-bottom: 20px;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            background: #222;
        }

        .marker-section h5 {
            margin: 0 0 12px 0;
            color: #26a69a;
            font-size: 13px;
            font-weight: bold;
        }

        .marker-item {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 6px;
            border: 1px solid #333;
        }

        .marker-item .config-item {
            margin-bottom: 0;
            flex: 0 0 auto;
        }

        .marker-item .config-item label {
            font-size: 11px;
            margin-right: 4px;
        }

        .marker-item .config-item input, 
        .marker-item .config-item select {
            width: 80px;
            font-size: 11px;
            padding: 4px 6px;
        }

        .remove-marker {
            width: 24px;
            height: 24px;
            background: #ef5350;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .remove-marker:hover {
            background: #d32f2f;
            opacity: 1;
            transform: scale(1.1);
        }

        .add-marker-btn {
            background: #26a69a;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            width: 100%;
        }

        .add-marker-btn:hover {
            background: #2dd4aa;
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #000;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            line-height: 1.3;
            border: 1px solid #333;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        #apply-config {
            width: 100%;
            padding: 15px 24px;
            background: #26a69a;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(38, 166, 154, 0.3);
        }

        #apply-config:hover {
            background: #2bbbad;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(38, 166, 154, 0.4);
        }

        #apply-config:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #animation-status {
            margin-top: 10px;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            text-align: center;
            font-size: 12px;
            color: #d1d4dc;
        }

        #tv_chart_container {
            width: 100%;
            height: 100%;
            position: relative;
            background: #000;
            min-height: 400px;
        }


        /* Transactions Section */
        .transactions-section {
            background: #0a0a0a;
            border-top: 1px solid #1a1a1a;
        }

        .transactions-tabs {
            display: flex;
            border-bottom: 1px solid #1a1a1a;
        }

        @media (max-width: 768px) {
            .transactions-tabs {
                margin-right: 16px;
                padding-right: 16px;
                overflow-x: auto;
            }
            
            .tab {
                padding: 12px 16px;
                font-size: 12px;
                white-space: nowrap;
                flex-shrink: 0;
            }
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 2px solid transparent;
        }

        .tab.active {
            color: #fff;
            border-bottom-color: #00d4aa;
        }

        .transactions-table {
            padding: 16px 24px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
        }

        .table th {
            text-align: left;
            padding: 8px 12px;
            font-size: 12px;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
        }

        .table td {
            padding: 8px 12px;
            font-size: 12px;
            color: #ccc;
        }

        .table tr:hover {
            background: #1a1a1a;
        }

        /* Transaction animations */
        .table tr {
            animation: slideInUp 0.5s ease-out;
            transition: all 0.3s ease;
        }

        .table tr.new-transaction {
            animation: highlightNew 2s ease-out;
            background: rgba(0, 212, 170, 0.1);
        }

        .table tr.new-transaction.txn-sell-row {
            background: rgba(255, 107, 107, 0.1);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes highlightNew {
            0% {
                background: rgba(0, 212, 170, 0.3);
                transform: scale(1.02);
            }
            50% {
                background: rgba(0, 212, 170, 0.2);
                transform: scale(1.01);
            }
            100% {
                background: rgba(0, 212, 170, 0.1);
                transform: scale(1);
            }
        }

        .txn-type {
            animation: pulse 0.6s ease-out;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Metrics animation effects */
        .price-value, .metric-value {
            transition: all 0.3s ease;
        }

        .price-value.updating, .metric-value.updating {
            animation: metricUpdate 0.5s ease-out;
        }

        @keyframes metricUpdate {
            0% {
                background: rgba(0, 212, 170, 0.1);
                transform: scale(1);
            }
            50% {
                background: rgba(0, 212, 170, 0.2);
                transform: scale(1.02);
            }
            100% {
                background: transparent;
                transform: scale(1);
            }
        }

        .progress-fill {
            transition: width 0.5s ease-out;
        }

        .editable-metric {
            background: transparent;
            border: 1px solid transparent;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            padding: 2px 4px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 60px;
            text-align: right;
            width: 100%;
        }

        .editable-metric:hover {
            background: #1a1a1a;
            border-color: #333;
        }

        .editable-metric:focus {
            outline: none;
            background: #1a1a1a;
            border-color: #00d4aa;
            cursor: text;
        }

        .txn-type {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .txn-buy {
            background: #00d4aa;
            color: #000;
        }

        .txn-sell {
            background: #ff6b6b;
            color: #fff;
        }

        /* Right Panel */
        .right-panel {
            width: 320px;
            background: #0a0a0a;
            border-left: 1px solid #1a1a1a;
            padding: 20px;
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 10;
            min-width: 250px;
            max-width: 500px;
        }

        .right-panel-resize-handle {
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: transparent;
            cursor: ew-resize;
            z-index: 11;
        }

        .right-panel-resize-handle:hover {
            background: #00d4aa;
        }

        .token-profile {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .token-avatar {
            width: 48px;
            height: 48px;
            background: linear-gradient(45deg, #00d4aa, #0099cc);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        .token-info h2 {
            font-size: 18px;
            margin-bottom: 4px;
        }

        .editable-token-name {
            background: transparent;
            border: 1px solid transparent;
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
        }

        .editable-token-name:hover {
            background: #1a1a1a;
            border-color: #333;
        }

        .editable-token-name:focus {
            outline: none;
            background: #1a1a1a;
            border-color: #00d4aa;
            cursor: text;
        }

        .token-symbol {
            color: #00d4aa;
            font-size: 14px;
        }

        .token-indicators {
            display: flex;
            gap: 8px;
            margin-top: 4px;
        }

        .indicator {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            color: #ccc;
        }

        .network-info {
            color: #666;
            font-size: 12px;
            margin-bottom: 20px;
        }

        .external-links {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .link-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 6px;
            text-decoration: none;
            font-size: 12px;
            transition: all 0.2s;
        }

        .link-btn:hover {
            background: #222;
            color: #fff;
        }

        .price-section {
            margin-bottom: 20px;
        }

        .price-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .price-label {
            color: #666;
            font-size: 12px;
        }

        .price-value {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
        }

        .metrics-section {
            margin-bottom: 20px;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #1a1a1a;
        }

        .metric-label {
            color: #666;
            font-size: 12px;
        }

        .metric-value {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
        }

        .metric-change {
            font-size: 12px;
            margin-left: 8px;
        }

        .positive {
            color: #00d4aa;
        }

        .negative {
            color: #ff6b6b;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            margin-top: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 2px;
        }

        .progress-green {
            background: #00d4aa;
        }

        .progress-red {
            background: #ff6b6b;
        }

        .trading-buttons {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .trade-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .buy-btn {
            background: #00d4aa;
            color: #000;
        }

        .buy-btn:hover {
            background: #00b894;
        }

        .sell-btn {
            background: #ff6b6b;
            color: #fff;
        }

        .sell-btn:hover {
            background: #ff5252;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .action-btn {
            flex: 1;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #222;
            color: #fff;
        }

        /* Mobile Menu Button */
        .mobile-menu-btn {
            display: none;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 8px;
            border-radius: 4px;
            margin-right: 12px;
            cursor: pointer;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .right-panel {
                width: 280px;
            }
        }

        .mobile-token-display {
            display: none;
            align-items: center;
            gap: 4px;
            margin-bottom: 12px;
        }

        .mobile-token-name {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        .mobile-token-pair {
            font-size: 16px;
            color: #00d4aa;
        }

        @media (max-width: 1024px) {
            .mobile-menu-btn {
                display: block;
            }
            
            .sidebar.open .sidebar-close-btn {
                display: flex !important;
            }
            
            .mobile-token-display {
                display: flex;
            }
            
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s;
                z-index: 1000;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                margin-right: 0;
                max-width: 100vw;
            }
            
            .right-panel {
                width: 100%;
                position: static;
                height: auto;
                border-left: none;
                border-top: 1px solid #1a1a1a;
            }
            
            .container {
                flex-direction: column;
            }
            
            .chart-container {
                height: 300px;
                padding-bottom: 0;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 12px 16px;
                flex-wrap: wrap;
            }
            
            .ad-container {
                display: none;
            }
            
            .chart-header {
                padding: 12px 16px;
                flex-wrap: wrap;
                gap: 12px;
            }
            
            .chart-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .transactions-table {
                padding: 12px 16px 12px 16px;
                overflow-x: auto;
                margin-right: 16px;
            }
            
            .table {
                font-size: 10px;
                min-width: 600px;
            }
            
            .right-panel {
                padding: 16px 16px 16px 16px;
                margin-right: 16px;
            }
            
            .sidebar {
                width: 100%;
                max-width: 100%;
            }
            
            .editable-token-name {
                display: none;
            }
        }

        @media (max-width: 480px) {
            .timeframe-buttons {
                flex-wrap: wrap;
                gap: 2px;
            }
            
            .timeframe-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            
            .timeframe-select {
                padding: 4px 8px;
                font-size: 10px;
                min-width: 50px;
            }
            
            .token-price-display {
                padding: 4px 8px;
                font-size: 10px;
            }
            
            .token-price-label, .token-price-value {
                font-size: 10px;
            }
            
            .price-container {
                gap: 2px;
            }
            
            
            .trading-buttons {
                flex-direction: column;
                gap: 8px;
            }
            
            .trade-btn {
                padding: 10px;
                font-size: 12px;
            }
            
            .header-left {
                gap: 8px;
            }
            
            .user-profile {
                font-size: 12px;
            }
            
            .user-avatar {
                width: 24px;
                height: 24px;
                font-size: 10px;
            }
            
            .chart-container {
                height: 250px;
            }
            
            .table th,
            .table td {
                padding: 4px 2px;
                font-size: 9px;
            }
        }
    </style>
</head>
<body>
    <!-- Config Panel -->
    <div id="config-panel">
        <div class="config-header">
            <h3>Chart Configuration</h3>
            <button class="config-close-btn" id="configCloseBtn" title="Close Configuration">‚úï</button>
        </div>
        <div class="config-content">
            
            <div class="config-group">
                <h4>Token Information</h4>
                <div class="config-item">
                    <label>Token Name:</label>
                    <input type="text" id="tokenName" value="token" placeholder="Enter token name">
                </div>
            </div>
            
            <div class="config-group">
                <h4>Market Cap Settings</h4>
                <p style="font-size: 12px; color: #888; margin: 5px 0;">Use K/M/B notation: 10K = 10,000, 1.5M = 1,500,000, 2B = 2,000,000,000</p>
                <div class="config-item">
                    <label>Initial MC:</label>
                    <input type="text" id="initialMarketCap" value="3K" placeholder="e.g., 10K, 1.5M, 2B">
                </div>
                <div class="config-item">
                    <label>Final MC:</label>
                    <input type="text" id="finalMarketCap" value="15K" placeholder="e.g., 10K, 1.5M, 2B">
                </div>
                <div class="config-item">
                    <label>Min MC:</label>
                    <input type="text" id="minMarketCap" value="500" placeholder="e.g., 10K, 1.5M, 2B">
                </div>
                <div class="config-item">
                    <label>Range MC:</label>
                    <input type="text" id="rangeMarketCap" value="8K" placeholder="e.g., 10K, 1.5M, 2B">
                </div>
            </div>
            
            <div class="config-group">
                <h4>Animation Timing</h4>
                <div class="config-item">
                    <label>Duration (s):</label>
                    <input type="number" id="totalSeconds" value="10">
                </div>
                <div class="config-item">
                    <label>Speed Multiplier:</label>
                    <input type="number" id="speedMultiplier" value="1" step="0.1">
                </div>
            </div>
            
            <div class="config-group">
                <h4>Randomness Control</h4>
                <div class="config-item">
                    <label>Seed:</label>
                    <input type="number" id="seed" value="1">
                </div>
            </div>
            
            <div class="config-group">
                <h4>Historical Data</h4>
                <div class="config-item">
                    <label>Enable:</label>
                    <input type="checkbox" id="enableHistoricalData">
                </div>
                <div class="config-item">
                    <label>Time:</label>
                    <input type="text" id="preAnimationTime" value="1h" placeholder="e.g., 2h, 60s">
                </div>
            </div>
            
            <div class="config-group">
                <h4>Final Action</h4>
                <div class="config-item">
                    <label>Type:</label>
                    <select id="finalActionType">
                        <option value="dump">Dump</option>
                        <option value="pump">Pump</option>
                    </select>
                </div>
                <div class="config-item">
                    <label>Target MC:</label>
                    <input type="text" id="finalActionMarketCap" value="5K" placeholder="e.g., 10K, 1.5M, 2B">
                </div>
            </div>
            
            <div class="config-group">
                <h4 style="display: flex; align-items: center; gap: 10px;">
                    Invisible Chart
                    <button id="customThemeToggle" style="
                        background: none; 
                        border: none; 
                        cursor: pointer; 
                        font-size: 18px; 
                        padding: 2px;
                        color: #666;
                        transition: color 0.2s;
                    " title="Toggle invisible chart mode">
                        üëÅÔ∏è
                    </button>
                </h4>
            </div>
            
            <div class="config-group">
                <h4 style="display: flex; align-items: center; gap: 10px;">
                    Export Blank Chart
                    <button id="exportBlankChart" style="
                        background: none; 
                        border: none; 
                        cursor: pointer; 
                        font-size: 18px; 
                        padding: 2px;
                        color: #666;
                        transition: color 0.2s;
                    " title="Export blank chart for background use">
                        üì§
                    </button>
                </h4>
            </div>
            
            <div class="config-group collapsible">
                <h4 class="collapsible-header" onclick="toggleCollapsible('markers')">
                    <span class="collapsible-icon">‚ñº</span>
                    Markers
                </h4>
                <div class="collapsible-content" id="markers-content" style="display: none;">
                    <!-- Dev Markers -->
                    <div class="marker-section">
                        <h5>Developer Markers</h5>
                        <div id="dev-markers">
                            <div class="marker-item">
                                <div class="config-item">
                                    <label class="tooltip">Dev 1:
                                        <span class="tooltiptext">Developer marker 1. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                                    </label>
                                    <input type="checkbox" id="showFirstCandle" checked>
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Type:
                                        <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                                    </label>
                                    <select id="firstCandleType">
                                        <option value="buy">Buy</option>
                                        <option value="sell">Sell</option>
                                    </select>
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Time:
                                        <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                                    </label>
                                    <input type="number" id="firstCandleTime" value="1">
                                </div>
                                <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">üóëÔ∏è</button>
                            </div>
                            <div class="marker-item">
                                <div class="config-item">
                                    <label class="tooltip">Dev 2:
                                        <span class="tooltiptext">Developer marker 2. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                                    </label>
                                    <input type="checkbox" id="showFinalCandle" checked>
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Type:
                                        <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                                    </label>
                                    <select id="finalCandleType">
                                        <option value="buy">Buy</option>
                                        <option value="sell" selected>Sell</option>
                                    </select>
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Time:
                                        <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                                    </label>
                                    <input type="number" id="finalCandleTime" value="10">
                                </div>
                                <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">üóëÔ∏è</button>
                            </div>
                        </div>
                        <button type="button" class="add-marker-btn" onclick="addDevMarker()">+ Add Dev Marker</button>
                    </div>
                    
                    <!-- User Markers -->
                    <div class="marker-section">
                        <h5>User Markers</h5>
                        <div id="user-markers">
                            <div class="marker-item">
                                <div class="config-item">
                                    <label class="tooltip">User 1:
                                        <span class="tooltiptext">User marker 1. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                                    </label>
                                    <input type="checkbox" id="showB">
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Type:
                                        <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                                    </label>
                                    <select id="bType">
                                        <option value="buy" selected>Buy</option>
                                        <option value="sell">Sell</option>
                                    </select>
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Time:
                                        <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                                    </label>
                                    <input type="number" id="bTime" value="5">
                                </div>
                                <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">üóëÔ∏è</button>
                            </div>
                            <div class="marker-item">
                                <div class="config-item">
                                    <label class="tooltip">User 2:
                                        <span class="tooltiptext">User marker 2. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                                    </label>
                                    <input type="checkbox" id="showS">
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Type:
                                        <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                                    </label>
                                    <select id="sType">
                                        <option value="buy">Buy</option>
                                        <option value="sell" selected>Sell</option>
                                    </select>
                                </div>
                                <div class="config-item">
                                    <label class="tooltip">Time:
                                        <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                                    </label>
                                    <input type="number" id="sTime" value="8">
                                </div>
                                <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">üóëÔ∏è</button>
                            </div>
                        </div>
                        <button type="button" class="add-marker-btn" onclick="addUserMarker()">+ Add User Marker</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="config-button-container">
            <button id="apply-config">Apply & Start Animation</button>
            <div id="animation-status">Chart ready - click "Apply & Start" to begin</div>
        </div>
    </div>

    <div class="container">
        <!-- Left Sidebar -->
        <div class="sidebar" id="leftSidebar">
            <div class="sidebar-resize-handle" id="leftResizeHandle"></div>
            <div class="sidebar-header">
                <div class="sidebar-logo">
                    <div class="logo-icon"></div>
                    DexFools
                    <button class="config-toggle-btn" id="configToggleBtn" title="Chart Configuration">‚öôÔ∏è</button>
                </div>
                <button class="sidebar-close-btn" id="sidebarCloseBtn" style="display: none;">‚úï</button>
            </div>
            
            <div class="search-container">
                <input type="text" class="search-input" placeholder="Search">
                <div class="search-icon">üîç</div>
            </div>

            <div class="nav-section">
                <div class="nav-title">Get the App!</div>
                <div style="display: flex; gap: 8px; margin-bottom: 20px;">
                    <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 8px; text-align: center; flex: 1;">
                        <div style="font-size: 16px;">üçé</div>
                        <div style="font-size: 10px; color: #666;">iOS</div>
                    </div>
                    <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 8px; text-align: center; flex: 1;">
                        <div style="font-size: 16px;">ü§ñ</div>
                        <div style="font-size: 10px; color: #666;">Android</div>
                    </div>
                </div>
            </div>

            <div class="nav-section">
                <a href="#" class="nav-item">
                    <div class="nav-icon">‚≠ê</div>
                    Watchlist
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">üîî</div>
                    Alerts
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">‚äû</div>
                    Multicharts
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">üçÉ</div>
                    New Pairs
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">üìà</div>
                    Gainers & Losers
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">üíº</div>
                    Portfolio
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">üì¢</div>
                    Advertise
                </a>
                <a href="#" class="nav-item">
                    <div class="nav-icon">‚ãØ</div>
                    more ‚ñæ
                </a>
            </div>

            <div class="blockchain-section">
                <div class="nav-title">Blockchain Networks</div>
                <div class="blockchain-grid">
                    <div class="blockchain-item">
                        <div class="blockchain-icon" style="background: #ffd700;">üåô</div>
                        <div class="blockchain-name">Moonit</div>
                    </div>
                    <div class="blockchain-item">
                        <div class="blockchain-icon" style="background: #9945ff;">S</div>
                        <div class="blockchain-name">Solana</div>
                    </div>
                    <div class="blockchain-item">
                        <div class="blockchain-icon" style="background: #627eea;">‚ü†</div>
                        <div class="blockchain-name">Ethereum</div>
                    </div>
                    <div class="blockchain-item">
                        <div class="blockchain-icon" style="background: #0052ff;">B</div>
                        <div class="blockchain-name">Base</div>
                    </div>
                    <div class="blockchain-item">
                        <div class="blockchain-icon" style="background: #f3ba2f;">B</div>
                        <div class="blockchain-name">BSC</div>
                    </div>
                    <div class="blockchain-item">
                        <div class="blockchain-icon" style="background: #8b5cf6;">P</div>
                        <div class="blockchain-name">PulseChain</div>
                    </div>
                </div>
            </div>

            <div class="watchlist-section">
                <div class="watchlist-header">
                    <div class="watchlist-title">‚≠ê WATCHLIST</div>
                    <div style="color: #666; font-size: 12px;">Main Watchlist ‚ñæ</div>
                </div>
                <div class="watchlist-content">Nothing in this list yet...</div>
            </div>

            <div style="margin-top: auto; padding-top: 20px; border-top: 1px solid #1a1a1a;">
                <div style="color: #666; font-size: 12px; margin-bottom: 8px;">anon</div>
                <button style="background: #00d4aa; color: #000; border: none; padding: 8px 16px; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer; width: 100%; margin-bottom: 12px;">Sign-in</button>
                <div style="display: flex; gap: 8px; justify-content: center;">
                    <div style="width: 32px; height: 32px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;">X</div>
                    <div style="width: 32px; height: 32px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;">üí¨</div>
                    <div style="width: 32px; height: 32px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer;">‚öôÔ∏è</div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Header -->
            <div class="header">
                <div class="header-left">
                    <button class="mobile-menu-btn" id="mobileMenuBtn">‚ò∞</button>
                    <div class="mobile-header-logo">
                        <div class="mobile-logo-icon"></div>
                        DexFools
                    </div>
                    <div class="ad-container">
                        <div class="ad-box">
                            <div class="ad-token">PEPE2.0</div>
                            <div class="ad-value">0.000123</div>
                            <div class="ad-change positive">+2,340%</div>
                            <div class="ad-time">2h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">DOGEKILLER</div>
                            <div class="ad-value">$0.0045</div>
                            <div class="ad-change positive">+890%</div>
                            <div class="ad-time">4h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">MOONSHOT</div>
                            <div class="ad-value">$0.00089</div>
                            <div class="ad-change negative">-67%</div>
                            <div class="ad-time">1h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">DIAMONDHANDS</div>
                            <div class="ad-value">$0.0012</div>
                            <div class="ad-change positive">+1,500%</div>
                            <div class="ad-time">6h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">SHIBAROCKET</div>
                            <div class="ad-value">$0.000056</div>
                            <div class="ad-change positive">+3,200%</div>
                            <div class="ad-time">3h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">MEMECOIN</div>
                            <div class="ad-value">$0.00078</div>
                            <div class="ad-change negative">-45%</div>
                            <div class="ad-time">5h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">LAMBO</div>
                            <div class="ad-value">$0.0023</div>
                            <div class="ad-change positive">+1,800%</div>
                            <div class="ad-time">8h</div>
                        </div>
                        <div class="ad-box">
                            <div class="ad-token">HODL</div>
                            <div class="ad-value">$0.0015</div>
                            <div class="ad-change positive">+650%</div>
                            <div class="ad-time">12h</div>
                        </div>
                    </div>
                </div>
                <div class="header-right">
                    <button class="config-toggle-btn" id="configToggleBtnMobile" title="Chart Configuration" style="display: none;">‚öôÔ∏è</button>
                    <div class="header-icons">
                        <div class="header-icon">‚ãØ</div>
                    </div>
                </div>
            </div>

            <!-- Chart Section -->
            <div class="chart-section">
                <div class="chart-header">
                    <div class="mobile-token-display">
                        <span class="mobile-token-name" id="mobileTokenName">token/SOL</span>
                    </div>
                    <div class="chart-controls">
                        <div class="timeframe-dropdown">
                            <select id="timeframeSelect" class="timeframe-select">
                                <option value="1s" selected>1s</option>
                                <option value="1m">1m</option>
                                <option value="5m">5m</option>
                                <option value="15m">15m</option>
                                <option value="1h">1h</option>
                                <option value="4h">4h</option>
                                <option value="D">D</option>
                            </select>
                        </div>
                        <div class="token-price-display">
                            <div class="price-container">
                                <span class="token-price-label">USD:</span>
                                <span class="token-price-value" id="chartTokenPriceUSD">$0.00000002</span>
                            </div>
                        </div>
                        <div class="token-price-display">
                            <div class="price-container">
                                <span class="token-price-label">SOL:</span>
                                <span class="token-price-value" id="chartTokenPrice">0.00000002 SOL</span>
                            </div>
                        </div>
                        <button style="background: #1a1a1a; border: 1px solid #333; color: #ccc; padding: 6px 12px; border-radius: 4px; font-size: 12px;">Price / MCap</button>
                    </div>
                </div>
                <div class="chart-container" id="chartContainer">
                    <div id="tv_chart_container">
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #666; font-size: 16px; z-index: 1;">
                            üìä Loading TradingView Chart...
                        </div>
                    </div>
                    <div class="resize-handle" id="resizeHandle"></div>
                </div>
            </div>

            <!-- Transactions Section -->
            <div class="transactions-section">
                <div class="transactions-tabs">
                    <button class="tab active">Transactions</button>
                    <button class="tab">Top Traders</button>
                    <button class="tab">KOLs</button>
                    <button class="tab">Holders (1,912)</button>
                    <button class="tab">Bubblemaps</button>
                </div>
                <div class="transactions-table">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>DATE</th>
                                <th>TYPE</th>
                                <th>USD</th>
                                <th id="tokenHeader">TOKEN</th>
                                <th>SOL</th>
                                <th>PRICE</th>
                                <th>MAKER</th>
                                <th>TXN</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>19:00:24</td>
                                <td><span class="txn-type txn-sell">Sell</span></td>
                                <td>$1,234</td>
                                <td>1,800,000</td>
                                <td>0.052937</td>
                                <td>$0.0006831</td>
                                <td>E3gCT...cuXE</td>
                                <td>üîó</td>
                            </tr>
                            <tr>
                                <td>18:59:15</td>
                                <td><span class="txn-type txn-buy">Buy</span></td>
                                <td>$856</td>
                                <td>1,250,000</td>
                                <td>0.036789</td>
                                <td>$0.0006848</td>
                                <td>F4hDT...bvXF</td>
                                <td>üîó</td>
                            </tr>
                            <tr>
                                <td>18:58:42</td>
                                <td><span class="txn-type txn-sell">Sell</span></td>
                                <td>$2,100</td>
                                <td>3,100,000</td>
                                <td>0.067432</td>
                                <td>$0.0006774</td>
                                <td>G5iEU...cwYG</td>
                                <td>üîó</td>
                            </tr>
                            <tr>
                                <td>18:57:33</td>
                                <td><span class="txn-type txn-buy">Buy</span></td>
                                <td>$1,567</td>
                                <td>2,300,000</td>
                                <td>0.052156</td>
                                <td>$0.0006812</td>
                                <td>H6jFV...dxZH</td>
                                <td>üîó</td>
                            </tr>
                            <tr>
                                <td>18:56:18</td>
                                <td><span class="txn-type txn-sell">Sell</span></td>
                                <td>$987</td>
                                <td>1,450,000</td>
                                <td>0.031234</td>
                                <td>$0.0006809</td>
                                <td>I7kGW...eyAI</td>
                                <td>üîó</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel" id="rightPanel">
            <div class="right-panel-resize-handle" id="rightResizeHandle"></div>
            <div class="token-profile">
                <div class="token-info">
                    <input type="text" class="editable-token-name" value="token/SOL" id="tokenNameInput">
                    <div class="token-indicators">
                        <div class="indicator">5h</div>
                        <div class="indicator">#4</div>
                        <div class="indicator">60</div>
                    </div>
                </div>
            </div>


            <div class="external-links">
                <a href="#" class="link-btn">Website</a>
                <a href="#" class="link-btn">X Twitter</a>
            </div>

            <div class="price-section">
                <div class="price-item">
                    <div class="price-label">PRICE USD</div>
                    <div class="price-value">$0.0000030</div>
                </div>
                <div class="price-item">
                    <div class="price-label">PRICE</div>
                    <div class="price-value">0.00000002 SOL</div>
                </div>
            </div>

            <div class="metrics-section">
                <div class="metric-item">
                    <div class="metric-label">LIQUIDITY</div>
                    <div class="metric-value">$600</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">FDV</div>
                    <div class="metric-value">$3K</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">MKT CAP</div>
                        <input type="text" class="metric-value editable-metric" id="marketCapInput" value="$3.00K" data-base-value="3000">
                </div>
            </div>

            <div class="metrics-section">
                <div class="metric-item">
                    <div class="metric-label">5M</div>
                    <div class="metric-value">
                        <span class="positive" id="performance5M">0%</span>
                    </div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">1H</div>
                    <div class="metric-value">
                        <span class="negative" id="performance1H">0%</span>
                    </div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">6H</div>
                    <div class="metric-value">
                        <span class="positive" id="performance6H">0%</span>
                    </div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">24H</div>
                    <div class="metric-value">
                        <span class="positive" id="performance24H">0%</span>
                    </div>
                </div>
            </div>

            <div class="metrics-section">
                <div class="metric-item">
                    <div class="metric-label">TXNS</div>
                    <div class="metric-value">0</div>
                </div>
                <div class="txns-comparison">
                    <div class="txns-item">
                    <div class="metric-label">BUYS</div>
                        <div class="metric-value" id="buyTxnsValue">0</div>
                </div>
                    <div class="txns-item">
                    <div class="metric-label">SELLS</div>
                        <div class="metric-value" id="sellTxnsValue">0</div>
                </div>
                </div>
                <div class="combined-progress-bar">
                    <div class="progress-fill progress-green" id="buyTxnsBar" style="width: 50%;"></div>
                    <div class="progress-fill progress-red" id="sellTxnsBar" style="width: 50%;"></div>
                </div>
            </div>

            <div class="metrics-section">
                <div class="metric-item">
                    <div class="metric-label">VOLUME</div>
                    <div class="metric-value">$0</div>
                </div>
                <div class="volume-comparison">
                    <div class="volume-item">
                    <div class="metric-label">BUY VOL</div>
                        <div class="metric-value" id="buyVolValue">$0</div>
                </div>
                    <div class="volume-item">
                    <div class="metric-label">SELL VOL</div>
                        <div class="metric-value" id="sellVolValue">$0</div>
                </div>
                </div>
                <div class="combined-progress-bar">
                    <div class="progress-fill progress-green" id="buyVolBar" style="width: 50%;"></div>
                    <div class="progress-fill progress-red" id="sellVolBar" style="width: 50%;"></div>
                </div>
            </div>

            <div class="metrics-section">
                <div class="makers-comparison">
                    <div class="makers-item">
                    <div class="metric-label">MAKERS</div>
                        <div class="metric-value" id="makersValue">0</div>
                </div>
                    <div class="makers-item">
                        <div class="metric-label">TRADERS</div>
                        <div class="metric-value" id="tradersValue">0</div>
                </div>
                </div>
                <div class="combined-progress-bar">
                    <div class="progress-fill progress-blue" id="makersBar" style="width: 50%;"></div>
                    <div class="progress-fill progress-orange" id="tradersBar" style="width: 50%;"></div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="action-btn">‚≠ê Watchlist</button>
                <button class="action-btn">üîî Alerts</button>
            </div>

            <div class="trading-buttons">
                <button class="trade-btn buy-btn">‚Üë Buy</button>
                <button class="trade-btn sell-btn">‚Üì Sell</button>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <a href="#" style="color: #666; font-size: 12px; text-decoration: none;">Hide ad</a>
            </div>

            <div class="metrics-section" style="margin-top: 30px;">
                <div class="metric-item">
                    <div class="metric-label">Pair created</div>
                    <div class="metric-value">3m ago</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Pooled <span id="pooledTokenName">token</span></div>
                    <div class="metric-value" id="pooledTokenAmount">900,000,000</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Pooled SOL</div>
                    <div class="metric-value" id="pooledSOLAmount">3.00 SOL</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Pair</div>
                    <div class="metric-value">E3gCT...cuXE üîó</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Timeframe dropdown functionality
        const timeframeSelect = document.getElementById('timeframeSelect');
        if (timeframeSelect) {
            timeframeSelect.addEventListener('change', function() {
                console.log('Timeframe changed to:', this.value);
                // You can add additional functionality here if needed
            });
        }

        // Tab functionality
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // Mobile sidebar toggle (for responsive design)
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const closeBtn = document.getElementById('sidebarCloseBtn');
            sidebar.classList.toggle('open');
            
            // Show/hide close button based on sidebar state
            if (sidebar.classList.contains('open')) {
                closeBtn.style.display = 'flex';
            } else {
                closeBtn.style.display = 'none';
            }
        }

        function closeSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const closeBtn = document.getElementById('sidebarCloseBtn');
            sidebar.classList.remove('open');
            closeBtn.style.display = 'none';
        }

        // Mobile menu button functionality
        const mobileMenuBtn = document.getElementById('mobileMenuBtn');
        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', toggleSidebar);
        }

        // Sidebar close button functionality
        const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
        if (sidebarCloseBtn) {
            sidebarCloseBtn.addEventListener('click', closeSidebar);
        }

        // Close sidebar when pressing escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeSidebar();
            }
        });

        // Token name editing functionality
        const tokenNameInput = document.getElementById('tokenNameInput');
        const mobileTokenName = document.getElementById('mobileTokenName');
        const tokenHeader = document.getElementById('tokenHeader');

        // Sync mobile token display and transactions header with editable token name
        function updateTokenDisplay() {
            let displayName = tokenNameInput.value;
            
            // Remove existing /SOL if present to avoid duplication
            if (displayName.endsWith('/SOL')) {
                displayName = displayName.replace('/SOL', '');
            }
            
            if (mobileTokenName) {
                mobileTokenName.textContent = displayName + '/SOL';
            }
            
            // Update transactions table header with just the token name (no /SOL)
            if (tokenHeader) {
                tokenHeader.textContent = displayName.toUpperCase();
            }
            
            // Update pooled token name in the bottom metrics
            const pooledTokenName = document.getElementById('pooledTokenName');
            if (pooledTokenName) {
                pooledTokenName.textContent = displayName;
            }
        }

        // Handle Enter key to finish editing
        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                event.target.blur();
            }
        }

        // Handle input changes
        function handleTokenNameChange() {
            updateTokenDisplay();
        }

        if (tokenNameInput) {
            tokenNameInput.addEventListener('keydown', handleEnterKey);
            tokenNameInput.addEventListener('input', handleTokenNameChange);
            tokenNameInput.addEventListener('blur', handleTokenNameChange);
        }

        // Add click-to-edit functionality
        function makeEditable(element) {
            element.addEventListener('click', function() {
                this.focus();
                this.select();
            });
        }

        if (tokenNameInput) {
            makeEditable(tokenNameInput);
        }

        // Initialize token displays
        updateTokenDisplay();
        
        // Link config panel token name to site token name
        const configTokenName = document.getElementById('tokenName');
        if (configTokenName && tokenNameInput) {
            // Update site token name when config token name changes
            configTokenName.addEventListener('input', function() {
                tokenNameInput.value = this.value + '/SOL';
                updateTokenDisplay();
                
                // Update chart widget if it exists (with /SOL)
                if (tvWidget) {
                    const tokenNameWithSOL = this.value + '/SOL';
                    console.log('üîÑ Updating chart symbol to:', tokenNameWithSOL);
                    tvWidget.setSymbol(tokenNameWithSOL, '1', () => {
                        console.log('‚úÖ Chart symbol updated to:', tokenNameWithSOL);
                    });
                }
            });
            
            // Update config token name when site token name changes
            tokenNameInput.addEventListener('input', function() {
                // Remove /SOL if present before updating config panel
                let cleanTokenName = this.value;
                if (cleanTokenName.endsWith('/SOL')) {
                    cleanTokenName = cleanTokenName.replace('/SOL', '');
                }
                configTokenName.value = cleanTokenName;
            });
            
            // Initialize config token name with site token name value
            configTokenName.value = tokenNameInput.value;
        }

        // Market cap editing functionality
        const TOKEN_SUPPLY = 1000000000; // 1B tokens
        let marketCapInput;

        function parseMarketCap(value) {
            const cleanValue = value.replace(/[$,]/g, '').trim();
            if (cleanValue.includes('K')) {
                return parseFloat(cleanValue.replace('K', '')) * 1000;
            } else if (cleanValue.includes('M')) {
                return parseFloat(cleanValue.replace('M', '')) * 1000000;
            } else if (cleanValue.includes('B')) {
                return parseFloat(cleanValue.replace('B', '')) * 1000000000;
            }
            const parsed = parseFloat(cleanValue);
            // If it's a small number (less than 1000), assume it's in thousands
            if (!isNaN(parsed) && parsed < 1000) {
                return parsed * 1000;
            }
            return isNaN(parsed) ? 3000 : parsed; // Default to 3K if invalid
        }

        function formatMarketCap(value) {
            if (value >= 1000000000) {
                return `$${(value / 1000000000).toFixed(2)}B`;
            } else if (value >= 1000000) {
                return `$${(value / 1000000).toFixed(2)}M`;
            } else if (value >= 1000) {
                return `$${(value / 1000).toFixed(2)}K`;
            }
            return `$${value.toFixed(2)}`;
        }

        // Function to parse K/M/B notation to numbers
        function parseMarketCapNotation(value) {
            if (typeof value === 'string') {
                const cleanValue = value.trim().toUpperCase();
                const lastChar = cleanValue.slice(-1);
                const numValue = parseFloat(cleanValue.slice(0, -1));
                
                if (isNaN(numValue)) {
                    return parseInt(value) || 0;
                }
                
                switch (lastChar) {
                    case 'K':
                        return Math.round(numValue * 1000);
                    case 'M':
                        return Math.round(numValue * 1000000);
                    case 'B':
                        return Math.round(numValue * 1000000000);
                    default:
                        return parseInt(cleanValue) || 0;
                }
            }
            return parseInt(value) || 0;
        }

        // Function to format input field values with K/M/B notation
        function formatInputValue(value) {
            const numValue = parseMarketCapNotation(value);
            return formatMarketCap(numValue);
        }

        function formatScientificNotation(value) {
            if (value === 0) return '0';
            
            const str = value.toExponential(6);
            const match = str.match(/^(\d)\.(\d+)e([+-]\d+)$/);
            
            if (!match) return value.toFixed(7);
            
            const [, leadingDigit, decimals, exponent] = match;
            const exp = parseInt(exponent);
            
            if (exp >= 0) {
                // For positive exponents, use normal notation
                return value.toFixed(7);
            } else {
                // For negative exponents, use scientific notation with subscript
                const absExp = Math.abs(exp);
                const subscript = absExp.toString().split('').map(d => 
                    ['‚ÇÄ', '‚ÇÅ', '‚ÇÇ', '‚ÇÉ', '‚ÇÑ', '‚ÇÖ', '‚ÇÜ', '‚Çá', '‚Çà', '‚Çâ'][parseInt(d)]
                ).join('');
                return `0.0${subscript}${leadingDigit}${decimals}`;
            }
        }

        function calculatePriceFromMarketCap(marketCap) {
            return marketCap / TOKEN_SUPPLY;
        }

        function updatePricesFromMarketCap() {
            const marketCapValue = parseMarketCap(marketCapInput.value);
            const pricePerToken = calculatePriceFromMarketCap(marketCapValue);
            
            // Update USD price
            const priceUsd = document.querySelector('.price-value');
            if (priceUsd) {
                priceUsd.textContent = `$${pricePerToken.toFixed(6)}`;
            }
            
            // Update SOL price (assuming 1 SOL = $239 for current rate)
        const priceSol = document.querySelectorAll('.price-value')[1];
        if (priceSol) {
            const solPrice = pricePerToken / 239; // Convert USD to SOL
            priceSol.textContent = `${formatScientificNotation(solPrice)} SOL`;
        }
        
        // Update chart token price display
        const chartTokenPrice = document.getElementById('chartTokenPrice');
        const chartTokenPriceUSD = document.getElementById('chartTokenPriceUSD');
        if (chartTokenPrice) {
            const solPrice = pricePerToken / 239; // Convert USD to SOL
            chartTokenPrice.textContent = `${formatScientificNotation(solPrice)} SOL`;
        }
        if (chartTokenPriceUSD) {
            chartTokenPriceUSD.textContent = `$${pricePerToken.toFixed(7)}`;
        }
            
            // Update FDV to match market cap
            const fdv = document.querySelectorAll('.metric-value')[1];
            if (fdv) {
                fdv.textContent = formatMarketCap(marketCapValue);
            }
            
            // Update liquidity (typically 15-25% of market cap for PumpFun tokens)
            const liquidity = document.querySelectorAll('.metric-value')[0];
            if (liquidity) {
                const liquidityAmount = marketCapValue * 0.2; // 20% of market cap
                liquidity.textContent = formatMarketCap(liquidityAmount);
            }
        }

        function handleMarketCapChange() {
            updatePricesFromMarketCap();
            
            // Update the base value for animations
            const marketCapValue = parseMarketCap(marketCapInput.value);
            marketCapInput.setAttribute('data-base-value', marketCapValue);
        }


        // Transaction animations
        function addNewTransaction() {
            const tbody = document.querySelector('.table tbody');
            if (!tbody) return;

            // Create new transaction row
            const newRow = document.createElement('tr');
            const isBuy = Math.random() > 0.5;
            const txnType = isBuy ? 'Buy' : 'Sell';
            const txnClass = isBuy ? 'txn-buy' : 'txn-sell';
            const amount = Math.floor(Math.random() * 2000) + 100;
            const price = (Math.random() * 0.0001).toFixed(6);
            const time = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            const makerId = Math.random().toString(36).substr(2, 6).toUpperCase();

            // Get token name without /SOL for transactions
            let tokenName = tokenNameInput ? tokenNameInput.value : 'token';
            if (tokenName.endsWith('/SOL')) {
                tokenName = tokenName.replace('/SOL', '');
            }
            newRow.innerHTML = `
                <td>${time}</td>
                <td><span class="txn-type ${txnClass}">${txnType}</span></td>
                <td>$${amount.toLocaleString()}</td>
                <td>${(amount * 1000).toLocaleString()}</td>
                <td>${(amount * 0.05).toFixed(6)}</td>
                <td>$${price}</td>
                <td>${makerId}...${Math.random().toString(36).substr(2, 4)}</td>
                <td>üîó</td>
            `;

            // Add animation classes
            newRow.classList.add('new-transaction');
            if (!isBuy) {
                newRow.classList.add('txn-sell-row');
            }

            // Insert at the top
            tbody.insertBefore(newRow, tbody.firstChild);

            // Remove old transactions if too many
            const rows = tbody.querySelectorAll('tr');
            if (rows.length > 10) {
                tbody.removeChild(rows[rows.length - 1]);
            }

            // Remove animation class after animation completes
            setTimeout(() => {
                newRow.classList.remove('new-transaction', 'txn-sell-row');
            }, 2000);
        }

        // Add new transaction every 0.5-2 seconds
        function startTransactionAnimation() {
            const interval = Math.random() * 1500 + 500; // 0.5-2 seconds
            setTimeout(() => {
                addNewTransaction();
                startTransactionAnimation(); // Schedule next one
            }, interval);
        }

        // Start the animation after page loads (disabled - now driven by chart)
        // setTimeout(startTransactionAnimation, 1000);

        // Metrics animation
        function animateMetrics() {
            // Get base market cap value
            const baseMarketCap = marketCapInput ? parseFloat(marketCapInput.getAttribute('data-base-value')) || 3000 : 3000;
            const basePrice = calculatePriceFromMarketCap(baseMarketCap);
            
            // Price animation based on market cap fluctuations
            const priceUsd = document.querySelector('.price-value');
            if (priceUsd) {
                // Market cap fluctuates ¬±10% around base value for more visible changes
                const marketCapChange = (Math.random() - 0.5) * 0.2; // ¬±10%
                const newMarketCap = baseMarketCap * (1 + marketCapChange);
                const newPrice = calculatePriceFromMarketCap(newMarketCap);
                
                priceUsd.textContent = `$${newPrice.toFixed(7)}`;
                priceUsd.classList.add('updating');
                setTimeout(() => priceUsd.classList.remove('updating'), 500);
            }

            // Price in SOL animation (based on USD price)
            const priceSol = document.querySelectorAll('.price-value')[1];
            if (priceSol) {
                const currentUsdPrice = parseFloat(priceUsd.textContent.replace('$', ''));
                const solPrice = currentUsdPrice / 239; // Convert USD to SOL
                priceSol.textContent = `${formatScientificNotation(solPrice)} SOL`;
            }
            
            // Update chart token price display
            const chartTokenPrice = document.getElementById('chartTokenPrice');
            const chartTokenPriceUSD = document.getElementById('chartTokenPriceUSD');
            if (chartTokenPrice) {
                const currentUsdPrice = parseFloat(priceUsd.textContent.replace('$', ''));
                const solPrice = currentUsdPrice / 239; // Convert USD to SOL
                chartTokenPrice.textContent = `${formatScientificNotation(solPrice)} SOL`;
            }
            if (chartTokenPriceUSD) {
                const currentUsdPrice = parseFloat(priceUsd.textContent.replace('$', ''));
                chartTokenPriceUSD.textContent = `$${currentUsdPrice.toFixed(7)}`;
            }

            // Liquidity animation
            const liquidity = document.querySelector('.metric-value');
            if (liquidity && liquidity.textContent.includes('K')) {
                const currentValue = parseFloat(liquidity.textContent.replace('$', '').replace('K', ''));
                const change = (Math.random() - 0.5) * 5; // 0-5K changes
                const newValue = Math.max(50, currentValue + change);
                liquidity.textContent = `$${Math.round(newValue)}K`;
                liquidity.classList.add('updating');
                setTimeout(() => liquidity.classList.remove('updating'), 500);
            }

            // Market Cap animation (fluctuate around base value)
            if (marketCapInput) {
                const marketCapChange = (Math.random() - 0.5) * 0.2; // ¬±10% for more visible changes
                const newMarketCap = baseMarketCap * (1 + marketCapChange);
                marketCapInput.value = formatMarketCap(newMarketCap);
                marketCapInput.classList.add('updating');
                setTimeout(() => marketCapInput.classList.remove('updating'), 500);
            }

            // Transaction count animation
            const txns = document.querySelectorAll('.metric-value')[3];
            if (txns && !txns.textContent.includes('%')) {
                const currentValue = parseInt(txns.textContent.replace(/,/g, ''));
                const change = Math.floor(Math.random() * 5) + 1; // 1-5 new txns
                const newValue = currentValue + change;
                txns.textContent = newValue.toLocaleString();
            }

            // Buy count animation - more realistic based on price movement
            const buys = document.querySelectorAll('.metric-value')[3];
            if (buys && !buys.textContent.includes('%')) {
                const currentValue = parseInt(buys.textContent.replace(/,/g, ''));
                // More realistic: 0-2 buys per update, with slight bias toward buys
                const change = Math.random() > 0.3 ? Math.floor(Math.random() * 2) : 0;
                const newValue = currentValue + change;
                buys.textContent = newValue.toLocaleString();
            }

            // Sell count animation - more realistic based on price movement
            const sells = document.querySelectorAll('.metric-value')[4];
            if (sells && !sells.textContent.includes('%')) {
                const currentValue = parseInt(sells.textContent.replace(/,/g, ''));
                // More realistic: 0-1 sells per update, with slight bias toward sells
                const change = Math.random() > 0.4 ? 1 : 0;
                const newValue = currentValue + change;
                sells.textContent = newValue.toLocaleString();
            }

            // Volume animation - more realistic based on market activity
            const volume = document.querySelectorAll('.metric-value')[5];
            if (volume && volume.textContent.includes('M')) {
                const currentValue = parseFloat(volume.textContent.replace('$', '').replace('M', ''));
                // More realistic: smaller, more frequent changes
                const change = (Math.random() - 0.5) * 0.2; // ¬±0.1M changes
                const newValue = Math.max(0.5, currentValue + change);
                volume.textContent = `$${newValue.toFixed(1)}M`;
            }

            // Buy volume animation - correlate with buy count
            const buyVol = document.querySelectorAll('.metric-value')[6];
            if (buyVol && buyVol.textContent.includes('M')) {
                const currentValue = parseFloat(buyVol.textContent.replace('$', '').replace('M', ''));
                // Smaller changes, more realistic
                const change = (Math.random() - 0.3) * 0.15; // Slight bias toward increasing
                const newValue = Math.max(0.1, currentValue + change);
                buyVol.textContent = `$${newValue.toFixed(1)}M`;
            }

            // Sell volume animation - correlate with sell count
            const sellVol = document.querySelectorAll('.metric-value')[7];
            if (sellVol && sellVol.textContent.includes('M')) {
                const currentValue = parseFloat(sellVol.textContent.replace('$', '').replace('M', ''));
                // Smaller changes, more realistic
                const change = (Math.random() - 0.7) * 0.15; // Slight bias toward increasing
                const newValue = Math.max(0.1, currentValue + change);
                sellVol.textContent = `$${newValue.toFixed(1)}M`;
            }

            // Makers animation
            const makers = document.querySelectorAll('.metric-value')[9];
            if (makers && !makers.textContent.includes('%')) {
                const currentValue = parseInt(makers.textContent.replace(/,/g, ''));
                const change = Math.floor(Math.random() * 2) + 1; // 1-2 new makers
                const newValue = currentValue + change;
                makers.textContent = newValue.toLocaleString();
            }

            // Buyers animation
            const buyers = document.querySelectorAll('.metric-value')[10];
            if (buyers && !buyers.textContent.includes('%')) {
                const currentValue = parseInt(buyers.textContent.replace(/,/g, ''));
                const change = Math.floor(Math.random() * 2) + 1; // 1-2 new buyers
                const newValue = currentValue + change;
                buyers.textContent = newValue.toLocaleString();
            }

            // Sellers animation
            const sellers = document.querySelectorAll('.metric-value')[11];
            if (sellers && !sellers.textContent.includes('%')) {
                const currentValue = parseInt(sellers.textContent.replace(/,/g, ''));
                const change = Math.floor(Math.random() * 2) + 1; // 1-2 new sellers
                const newValue = currentValue + change;
                sellers.textContent = newValue.toLocaleString();
            }

            // Update progress bars based on new values
            updateProgressBars();
        }

        function updateProgressBars() {
            const buyProgress = document.querySelector('.progress-green');
            const sellProgress = document.querySelector('.progress-red');
            
            if (buyProgress && sellProgress) {
                // Get current buy/sell counts to calculate realistic ratios
                const buys = document.querySelectorAll('.metric-value')[3];
                const sells = document.querySelectorAll('.metric-value')[4];
                
                if (buys && sells) {
                    const buyCount = parseInt(buys.textContent.replace(/,/g, '')) || 0;
                    const sellCount = parseInt(sells.textContent.replace(/,/g, '')) || 0;
                    const total = buyCount + sellCount;
                    
                    if (total > 0) {
                        const buyPercentage = (buyCount / total) * 100;
                const sellPercentage = 100 - buyPercentage;
                
                        // Ensure minimum 5% and maximum 95% for visibility
                        buyProgress.style.width = `${Math.max(5, Math.min(95, buyPercentage))}%`;
                        sellProgress.style.width = `${Math.max(5, Math.min(95, sellPercentage))}%`;
                        
                        console.log('üìä Progress bars updated:', { buyCount, sellCount, buyPercentage: buyPercentage.toFixed(1), sellPercentage: sellPercentage.toFixed(1) });
                    } else {
                        // When no transactions, show equal bars (50/50)
                        buyProgress.style.width = '50%';
                        sellProgress.style.width = '50%';
                        console.log('üìä Progress bars reset to 50/50 (no transactions)');
                    }
                }
            }
        }

        function updateVolumeProgressBar() {
            const buyVolBar = document.getElementById('buyVolBar');
            const sellVolBar = document.getElementById('sellVolBar');
            const buyVolValue = document.getElementById('buyVolValue');
            const sellVolValue = document.getElementById('sellVolValue');
            
            if (buyVolBar && sellVolBar && buyVolValue && sellVolValue) {
                // Parse the volume values
                const buyVolText = buyVolValue.textContent.replace('$', '').replace('K', '000').replace('M', '000000').replace('B', '000000000');
                const sellVolText = sellVolValue.textContent.replace('$', '').replace('K', '000').replace('M', '000000').replace('B', '000000000');
                
                const buyVolAmount = parseFloat(buyVolText) || 0;
                const sellVolAmount = parseFloat(sellVolText) || 0;
                const totalVol = buyVolAmount + sellVolAmount;
                
                if (totalVol > 0) {
                    const buyPercentage = (buyVolAmount / totalVol) * 100;
                    const sellPercentage = 100 - buyPercentage;
                    
                    // Ensure minimum 5% and maximum 95% for visibility
                    buyVolBar.style.width = `${Math.max(5, Math.min(95, buyPercentage))}%`;
                    sellVolBar.style.width = `${Math.max(5, Math.min(95, sellPercentage))}%`;
                    
                    console.log('üìä Volume progress bar updated:', { buyVolAmount, sellVolAmount, buyPercentage: buyPercentage.toFixed(1), sellPercentage: sellPercentage.toFixed(1) });
                } else {
                    // When no volume, show equal bars (50/50)
                    buyVolBar.style.width = '50%';
                    sellVolBar.style.width = '50%';
                    console.log('üìä Volume progress bar reset to 50/50 (no volume)');
                }
            }
        }

        function updateTxnsProgressBar() {
            const buyTxnsBar = document.getElementById('buyTxnsBar');
            const sellTxnsBar = document.getElementById('sellTxnsBar');
            const buyTxnsValue = document.getElementById('buyTxnsValue');
            const sellTxnsValue = document.getElementById('sellTxnsValue');
            
            if (buyTxnsBar && sellTxnsBar && buyTxnsValue && sellTxnsValue) {
                const buyCount = parseInt(buyTxnsValue.textContent.replace(/,/g, '')) || 0;
                const sellCount = parseInt(sellTxnsValue.textContent.replace(/,/g, '')) || 0;
                const totalTxns = buyCount + sellCount;
                
                if (totalTxns > 0) {
                    const buyPercentage = (buyCount / totalTxns) * 100;
                    const sellPercentage = 100 - buyPercentage;
                    
                    // Ensure minimum 5% and maximum 95% for visibility
                    buyTxnsBar.style.width = `${Math.max(5, Math.min(95, buyPercentage))}%`;
                    sellTxnsBar.style.width = `${Math.max(5, Math.min(95, sellPercentage))}%`;
                    
                    console.log('üìä TXNS progress bar updated:', { buyCount, sellCount, buyPercentage: buyPercentage.toFixed(1), sellPercentage: sellPercentage.toFixed(1) });
                } else {
                    // When no transactions, show equal bars (50/50)
                    buyTxnsBar.style.width = '50%';
                    sellTxnsBar.style.width = '50%';
                    console.log('üìä TXNS progress bar reset to 50/50 (no transactions)');
                }
            }
        }

        function updateMakersProgressBar() {
            const makersBar = document.getElementById('makersBar');
            const tradersBar = document.getElementById('tradersBar');
            const makersValue = document.getElementById('makersValue');
            const tradersValue = document.getElementById('tradersValue');
            
            if (makersBar && tradersBar && makersValue && tradersValue) {
                const makersCount = parseInt(makersValue.textContent.replace(/,/g, '')) || 0;
                const tradersCount = parseInt(tradersValue.textContent.replace(/,/g, '')) || 0;
                const total = makersCount + tradersCount;
                
                if (total > 0) {
                    const makersPercentage = (makersCount / total) * 100;
                    const tradersPercentage = 100 - makersPercentage;
                    
                    // Ensure minimum 5% and maximum 95% for visibility
                    makersBar.style.width = `${Math.max(5, Math.min(95, makersPercentage))}%`;
                    tradersBar.style.width = `${Math.max(5, Math.min(95, tradersPercentage))}%`;
                    
                    console.log('üìä Makers progress bar updated:', { makersCount, tradersCount, makersPercentage: makersPercentage.toFixed(1), tradersPercentage: tradersPercentage.toFixed(1) });
                } else {
                    // When no activity, show equal bars (50/50)
                    makersBar.style.width = '50%';
                    tradersBar.style.width = '50%';
                    console.log('üìä Makers progress bar reset to 50/50 (no activity)');
                }
            }
        }

        function updatePerformanceMetrics(marketCap, tokenPrice) {
            // Calculate realistic performance percentages based on market cap and price movement
            const basePrice = 0.000003; // Base price for comparison
            const priceChange = ((tokenPrice - basePrice) / basePrice) * 100;
            
            // Special case: if final action MC is 0 (complete dump), show -100% for all intervals
            if (marketCap === 0 || tokenPrice === 0) {
                const performance5M = document.getElementById('performance5M');
                const performance1H = document.getElementById('performance1H');
                const performance6H = document.getElementById('performance6H');
                const performance24H = document.getElementById('performance24H');
                
                if (performance5M) {
                    performance5M.textContent = '-100.00%';
                    performance5M.className = 'negative';
                }
                if (performance1H) {
                    performance1H.textContent = '-100.00%';
                    performance1H.className = 'negative';
                }
                if (performance6H) {
                    performance6H.textContent = '-100.00%';
                    performance6H.className = 'negative';
                }
                if (performance24H) {
                    performance24H.textContent = '-100.00%';
                    performance24H.className = 'negative';
                }
                
                console.log('üìä Performance metrics updated (DUMP): All intervals show -100%');
                return;
            }
            
            // 5M performance - more volatile, smaller changes
            const performance5M = document.getElementById('performance5M');
            if (performance5M) {
                const change5M = priceChange * (0.1 + Math.random() * 0.3); // 10-40% of price change
                const value5M = Math.abs(change5M) < 0.1 ? 0 : change5M;
                performance5M.textContent = `${value5M >= 0 ? '+' : ''}${value5M.toFixed(2)}%`;
                performance5M.className = value5M >= 0 ? 'positive' : 'negative';
            }
            
            // 1H performance - moderate volatility
            const performance1H = document.getElementById('performance1H');
            if (performance1H) {
                const change1H = priceChange * (0.3 + Math.random() * 0.4); // 30-70% of price change
                const value1H = Math.abs(change1H) < 0.1 ? 0 : change1H;
                performance1H.textContent = `${value1H >= 0 ? '+' : ''}${value1H.toFixed(2)}%`;
                performance1H.className = value1H >= 0 ? 'positive' : 'negative';
            }
            
            // 6H performance - larger changes, more realistic for pump tokens
            const performance6H = document.getElementById('performance6H');
            if (performance6H) {
                const change6H = priceChange * (0.5 + Math.random() * 0.8); // 50-130% of price change
                const value6H = Math.abs(change6H) < 0.1 ? 0 : change6H;
                performance6H.textContent = `${value6H >= 0 ? '+' : ''}${value6H.toFixed(2)}%`;
                performance6H.className = value6H >= 0 ? 'positive' : 'negative';
            }
            
            // 24H performance - largest changes, typical for new tokens
            const performance24H = document.getElementById('performance24H');
            if (performance24H) {
                const change24H = priceChange * (0.8 + Math.random() * 1.2); // 80-200% of price change
                const value24H = Math.abs(change24H) < 0.1 ? 0 : change24H;
                performance24H.textContent = `${value24H >= 0 ? '+' : ''}${value24H.toFixed(2)}%`;
                performance24H.className = value24H >= 0 ? 'positive' : 'negative';
            }
            
            console.log('üìä Performance metrics updated:', { 
                priceChange: priceChange.toFixed(2), 
                marketCap, 
                tokenPrice: tokenPrice.toFixed(8) 
            });
        }

        // Start metrics animation every 2-4 seconds
        function startMetricsAnimation() {
            const interval = Math.random() * 2000 + 2000; // 2-4 seconds
            setTimeout(() => {
                animateMetrics();
                startMetricsAnimation(); // Schedule next update
            }, interval);
        }

        // Start metrics animation after page loads (disabled - now driven by chart)
        // setTimeout(startMetricsAnimation, 3000);

        // Chart Generation Variables (from index.html)
        let tvWidget = null;
        let globalDatafeed = null;
        let isAnimating = false;
        let currentAnimation = null;
        let animationComplete = false;
        
        // Pool Animation Variables
        let poolAnimationInterval = null;
        let isPoolAnimating = false;
        let baseTokenAmount = 900000000; // Start with close to a billion
        let baseSOLAmount = 3.0; // Start with realistic SOL amount (low MC)
        let baseTokenValue = 1; // Start much lower
        let baseSOLValue = 1; // Start much lower
        
        // Function to update fakeDEX data based on chart price
        function updateFakeDEXDataFromChart(currentPrice) {
            if (!currentPrice || !isAnimating || animationComplete) return;
            
            // The chart price is actually the market cap, so we need to calculate the token price
            const marketCap = currentPrice; // Chart price is market cap
            const tokenPrice = marketCap / 1000000000; // Market cap / 1B tokens = token price
            const solPrice = tokenPrice / 239; // Convert USD to SOL (SOL = $239)
            
            // Update market cap display
            if (marketCapInput) {
                marketCapInput.value = formatMarketCap(marketCap);
                marketCapInput.setAttribute('data-base-value', marketCap);
            }
            
            // Update price displays
            const priceUsd = document.querySelector('.price-value');
            if (priceUsd) {
                priceUsd.textContent = `$${tokenPrice.toFixed(7)}`;
            }
            
            const priceSol = document.querySelectorAll('.price-value')[1];
            if (priceSol) {
                priceSol.textContent = `${formatScientificNotation(solPrice)} SOL`;
            }
            
            // Update chart token price display
            const chartTokenPrice = document.getElementById('chartTokenPrice');
            const chartTokenPriceUSD = document.getElementById('chartTokenPriceUSD');
            if (chartTokenPrice) {
                chartTokenPrice.textContent = `${formatScientificNotation(solPrice)} SOL`;
            }
            if (chartTokenPriceUSD) {
                chartTokenPriceUSD.textContent = `$${tokenPrice.toFixed(7)}`;
            }
            
            // Update FDV to match market cap
            const fdv = document.querySelectorAll('.metric-value')[1];
            if (fdv) {
                fdv.textContent = formatMarketCap(marketCap);
            }
            
            // Update liquidity (typically 15-25% of market cap for PumpFun tokens)
            const liquidity = document.querySelectorAll('.metric-value')[0];
            if (liquidity) {
                const liquidityAmount = marketCap * 0.2; // 20% of market cap
                liquidity.textContent = formatMarketCap(liquidityAmount);
            }
            
            // Update buy/sell metrics based on price movement
            updateBuySellMetrics(marketCap, tokenPrice);
            
            console.log('üìä Updated fakeDEX data from chart - Market Cap:', marketCap, 'Token Price:', tokenPrice, 'SOL Price:', solPrice);
        }
        
        // Function to reset all metrics to zero
        function resetMetricsToZero() {
            // Reset TXNS
            const txns = document.querySelectorAll('.metric-value')[2];
            if (txns) txns.textContent = '0';
            
            // Reset buy/sell counts
            const buyTxnsValue = document.getElementById('buyTxnsValue');
            const sellTxnsValue = document.getElementById('sellTxnsValue');
            if (buyTxnsValue) buyTxnsValue.textContent = '0';
            if (sellTxnsValue) sellTxnsValue.textContent = '0';
            
            // Reset volumes
            const volume = document.querySelectorAll('.metric-value')[5];
            const buyVolValue = document.getElementById('buyVolValue');
            const sellVolValue = document.getElementById('sellVolValue');
            if (volume) volume.textContent = '$0';
            if (buyVolValue) buyVolValue.textContent = '$0';
            if (sellVolValue) sellVolValue.textContent = '$0';
            
            // Reset MAKERS and TRADERS
            const makersValue = document.getElementById('makersValue');
            const tradersValue = document.getElementById('tradersValue');
            if (makersValue) makersValue.textContent = '0';
            if (tradersValue) tradersValue.textContent = '0';
            
            // Reset performance metrics
            const performance5M = document.getElementById('performance5M');
            const performance1H = document.getElementById('performance1H');
            const performance6H = document.getElementById('performance6H');
            const performance24H = document.getElementById('performance24H');
            if (performance5M) {
                performance5M.textContent = '0%';
                performance5M.className = 'positive';
            }
            if (performance1H) {
                performance1H.textContent = '0%';
                performance1H.className = 'negative';
            }
            if (performance6H) {
                performance6H.textContent = '0%';
                performance6H.className = 'positive';
            }
            if (performance24H) {
                performance24H.textContent = '0%';
                performance24H.className = 'positive';
            }
            
            // Reset progress bars to 50/50
            const buyProgress = document.querySelector('.progress-green');
            const sellProgress = document.querySelector('.progress-red');
            if (buyProgress) buyProgress.style.width = '50%';
            if (sellProgress) sellProgress.style.width = '50%';
            
            // Reset TXNS progress bars to 50/50
            const buyTxnsBar = document.getElementById('buyTxnsBar');
            const sellTxnsBar = document.getElementById('sellTxnsBar');
            if (buyTxnsBar) buyTxnsBar.style.width = '50%';
            if (sellTxnsBar) sellTxnsBar.style.width = '50%';
            
            // Reset volume progress bars to 50/50
            const buyVolBar = document.getElementById('buyVolBar');
            const sellVolBar = document.getElementById('sellVolBar');
            if (buyVolBar) buyVolBar.style.width = '50%';
            if (sellVolBar) sellVolBar.style.width = '50%';
            
            // Reset makers progress bars to 50/50
            const makersBar = document.getElementById('makersBar');
            const tradersBar = document.getElementById('tradersBar');
            if (makersBar) makersBar.style.width = '50%';
            if (tradersBar) tradersBar.style.width = '50%';
            
            console.log('üîÑ Reset all metrics to zero');
        }

        // Function to update buy/sell metrics based on chart data
        function updateBuySellMetrics(marketCap, tokenPrice) {
            console.log('üîÑ updateBuySellMetrics called with:', { marketCap, tokenPrice });
            
            // Calculate realistic buy/sell activity based on market cap and price
            const baseActivity = Math.min(marketCap / 1000, 100); // Scale with market cap
            const priceVolatility = Math.abs(tokenPrice - 0.000003) / 0.000003; // Compare to base price
            
            console.log('üìä Calculated activity:', { baseActivity, priceVolatility });
            
            // Buy count - more buys when price is rising or stable
            const buyTxnsValue = document.getElementById('buyTxnsValue');
            if (buyTxnsValue) {
                const currentValue = parseInt(buyTxnsValue.textContent.replace(/,/g, '')) || 0;
                const buyActivity = Math.floor(baseActivity * (0.5 + Math.random() * 0.5));
                const newValue = currentValue + buyActivity;
                buyTxnsValue.textContent = newValue.toLocaleString();
                console.log('üìà Updated buys:', { currentValue, buyActivity, newValue });
            }
            
            // Sell count - more sells when price is volatile
            const sellTxnsValue = document.getElementById('sellTxnsValue');
            if (sellTxnsValue) {
                const currentValue = parseInt(sellTxnsValue.textContent.replace(/,/g, '')) || 0;
                const sellActivity = Math.floor(baseActivity * priceVolatility * (0.3 + Math.random() * 0.4));
                const newValue = currentValue + sellActivity;
                sellTxnsValue.textContent = newValue.toLocaleString();
                console.log('üìâ Updated sells:', { currentValue, sellActivity, newValue });
            }
            
            // Volume - correlate with market cap
            const volume = document.querySelectorAll('.metric-value')[5];
            if (volume && volume.textContent.includes('M')) {
                const volumeAmount = marketCap * 0.15; // 15% of market cap
                volume.textContent = formatMarketCap(volumeAmount);
            }
            
            // Buy volume - 60-70% of total volume
            const buyVolValue = document.getElementById('buyVolValue');
            if (buyVolValue) {
                const buyVolumeAmount = marketCap * 0.1; // 10% of market cap
                buyVolValue.textContent = formatMarketCap(buyVolumeAmount);
            }
            
            // Sell volume - 30-40% of total volume
            const sellVolValue = document.getElementById('sellVolValue');
            if (sellVolValue) {
                const sellVolumeAmount = marketCap * 0.05; // 5% of market cap
                sellVolValue.textContent = formatMarketCap(sellVolumeAmount);
            }
            
            // Update combined volume progress bar
            updateVolumeProgressBar();
            
            // Update TXNS (total transactions) - sum of buys and sells
            const txns = document.querySelectorAll('.metric-value')[2];
            if (txns && !txns.textContent.includes('%')) {
                const buyCount = parseInt(buyTxnsValue ? buyTxnsValue.textContent.replace(/,/g, '') : '0') || 0;
                const sellCount = parseInt(sellTxnsValue ? sellTxnsValue.textContent.replace(/,/g, '') : '0') || 0;
                const totalTxns = buyCount + sellCount;
                txns.textContent = totalTxns.toLocaleString();
            }
            
            // Update TXNS progress bar
            updateTxnsProgressBar();
            
            // Update MAKERS - correlate with total activity
            const makersValue = document.getElementById('makersValue');
            if (makersValue) {
                const currentValue = parseInt(makersValue.textContent.replace(/,/g, '')) || 0;
                const makerActivity = Math.floor(baseActivity * 0.3); // 30% of base activity
                const newValue = currentValue + makerActivity;
                makersValue.textContent = newValue.toLocaleString();
            }
            
            // Update TRADERS - sum of buyers and sellers
            const tradersValue = document.getElementById('tradersValue');
            if (tradersValue) {
                const buyCount = parseInt(buyTxnsValue ? buyTxnsValue.textContent.replace(/,/g, '') : '0') || 0;
                const sellCount = parseInt(sellTxnsValue ? sellTxnsValue.textContent.replace(/,/g, '') : '0') || 0;
                const totalTraders = buyCount + sellCount;
                tradersValue.textContent = totalTraders.toLocaleString();
            }
            
            // Update makers progress bar
            updateMakersProgressBar();
            
            // Update performance metrics
            updatePerformanceMetrics(marketCap, tokenPrice);
            
            // Update progress bars based on new ratios
            updateProgressBars();
        }

        // Function to set final data after animation completes
        function setFinalData() {
            const config = getConfig();
            const finalActionMC = config.finalActionMarketCap;
            const tokenPrice = finalActionMC / 1000000000;
            const solPrice = tokenPrice / 239;
            
            // Mark animation as complete to stop data updates
            animationComplete = true;
            isAnimating = false;
            
            // Stop pool animation
            stopPoolAnimation();
            
            // Update market cap display
            if (marketCapInput) {
                marketCapInput.value = formatMarketCap(finalActionMC);
                marketCapInput.setAttribute('data-base-value', finalActionMC);
            }
            
            // Update price displays
            const priceUsd = document.querySelector('.price-value');
            if (priceUsd) {
                priceUsd.textContent = `$${tokenPrice.toFixed(7)}`;
            }
            
            const priceSol = document.querySelectorAll('.price-value')[1];
            if (priceSol) {
                priceSol.textContent = `${formatScientificNotation(solPrice)} SOL`;
            }
            
            // Update chart token price display
            const chartTokenPrice = document.getElementById('chartTokenPrice');
            const chartTokenPriceUSD = document.getElementById('chartTokenPriceUSD');
            if (chartTokenPrice) {
                chartTokenPrice.textContent = `${formatScientificNotation(solPrice)} SOL`;
            }
            if (chartTokenPriceUSD) {
                chartTokenPriceUSD.textContent = `$${tokenPrice.toFixed(7)}`;
            }
            
            // Update FDV to match market cap
            const fdv = document.querySelectorAll('.metric-value')[1];
            if (fdv) {
                fdv.textContent = formatMarketCap(finalActionMC);
            }
            
            // Update liquidity (typically 15-25% of market cap for PumpFun tokens)
            const liquidity = document.querySelectorAll('.metric-value')[0];
            if (liquidity) {
                const liquidityAmount = finalActionMC * 0.2; // 20% of market cap
                liquidity.textContent = formatMarketCap(liquidityAmount);
            }
            
            // Update buy/sell metrics for final data
            updateBuySellMetrics(finalActionMC, tokenPrice);
            
            // Update pool amounts to final target MC values
            updatePoolAmounts();
            
            console.log('üéØ Set final data - Final Action MC:', finalActionMC, 'Token Price:', tokenPrice, 'SOL Price:', solPrice);
        }

        // Seeded random number generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 1664525 + 1013904223) % Math.pow(2, 32);
                return this.seed / Math.pow(2, 32);
            }
            
            range(min, max) {
                return min + this.next() * (max - min);
            }
        }

        // Config Panel Toggle Functionality
        function toggleConfigPanel() {
            const configPanel = document.getElementById('config-panel');
            const toggleBtn = document.getElementById('configToggleBtn');
            const toggleBtnMobile = document.getElementById('configToggleBtnMobile');
            
            configPanel.classList.toggle('open');
            toggleBtn.classList.toggle('open');
            if (toggleBtnMobile) {
                toggleBtnMobile.classList.toggle('open');
            }
            
            if (configPanel.classList.contains('open')) {
                toggleBtn.textContent = '‚úï';
                toggleBtn.title = 'Close Configuration';
                if (toggleBtnMobile) {
                    toggleBtnMobile.textContent = '‚úï';
                    toggleBtnMobile.title = 'Close Configuration';
                }
            } else {
                toggleBtn.textContent = '‚öôÔ∏è';
                toggleBtn.title = 'Chart Configuration';
                if (toggleBtnMobile) {
                    toggleBtnMobile.textContent = '‚öôÔ∏è';
                    toggleBtnMobile.title = 'Chart Configuration';
                }
            }
        }

        // Initialize everything on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Hide close button
            const closeBtn = document.getElementById('sidebarCloseBtn');
            if (closeBtn) {
                closeBtn.style.display = 'none';
            }
            
            // Config panel toggle
            const configToggleBtn = document.getElementById('configToggleBtn');
            if (configToggleBtn) {
                configToggleBtn.addEventListener('click', toggleConfigPanel);
            }

            // Config panel toggle (mobile)
            const configToggleBtnMobile = document.getElementById('configToggleBtnMobile');
            if (configToggleBtnMobile) {
                configToggleBtnMobile.addEventListener('click', toggleConfigPanel);
            }

            // Config panel close button
            const configCloseBtn = document.getElementById('configCloseBtn');
            if (configCloseBtn) {
                configCloseBtn.addEventListener('click', toggleConfigPanel);
            }

            // Apply config button
            const applyConfigBtn = document.getElementById('apply-config');
            if (applyConfigBtn) {
                applyConfigBtn.addEventListener('click', function() {
                    // Close the config panel (only if it's open)
                    const configPanel = document.getElementById('config-panel');
                    if (configPanel && configPanel.classList.contains('open')) {
                        toggleConfigPanel();
                    }
                    
                    // Apply custom chart overrides only if toggle is enabled
                    const toggle = document.getElementById('customThemeToggle');
                    if (toggle && toggle.getAttribute('data-enabled') === 'true') {
                        applyChartOverrides();
                    } else {
                        resetChartToDefaults();
                    }
                    
                    // Update button text to show delay
                    applyConfigBtn.textContent = 'Starting in 2 seconds...';
                    applyConfigBtn.disabled = true;
                    
                    // Update animation status
                    const animationStatus = document.getElementById('animation-status');
                    if (animationStatus) {
                        animationStatus.textContent = 'Chart styled & config applied - starting animation in 2 seconds...';
                        animationStatus.style.color = '#26a69a';
                    }
                    
                    // Start animation after 2 second delay
                    setTimeout(() => {
                        startAnimation();
                        // Reset button after animation starts
                        applyConfigBtn.textContent = 'Apply & Start Animation';
                        applyConfigBtn.disabled = false;
                    }, 2000);
                });
            }

            // Initialize chart on page load
            setTimeout(() => {
                console.log('üöÄ Initializing chart on page load...');
                globalDatafeed = new CustomDatafeed();
                initTradingView();
            }, 1000);
            
            // Initialize market cap input first
            marketCapInput = document.getElementById('marketCapInput');
            
            // Initialize theme toggle - wait for DOM to be ready
            setTimeout(() => {
                const themeToggle = document.getElementById('customThemeToggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', function() {
                        toggleCustomTheme();
                    });
                }
                
                // Initialize export blank chart button
                const exportBtn = document.getElementById('exportBlankChart');
                if (exportBtn) {
                    exportBtn.addEventListener('click', function() {
                        exportBlankChart();
                    });
                }
            }, 2000);
            
        // Initialize prices on page load
        setTimeout(() => {
            console.log('üí∞ Initializing prices...');
            updatePricesFromMarketCap();
        }, 500);
        
        // Link config panel market cap to site market cap display
        const configInitialMC = document.getElementById('initialMarketCap');
        const configFinalMC = document.getElementById('finalMarketCap');
        const configMinMC = document.getElementById('minMarketCap');
        
        if (configInitialMC && marketCapInput) {
            // Update site market cap when config initial market cap changes
            configInitialMC.addEventListener('input', function() {
                const value = parseInt(this.value);
                if (!isNaN(value)) {
                    // Only update if animation is not running
                    if (!isAnimating) {
                        marketCapInput.value = formatMarketCap(value);
                        marketCapInput.setAttribute('data-base-value', value);
                        updatePricesFromMarketCap();
                    }
                }
            });
            
            // Initialize site market cap with config value
            const initialValue = parseInt(configInitialMC.value);
            if (!isNaN(initialValue)) {
                marketCapInput.value = formatMarketCap(initialValue);
                marketCapInput.setAttribute('data-base-value', initialValue);
            }
        }
        
        // Add listeners for final and min market cap changes
        if (configFinalMC) {
            configFinalMC.addEventListener('input', function() {
                // Only update if animation is not running
                if (!isAnimating) {
                    console.log('üìù Final market cap updated:', this.value);
                }
            });
        }
        
        if (configMinMC) {
            configMinMC.addEventListener('input', function() {
                // Only update if animation is not running
                if (!isAnimating) {
                    console.log('üìù Min market cap updated:', this.value);
                }
            });
        }

        // Add K/M/B notation support to all market cap input fields
        const marketCapFields = [
            'initialMarketCap',
            'finalMarketCap', 
            'minMarketCap',
            'rangeMarketCap',
            'finalActionMarketCap'
        ];

        marketCapFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
                // Format on blur (when user finishes typing)
                field.addEventListener('blur', function() {
                    const parsedValue = parseMarketCapNotation(this.value);
                    if (parsedValue > 0) {
                        this.value = parsedValue; // Store the numeric value
                    }
                });
                
                // Add placeholder text to show format
                field.setAttribute('placeholder', 'e.g., 10K, 1.5M, 2B');
            }
        });

        // Black Theme Toggle
        const blackThemeCheckbox = document.getElementById('blackTheme');
        
        if (blackThemeCheckbox) {
            blackThemeCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    console.log('üé® Black theme enabled - applying settings');
                    applyBlackTheme();
                } else {
                    console.log('üé® Normal theme enabled - applying settings');
                    applyNormalTheme();
                }
            });
        }

        // Apply black theme settings (background: solid black, gridlines: none, crosshairs: black)
        function applyBlackTheme() {
            if (tvWidget) {
                try {
                    tvWidget.chart().executeActionById('setChartStyle', {
                        'paneProperties.background': '#000000',
                        'paneProperties.backgroundType': 'solid',
                        'paneProperties.gridProperties.color': '#000000',
                        'paneProperties.gridProperties.style': 0, // 0 = none
                        'paneProperties.vertGridProperties.color': '#000000',
                        'paneProperties.vertGridProperties.style': 0, // 0 = none
                        'paneProperties.horzGridProperties.color': '#000000',
                        'paneProperties.horzGridProperties.style': 0, // 0 = none
                        'scalesProperties.textColor': '#000000',
                        'scalesProperties.lineColor': '#000000'
                    });
                    console.log('‚úÖ Black theme applied');
                } catch (error) {
                    console.log('‚ùå Could not apply black theme:', error);
                }
            }
        }

        // Apply normal theme settings
        function applyNormalTheme() {
            if (tvWidget) {
                try {
                    tvWidget.chart().executeActionById('setChartStyle', {
                        'paneProperties.background': '#1e1e1e',
                        'paneProperties.backgroundType': 'solid',
                        'paneProperties.gridProperties.color': '#2a2a2a',
                        'paneProperties.gridProperties.style': 1, // 1 = solid
                        'paneProperties.vertGridProperties.color': '#2a2a2a',
                        'paneProperties.vertGridProperties.style': 1, // 1 = solid
                        'paneProperties.horzGridProperties.color': '#2a2a2a',
                        'paneProperties.horzGridProperties.style': 1, // 1 = solid
                        'scalesProperties.textColor': '#d1d4dc',
                        'scalesProperties.lineColor': '#2a2a2a'
                    });
                    console.log('‚úÖ Normal theme applied');
                } catch (error) {
                    console.log('‚ùå Could not apply normal theme:', error);
                }
            }
        }
            
            if (marketCapInput) {
                // Set up event listeners
                marketCapInput.addEventListener('input', handleMarketCapChange);
                marketCapInput.addEventListener('blur', handleMarketCapChange);
                marketCapInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                });
                
                // Initialize with current value
                handleMarketCapChange();
            }
        });

        // Chart resizing functionality
        const chartContainer = document.getElementById('chartContainer');
        const resizeHandle = document.getElementById('resizeHandle');
        
        if (chartContainer && resizeHandle) {
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;

            function startResize(e) {
                isResizing = true;
                startY = e.clientY;
                // Get current height, accounting for padding-bottom aspect ratio
                const currentHeight = chartContainer.offsetHeight || (chartContainer.offsetWidth * 9/16);
                startHeight = currentHeight;
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
                e.stopPropagation();
            }

            function doResize(e) {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const newHeight = startHeight + deltaY;
                const minHeight = 200;
                const maxHeight = window.innerHeight * 0.8;
                
                if (newHeight >= minHeight && newHeight <= maxHeight) {
                    // Calculate width based on 16:9 aspect ratio
                    const newWidth = newHeight * (16/9);
                    chartContainer.style.width = newWidth + 'px';
                    chartContainer.style.height = newHeight + 'px';
                    chartContainer.style.paddingBottom = '0';
                }
            }

            function stopResize() {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            }

            resizeHandle.addEventListener('mousedown', startResize);
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);

            // Double-click to reset size
            resizeHandle.addEventListener('dblclick', function(e) {
                e.preventDefault();
                // Reset to default 16:9 aspect ratio
                chartContainer.style.width = '100%';
                chartContainer.style.height = '0';
                chartContainer.style.paddingBottom = '56.25%';
            });
        }

        // Sidebar resizing functionality
        const leftSidebar = document.getElementById('leftSidebar');
        const leftResizeHandle = document.getElementById('leftResizeHandle');
        const rightPanel = document.getElementById('rightPanel');
        const rightResizeHandle = document.getElementById('rightResizeHandle');
        const mainContent = document.querySelector('.main-content');

        if (leftSidebar && leftResizeHandle && rightPanel && rightResizeHandle && mainContent) {
            let isLeftResizing = false;
            let isRightResizing = false;
            let startX = 0;
            let startWidth = 0;

            // Left sidebar resize
            function startLeftResize(e) {
                isLeftResizing = true;
                startX = e.clientX;
                startWidth = leftSidebar.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
                e.stopPropagation();
            }

            function doLeftResize(e) {
                if (!isLeftResizing) return;
                
                const deltaX = e.clientX - startX;
                const newWidth = startWidth + deltaX;
                const minWidth = 200;
                const maxWidth = 400;
                
                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    leftSidebar.style.width = newWidth + 'px';
                    mainContent.style.marginLeft = newWidth + 'px';
                    mainContent.style.maxWidth = `calc(100vw - ${newWidth}px - ${rightPanel.offsetWidth}px)`;
                }
            }

            // Right panel resize
            function startRightResize(e) {
                isRightResizing = true;
                startX = e.clientX;
                startWidth = rightPanel.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
                e.stopPropagation();
            }

            function doRightResize(e) {
                if (!isRightResizing) return;
                
                const deltaX = startX - e.clientX; // Reverse direction for right panel
                const newWidth = startWidth + deltaX;
                const minWidth = 250;
                const maxWidth = 500;
                
                if (newWidth >= minWidth && newWidth <= maxWidth) {
                    rightPanel.style.width = newWidth + 'px';
                    mainContent.style.marginRight = newWidth + 'px';
                    mainContent.style.maxWidth = `calc(100vw - ${leftSidebar.offsetWidth}px - ${newWidth}px)`;
                }
            }

            function stopSidebarResize() {
                if (isLeftResizing || isRightResizing) {
                    isLeftResizing = false;
                    isRightResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            }

            // Event listeners for left sidebar
            leftResizeHandle.addEventListener('mousedown', startLeftResize);
            
            // Event listeners for right panel
            rightResizeHandle.addEventListener('mousedown', startRightResize);
            
            // Global mouse events
            document.addEventListener('mousemove', function(e) {
                doLeftResize(e);
                doRightResize(e);
            });
            document.addEventListener('mouseup', stopSidebarResize);

            // Double-click to reset sidebar widths
            leftResizeHandle.addEventListener('dblclick', function(e) {
                e.preventDefault();
                leftSidebar.style.width = '280px';
                mainContent.style.marginLeft = '280px';
            });

            rightResizeHandle.addEventListener('dblclick', function(e) {
                e.preventDefault();
                rightPanel.style.width = '320px';
                mainContent.style.marginRight = '320px';
                mainContent.style.maxWidth = `calc(100vw - ${leftSidebar.offsetWidth}px - 320px)`;
            });
        }

        // Chart Generation Functions (from index.html)
        function startAnimation() {
            console.log('üé¨ startAnimation function called!');
            // Stop any existing animation first
            if (isAnimating) {
                console.log('üõë Stopping existing animation...');
                isAnimating = false;
                if (currentAnimation) {
                    clearTimeout(currentAnimation);
                    currentAnimation = null;
                }
            }
            
            // Reset animation state
            isAnimating = true;
            animationComplete = false;
            
            // Reset all metrics to 0
            resetMetricsToZero();
            
            const config = getConfig();
            console.log('üé¨ Starting TradingView Advanced Chart animation with config:', config);
            
            // Start transaction animation when chart starts
            startTransactionAnimation();
            
            // Start pool animation
            startPoolAnimation();
            
            document.getElementById('animation-status').textContent = 'Resetting chart and generating animation data...';
            document.getElementById('animation-status').style.color = '#26a69a';
            
            // COMPLETE CHART RESET - Recreate the entire chart widget
            console.log('üîÑ Performing complete chart reset...');
            
            // Remove the old chart completely
            if (tvWidget) {
                console.log('üîÑ Removing old chart widget...');
                tvWidget.remove();
                tvWidget = null;
            }
            
            // Pre-load historical data first
            let historicalBars = [];
            if (config.enableHistoricalData) {
                const preAnimationSeconds = parseTimeToSeconds(config.preAnimationTime);
                if (preAnimationSeconds > 0) {
                    console.log(`üìà Pre-loading ${preAnimationSeconds} seconds of historical data...`);
                    
                    // Generate historical data immediately
                    const rng = new SeededRandom(config.seed);
                    const currentTime = Math.floor(Date.now() / 1000);
                    const animationStartTime = currentTime;
                    const historicalStartTime = animationStartTime - preAnimationSeconds;
                    
                    let historicalPrice = config.initialMarketCap * (0.95 + rng.next() * 0.1);
                    let momentum = 0;
                    let trend = 0;
                    let lastTrendChange = 0;
                    
                    const historicalMinutes = Math.floor(preAnimationSeconds / 60);
                    for (let i = 0; i < historicalMinutes; i++) {
                        const time = historicalStartTime + (i * 60);
                        const open = historicalPrice;
                        
                        const progressRatio = i / (historicalMinutes - 1);
                        const trendStrength = 0.01 + (progressRatio * 0.02); // Increased trend strength
                        const randomStrength = 0.6; // Increased random strength
                        
                        // More varied target price with consolidation periods
                        let targetPrice;
                        if (progressRatio < 0.3 || progressRatio > 0.7) {
                            // Consolidation periods - stay near initial price
                            targetPrice = config.initialMarketCap + (rng.next() - 0.5) * config.rangeMarketCap * 0.2;
                        } else {
                            // Trend periods - gradual movement
                            targetPrice = config.initialMarketCap * (0.95 + progressRatio * 0.1);
                        }
                        
                        const trendComponent = (targetPrice - open) * trendStrength;
                        const randomComponent = (rng.next() - 0.5) * config.rangeMarketCap * randomStrength;
                        
                        const randomDirectionChance = 0.4; // More direction changes
                        const trendDirection = rng.next() < randomDirectionChance ? (rng.next() - 0.5) * 2 : 1;
                        
                        const volatility = 0.4 + rng.next() * 0.6; // Higher volatility
                        const momentum = rng.next() < 0.2 ? (rng.next() - 0.5) * 0.3 : 0; // More momentum
                        
                        let change = (trendComponent * trendDirection) + (randomComponent + momentum) * volatility;
                        
                        const meanReversion = (config.initialMarketCap - historicalPrice) * 0.05;
                        change += meanReversion;
                        
                        let close = open + change;
                        
                        const maxDeviation = config.initialMarketCap * 0.05;
                        if (close > config.initialMarketCap + maxDeviation) {
                            close = config.initialMarketCap + maxDeviation;
                        } else if (close < config.initialMarketCap - maxDeviation) {
                            close = config.initialMarketCap - maxDeviation;
                        }
                        
                        const effectiveMin = Math.min(config.minMarketCap, config.finalMarketCap);
                        if (close < effectiveMin) {
                            close = effectiveMin;
                        }
                        
                        let high = Math.max(open, close);
                        let low = Math.min(open, close);
                        
                        if (rng.next() < 0.2) {
                            const wickSize = Math.abs(change) * (0.1 + rng.next() * 0.3);
                            if (close > open) {
                                high = Math.max(open, close) + rng.next() * wickSize;
                            } else {
                                low = Math.min(open, close) - rng.next() * wickSize;
                            }
                        }
                        
                        historicalBars.push({
                            time: time,
                            open: open,
                            high: high,
                            low: low,
                            close: close,
                            volume: 1000 + rng.next() * 2000
                        });
                        
                        historicalPrice = close;
                    }
                    
                    if (historicalBars.length > 0) {
                        const lastBar = historicalBars[historicalBars.length - 1];
                        const currentPrice = lastBar.close;
                        const targetPrice = config.initialMarketCap;
                        const priceDifference = targetPrice - currentPrice;
                        
                        const maxAdjustment = config.initialMarketCap * 0.02;
                        const adjustment = Math.max(-maxAdjustment, Math.min(maxAdjustment, priceDifference));
                        
                        lastBar.close = currentPrice + adjustment;
                        lastBar.high = Math.max(lastBar.high, lastBar.open, lastBar.close);
                        lastBar.low = Math.min(lastBar.low, lastBar.open, lastBar.close);
                        
                        lastBar.time = animationStartTime - 60;
                        console.log(`üìà Last historical bar ends at: ${lastBar.time}, Animation starts at: ${animationStartTime}`);
                    }
                    
                    console.log(`üìà Generated ${historicalBars.length} historical bars`);
                }
            }
            
            // Create datafeed with historical data already loaded
            globalDatafeed = new CustomDatafeed();
            globalDatafeed.currentData = [...historicalBars];
            console.log('üîÑ Datafeed created with historical data:', globalDatafeed.currentData.length, 'bars');
            
            // Recreate the chart widget
            console.log('üîÑ Creating fresh chart widget...');
            initTradingView();
            
            // Wait for chart to be ready, then start animation
            setTimeout(() => {
                console.log('üöÄ Fresh chart ready, starting animation');
                startAnimationData(config);
            }, 1000);
        }

        // Pool Animation Functions
        function startPoolAnimation() {
            if (isPoolAnimating) return;
            
            isPoolAnimating = true;
            console.log('üèä Starting pool animation...');
            
            poolAnimationInterval = setInterval(() => {
                updatePoolAmounts();
            }, 2000 + Math.random() * 3000); // 2-5 seconds between updates
        }

        function stopPoolAnimation() {
            if (poolAnimationInterval) {
                clearInterval(poolAnimationInterval);
                poolAnimationInterval = null;
            }
            isPoolAnimating = false;
            console.log('üèä Pool animation stopped');
        }

        function updatePoolAmounts() {
            // Use current animation MC during animation, final target MC when complete
            let targetMC;
            if (animationComplete) {
                // Animation finished - use final target MC
                const config = getConfig();
                targetMC = config.finalActionMarketCap || 3000;
            } else {
                // Animation running - use current MC
                targetMC = marketCapInput ? parseFloat(marketCapInput.getAttribute('data-base-value')) || 3000 : 3000;
            }
            
            // Calculate token price from target market cap
            const tokenPrice = targetMC / 1000000000; // Market cap / 1B tokens
            const solPrice = 239; // SOL = $239
            
            // Start with close to a billion tokens and calculate SOL based on price
            // Higher MC = higher price = fewer tokens needed for same value
            let baseTokenAmount;
            
            if (targetMC < 10000) {
                // Low MC: ~900M tokens, ~3 SOL (based on real ratios)
                baseTokenAmount = 900000000;
                baseSOLAmount = 3;
            } else if (targetMC < 100000) {
                // Medium MC: ~800M tokens, ~30 SOL
                baseTokenAmount = 800000000;
                baseSOLAmount = 30;
            } else if (targetMC < 1000000) {
                // High MC: ~600M tokens, ~300 SOL (your reference point!)
                baseTokenAmount = 600000000;
                baseSOLAmount = 300;
            } else {
                // Very high MC: ~400M tokens, ~1000 SOL
                baseTokenAmount = 400000000;
                baseSOLAmount = 1000;
            }
            
            // Calculate actual amounts based on target market cap
            // Higher target MC = more SOL, fewer tokens (people bought tokens)
            const priceRatio = targetMC / 3000; // Ratio from starting MC (3K)
            const tokenAmount = baseTokenAmount / Math.sqrt(priceRatio);
            // Use logarithmic scaling for SOL - much more realistic growth
            const solAmount = baseSOLAmount * (1 + Math.log10(priceRatio) * 0.3);
            
            // Add some realistic trading activity (small fluctuations)
            const tradingActivity = Math.random();
            let fluctuation = 1.0;
            
            if (tradingActivity < 0.2) {
                // 20% chance: Small decrease (liquidity removal)
                fluctuation = 0.98 + Math.random() * 0.02; // 0-2% decrease
            } else if (tradingActivity < 0.6) {
                // 40% chance: Small increase (liquidity addition)
                fluctuation = 1.00 + Math.random() * 0.03; // 0-3% increase
            } else {
                // 40% chance: Larger change (big trade)
                const bigChange = (Math.random() - 0.5) * 0.1; // ¬±5% change
                fluctuation = 1 + bigChange;
            }
            
            // Apply fluctuations
            baseTokenAmount = Math.max(1000, tokenAmount * fluctuation);
            const finalSOLAmount = Math.max(0.1, solAmount * fluctuation);
            
            // Calculate USD values (raw numbers, no K conversion)
            const tokenValueUSD = baseTokenAmount * tokenPrice;
            const solValueUSD = finalSOLAmount * solPrice;
            
            // Update token amount display
            const tokenAmountElement = document.getElementById('pooledTokenAmount');
            if (tokenAmountElement) {
                const formattedAmount = Math.round(baseTokenAmount).toLocaleString();
                tokenAmountElement.textContent = formattedAmount;
            }
            
            // Update SOL amount display
            const solAmountElement = document.getElementById('pooledSOLAmount');
            if (solAmountElement) {
                const formattedSOL = finalSOLAmount.toFixed(2);
                solAmountElement.innerHTML = `${formattedSOL} SOL`;
            }
        }

        function getConfig() {
            try {
                const speedMultiplierValue = document.getElementById('speedMultiplier').value;
                const parsedSpeedMultiplier = parseFloat(speedMultiplierValue);
                
                return {
                    tokenName: document.getElementById('tokenName').value || 'Custom animated token',
                    initialMarketCap: parseMarketCapNotation(document.getElementById('initialMarketCap').value),
                    finalMarketCap: parseMarketCapNotation(document.getElementById('finalMarketCap').value),
                    minMarketCap: parseMarketCapNotation(document.getElementById('minMarketCap').value),
                    finalActionMarketCap: parseMarketCapNotation(document.getElementById('finalActionMarketCap').value),
                    rangeMarketCap: parseMarketCapNotation(document.getElementById('rangeMarketCap').value),
                    totalSeconds: parseInt(document.getElementById('totalSeconds').value),
                    speedMultiplier: parsedSpeedMultiplier || 1.0,
                    seed: parseInt(document.getElementById('seed').value) || 1,
                    enableHistoricalData: document.getElementById('enableHistoricalData').checked,
                    preAnimationTime: document.getElementById('preAnimationTime').value,
                    markers: {
                        showFirstCandle: document.getElementById('showFirstCandle').checked,
                        firstCandleType: document.getElementById('firstCandleType').value,
                        firstCandleTime: parseInt(document.getElementById('firstCandleTime').value),
                        showFinalCandle: document.getElementById('showFinalCandle').checked,
                        finalCandleType: document.getElementById('finalCandleType').value,
                        finalCandleTime: parseInt(document.getElementById('finalCandleTime').value),
                        userMarkers: {
                            showB: document.getElementById('showB').checked,
                            bTime: parseInt(document.getElementById('bTime').value),
                            bType: document.getElementById('bType').value,
                            showS: document.getElementById('showS').checked,
                            sTime: parseInt(document.getElementById('sTime').value),
                            sType: document.getElementById('sType').value
                        }
                    }
                };
            } catch (error) {
                console.error('‚ùå Error in getConfig():', error);
                return {
                    initialMarketCap: 10000,
                    finalMarketCap: 50000,
                    minMarketCap: 500,
                    rangeMarketCap: 8000,
                    totalSeconds: 10,
                    speedMultiplier: 1.0,
                    seed: 1,
                    enableHistoricalData: false,
                    preAnimationTime: '1h',
                    markers: {
                        showFirstCandle: true,
                        firstCandleType: 'buy',
                        firstCandleTime: 1,
                        showFinalCandle: true,
                        finalCandleType: 'sell',
                        finalCandleTime: 10,
                        userMarkers: {
                            showB: false,
                            bTime: 5,
                            bType: 'buy',
                            showS: false,
                            sTime: 8,
                            sType: 'sell'
                        }
                    }
                };
            }
        }

        function parseTimeToSeconds(timeString) {
            const timeStr = timeString.toLowerCase().trim();
            const match = timeStr.match(/^(\d+)([smhd])$/);
            
            if (!match) {
                console.warn(`Invalid time format: ${timeString}. Using default 1 hour.`);
                return 3600;
            }
            
            const value = parseInt(match[1]);
            const unit = match[2];
            
            switch (unit) {
                case 's': return value;
                case 'm': return value * 60;
                case 'h': return value * 3600;
                case 'd': return value * 86400;
                default: return 3600;
            }
        }

        // Custom Datafeed for TradingView Advanced Chart
        class CustomDatafeed {
            constructor() {
                this.currentData = [];
                this.animationIndex = 0;
                this.onRealtimeCallback = null;
            }

            onReady(callback) {
                console.log('üì° TradingView Advanced Chart onReady called');
                setTimeout(() => callback({
                    supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
                    supports_marks: true,
                    supports_timescale_marks: true,
                    supports_time: true,
                }), 0);
            }

            searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {
                console.log('üîç searchSymbols called');
                onResultReadyCallback([]);
            }

            resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
                console.log('üîó resolveSymbol called for:', symbolName);
                
                const tokenName = document.getElementById('tokenName')?.value || 'Custom animated token';
                let tokenNameWithSOL = tokenName;
                if (!tokenNameWithSOL.endsWith('/SOL')) {
                    tokenNameWithSOL = tokenName + '/SOL';
                }
                
                const symbolInfo = {
                    ticker: '',
                    name: tokenNameWithSOL,
                    description: tokenNameWithSOL,
                    type: 'crypto',
                    session: '24x7',
                    timezone: 'UTC',
                    exchange: '',
                    minmov: 1,
                    pricescale: 100,
                    has_intraday: true,
                    has_weekly_and_monthly: false,
                    supported_resolutions: ['1S', '5S', '15S', '30S', '1', '5', '15', '30', '60', '240', '1D'],
                    volume_precision: 0,
                    data_status: 'streaming',
                };

                console.log('üîó Sending symbolInfo to TradingView:', symbolInfo);
                setTimeout(() => onSymbolResolvedCallback(symbolInfo), 0);
            }

            getBars(symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) {
                console.log('üìä getBars called with:', { 
                    resolution, 
                    periodParams, 
                    dataLength: this.currentData.length,
                    from: new Date(periodParams.from * 1000).toISOString(),
                    to: new Date(periodParams.to * 1000).toISOString()
                });
                
                try {
                    if (this.currentData.length > 0) {
                        const fromTime = periodParams.from;
                        const toTime = periodParams.to;
                        
                        const filteredBars = this.currentData.filter(bar => {
                            const barTime = bar.time;
                            return barTime >= fromTime && barTime <= toTime;
                        });
                        
                        console.log('üìä Filtered to', filteredBars.length, 'bars in range');
                        
                        const tvData = filteredBars.map(bar => ({
                            time: bar.time * 1000,
                            open: bar.open,
                            high: bar.high,
                            low: bar.low,
                            close: bar.close,
                            volume: bar.volume || 1000
                        }));

                        console.log('‚úÖ Sending', tvData.length, 'bars to TradingView');
                        setTimeout(() => {
                            onHistoryCallback(tvData, { noData: false });
                        }, 0);
                    } else {
                        console.log('üìä No data available, sending empty response');
                        setTimeout(() => onHistoryCallback([], { noData: true }), 0);
                    }
                } catch (error) {
                    console.error('‚ùå Error in getBars:', error);
                    if (onErrorCallback) {
                        onErrorCallback(error);
                    }
                }
            }

            subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) {
                console.log('üì° subscribeBars called with:', { symbolInfo, resolution, subscribeUID });
                this.onRealtimeCallback = onRealtimeCallback;
                console.log('üì° Realtime callback stored:', !!this.onRealtimeCallback);
            }

            unsubscribeBars(subscribeUID) {
                console.log('üì° unsubscribeBars called');
            }

            addBar(bar) {
                this.currentData.push(bar);
                
                // Update fakeDEX data based on chart price
                updateFakeDEXDataFromChart(bar.close);
                
                if (this.onRealtimeCallback) {
                    const tvBar = {
                        time: bar.time * 1000,
                        open: bar.open,
                        high: bar.high,
                        low: bar.low,
                        close: bar.close,
                        volume: bar.volume || 1000
                    };
                    
                    console.log('üìä Sending real-time bar:', tvBar);
                    this.onRealtimeCallback(tvBar);
                }
            }

            clearData() {
                this.currentData = [];
                this.animationIndex = 0;
            }

            getMarks(symbolInfo, from, to, onDataCallback, resolution) {
                console.log('üéØ getMarks called:', { symbolInfo, from, to, resolution });
                const marks = this.getCurrentMarks(from, to);
                console.log('üéØ Returning marks:', marks.length, marks);
                onDataCallback(marks);
            }

            getCurrentMarks(from, to) {
                const marks = [];
                
                if (!this.currentData || this.currentData.length === 0) {
                    return marks;
                }

                for (let i = 0; i < this.currentData.length; i++) {
                    const bar = this.currentData[i];
                    const barTime = bar.time;
                    
                    if (barTime >= from && barTime <= to) {
                        if (bar.mark) {
                            marks.push({
                                id: bar.mark.id,
                                time: barTime,
                                color: bar.mark.color,
                                text: bar.mark.text,
                                minSize: 14,
                                shape: bar.mark.shape || 'circle'
                            });
                        }
                    }
                }

                marks.sort((a, b) => a.time - b.time);
                return marks;
            }

            addMark(barTime, markData) {
                console.log('üéØ addMark called:', { barTime, markData, currentDataLength: this.currentData.length });
                
                for (let i = 0; i < this.currentData.length; i++) {
                    if (this.currentData[i].time === barTime) {
                        this.currentData[i].mark = markData;
                        console.log('üéØ Mark added to bar at index', i, 'time', barTime);
                        break;
                    }
                }
            }

            getTimescaleMarks(symbolInfo, from, to, onDataCallback, resolution) {
                console.log('üìÖ getTimescaleMarks called:', { symbolInfo, from, to, resolution });
                onDataCallback([]);
            }
        }

        // Global flag to track if custom styling should be applied
        let shouldApplyCustomStyling = false;

        // Test function for debugging
        window.testToggle = function() {
            console.log('üß™ Test toggle function called');
            console.log('üìä TV Widget:', !!tvWidget);
            console.log('üìä Toggle element:', !!document.getElementById('customThemeToggle'));
            console.log('üìä shouldApplyCustomStyling:', shouldApplyCustomStyling);
            
            if (tvWidget) {
                console.log('üß™ Testing applyChartOverrides...');
                applyChartOverrides();
            } else {
                console.log('‚ùå No TV Widget available for testing');
            }
        };

        // Function to toggle custom theme
        window.toggleCustomTheme = function() {
            const toggle = document.getElementById('customThemeToggle');
            if (!toggle) {
                return;
            }

            // Toggle the state
            const isEnabled = toggle.getAttribute('data-enabled') === 'true';
            
            if (!isEnabled) {
                // Enable invisible mode
                toggle.setAttribute('data-enabled', 'true');
                toggle.textContent = 'üôà'; // Closed eye
                toggle.style.color = '#00d4aa';
                shouldApplyCustomStyling = true;
                if (tvWidget) {
                    applyChartOverrides();
                }
            } else {
                // Disable invisible mode
                toggle.setAttribute('data-enabled', 'false');
                toggle.textContent = 'üëÅÔ∏è'; // Open eye
                toggle.style.color = '#666';
                shouldApplyCustomStyling = false;
                if (tvWidget) {
                    resetChartToDefaults();
                }
            }
        };

        // Function to reset chart to default settings
        function resetChartToDefaults() {
            if (!tvWidget) {
                return;
            }
            
            const defaultOverrides = {
                // Reset all custom styling to default values
                'paneProperties.background': undefined,
                'paneProperties.backgroundType': undefined,
                'paneProperties.vertGridProperties.color': undefined,
                'paneProperties.vertGridProperties.style': undefined,
                'paneProperties.horzGridProperties.color': undefined,
                'paneProperties.horzGridProperties.style': undefined,
                'paneProperties.gridLinesMode': undefined,
                'paneProperties.separatorColor': undefined,
                'paneProperties.legendProperties.showLastDayChange': undefined,
                'paneProperties.legendProperties.showSeriesTitle': undefined,
                'paneProperties.legendProperties.showSeriesOHLC': undefined,
                'paneProperties.legendProperties.showBarChange': undefined,
                'paneProperties.legendProperties.showVolume': undefined,
                'paneProperties.legendProperties.showBackground': undefined,
                'paneProperties.legendProperties.backgroundTransparency': undefined,
                'scalesProperties.textColor': undefined,
                'scalesProperties.lineColor': undefined,
                'scalesProperties.showSeriesLastValue': undefined,
                'scalesProperties.showStudyLastValue': undefined,
                'scalesProperties.showBidAsk': undefined,
                'mainSeriesProperties.candleStyle.upColor': undefined,
                'mainSeriesProperties.candleStyle.downColor': undefined,
                'mainSeriesProperties.candleStyle.borderUpColor': undefined,
                'mainSeriesProperties.candleStyle.borderDownColor': undefined,
                'mainSeriesProperties.candleStyle.wickUpColor': undefined,
                'mainSeriesProperties.candleStyle.wickDownColor': undefined,
                'mainSeriesProperties.candleStyle.drawWick': undefined,
                'mainSeriesProperties.candleStyle.drawBorder': undefined,
                'mainSeriesProperties.candleStyle.drawBody': undefined,
                'mainSeriesProperties.showPriceLine': undefined,
                'mainSeriesProperties.priceLineWidth': undefined,
                'mainSeriesProperties.priceLineColor': undefined,
                'mainSeriesProperties.showVolume': undefined,
                'mainSeriesProperties.volumeStyle.upColor': undefined,
                'mainSeriesProperties.volumeStyle.downColor': undefined,
                'mainSeriesProperties.volumeStyle.borderUpColor': undefined,
                'mainSeriesProperties.volumeStyle.borderDownColor': undefined,
                'mainSeriesProperties.visible': undefined
            };

            try {
                tvWidget.applyOverrides(defaultOverrides);
                shouldApplyCustomStyling = false;
            } catch (error) {
                console.error('Error resetting chart to defaults:', error);
            }
        }

        // Function to export blank chart
        function exportBlankChart() {
            if (!tvWidget) {
                alert('Chart not ready. Please wait for the chart to load.');
                return;
            }

            try {
                // First, start the animation to ensure we have data
                if (typeof startAnimation === 'function') {
                    startAnimation();
                }
                
                // Wait for animation to start and data to load
                setTimeout(() => {
                    // Stop the animation after 2 seconds
                    setTimeout(() => {
                        if (typeof stopAnimation === 'function') {
                            stopAnimation();
                        }
                        
                        // Wait a bit more for chart to stabilize, then hide candles
                        setTimeout(() => {
                            const blankOverrides = {
                                // Hide candles by making them invisible
                                'mainSeriesProperties.candleStyle.upColor': 'rgba(0,0,0,0)',
                                'mainSeriesProperties.candleStyle.downColor': 'rgba(0,0,0,0)',
                                'mainSeriesProperties.candleStyle.borderUpColor': 'rgba(0,0,0,0)',
                                'mainSeriesProperties.candleStyle.borderDownColor': 'rgba(0,0,0,0)',
                                'mainSeriesProperties.candleStyle.wickUpColor': 'rgba(0,0,0,0)',
                                'mainSeriesProperties.candleStyle.wickDownColor': 'rgba(0,0,0,0)',
                                'mainSeriesProperties.candleStyle.drawWick': false,
                                'mainSeriesProperties.candleStyle.drawBorder': false,
                                'mainSeriesProperties.candleStyle.drawBody': false,
                                
                                // Hide price line
                                'mainSeriesProperties.showPriceLine': false,
                                
                                // Clean background and grid
                                'paneProperties.background': '#1e1e1e',
                                'paneProperties.backgroundType': 'solid',
                                'paneProperties.vertGridProperties.color': '#2a2a2a',
                                'paneProperties.horzGridProperties.color': '#2a2a2a',
                                
                                // Clean scales
                                'scalesProperties.textColor': '#d1d4dc',
                                'scalesProperties.lineColor': '#2a2a2a',
                                'scalesProperties.showSeriesLastValue': false,
                                'scalesProperties.showStudyLastValue': false,
                                
                                // Hide legend info
                                'paneProperties.legendProperties.showBarChange': false,
                                'paneProperties.legendProperties.showVolume': false,
                                'paneProperties.legendProperties.showSeriesOHLC': false,
                                'paneProperties.legendProperties.showLastDayChange': false
                            };

                            // Apply blank chart styling
                            tvWidget.applyOverrides(blankOverrides);
                            
                            // Show success message
                            alert('Chart is now in blank mode! You can manually screenshot it.');
                            
                        }, 1000); // Wait 1 second after stopping animation
                        
                    }, 2000); // Stop animation after 2 seconds
                }, 500); // Wait 500ms for animation to start
                
            } catch (error) {
                console.error('Error creating blank chart:', error);
                alert('Error creating blank chart: ' + error.message);
            }
        }

        // Function to apply custom chart overrides
        function applyChartOverrides() {
            if (!tvWidget) {
                return;
            }
            
            const customOverrides = {
                // Dark theme with proper colors
                'paneProperties.background': '#000000', // Black background
                'paneProperties.backgroundType': 'solid',
                
                // Hide grid lines - correct TradingView API properties
                'paneProperties.vertGridProperties.color': 'rgba(0, 0, 0, 0)', // Transparent vertical grid lines
                'paneProperties.horzGridProperties.color': 'rgba(0, 0, 0, 0)', // Transparent horizontal grid lines
                
                // Green/red candle theme
                'mainSeriesProperties.candleStyle.upColor': '#00d4aa', // Teal green
                'mainSeriesProperties.candleStyle.downColor': '#ff6b6b', // Red
                'mainSeriesProperties.candleStyle.borderUpColor': '#00d4aa',
                'mainSeriesProperties.candleStyle.borderDownColor': '#ff6b6b',
                'mainSeriesProperties.candleStyle.wickUpColor': '#00d4aa',
                'mainSeriesProperties.candleStyle.wickDownColor': '#ff6b6b',
                
                // Hide status lines as requested
                'paneProperties.legendProperties.showBarChange': false, // Hide bar change values
                'paneProperties.legendProperties.showVolume': false, // Hide volume
                'scalesProperties.showSeriesLastValue': false, // Hide chart values
                'scalesProperties.showStudyLastValue': false, // Hide study values
                'paneProperties.legendProperties.showSeriesOHLC': false, // Hide OHLC values
                'paneProperties.legendProperties.showLastDayChange': false // Hide day change
            };

            try {
                tvWidget.applyOverrides(customOverrides);
                shouldApplyCustomStyling = true;
            } catch (error) {
                console.error('Error applying chart overrides:', error);
            }
        }

        function initTradingView() {
            if (tvWidget) {
                tvWidget.remove();
                tvWidget = null;
            }

            console.log('üöÄ Initializing TradingView Advanced Chart...');
            
            const container = document.getElementById('tv_chart_container');
            console.log('üöÄ Chart container found:', !!container);
            console.log('üöÄ Container dimensions:', container ? {
                width: container.offsetWidth,
                height: container.offsetHeight,
                visible: container.offsetParent !== null
            } : 'Container not found');
            
            // Check if TradingView is available
            if (typeof TradingView === 'undefined') {
                console.error('‚ùå TradingView library not loaded!');
                document.getElementById('animation-status').textContent = 'Error: TradingView library not loaded!';
                document.getElementById('animation-status').style.color = '#ff6b6b';
                return;
            }
            
            console.log('‚úÖ TradingView library loaded successfully');

            const currentTokenName = document.getElementById('tokenName')?.value || 'Custom animated token';
            let currentTokenNameWithSOL = currentTokenName;
            if (!currentTokenNameWithSOL.endsWith('/SOL')) {
                currentTokenNameWithSOL = currentTokenName + '/SOL';
            }
            console.log('üöÄ Creating widget with name:', currentTokenNameWithSOL);
            
            tvWidget = new TradingView.widget({
                symbol: currentTokenNameWithSOL,
                interval: '1',
                container: 'tv_chart_container',
                datafeed: globalDatafeed,
                library_path: '',
                locale: 'en',
                theme: 'dark',
                custom_css_url: '',
                overrides: {
                    // Default minimal overrides - custom styling applied via button
                },
                disabled_features: [
                    'save_chart_properties_to_local_storage',
                    'use_localstorage_for_settings',
                    'right_bar_stays_on_scroll',
                    'study_templates',
                    'timeframes_toolbar',
                    'scales_context_menu',
                    'pane_context_menu',
                    'create_volume_indicator_by_default',
                    'header_symbol_search',
                    'header_compare',
                    'header_screenshot',
                    'header_widget',
                    'header_saveload',
                    'header_settings',
                    'header_chart_type',
                    'header_resolutions',
                    'header_snapshot_trading_drawing_tools',
                    'header_indicators',
                    'header_fullscreen_button',
                    'header_undo_redo',
                    'header_interval_dialog_button',
                    'show_interval_dialog_on_key_press',
                    'header_chart_type_dialog_button',
                    'show_chart_type_dialog_on_key_press',
                    'header_symbol_search_dialog_button',
                    'show_symbol_search_dialog_on_key_press',
                    'header_resolutions_dialog_button',
                    'show_resolutions_dialog_on_key_press',
                    'header_screenshot_dialog_button',
                    'show_screenshot_dialog_on_key_press',
                    'header_widget_dialog_button',
                    'show_widget_dialog_on_key_press',
                    'header_saveload_dialog_button',
                    'show_saveload_dialog_on_key_press',
                    'header_settings_dialog_button',
                    'show_settings_dialog_on_key_press',
                    'header_indicators_dialog_button',
                    'show_indicators_dialog_on_key_press',
                    'header_fullscreen_button_dialog_button',
                    'show_fullscreen_button_dialog_on_key_press',
                    'header_undo_redo_dialog_button',
                    'show_undo_redo_dialog_on_key_press'
                ],
                enabled_features: [
                    'move_logo_to_main_pane'
                ],
                fullscreen: false,
                autosize: true,
                studies_overrides: {},
                custom_css_url: null
            });

            tvWidget.onChartReady(() => {
                console.log('‚úÖ TradingView Advanced Chart ready');
                
                // Hide loading message
                const loadingMessage = document.querySelector('#tv_chart_container > div');
                if (loadingMessage) {
                    loadingMessage.style.display = 'none';
                }
                
                // Apply custom styling if flag is set AND toggle is checked (after chart recreation during animation)
                const toggle = document.getElementById('customThemeToggle');
                if (shouldApplyCustomStyling && toggle && toggle.getAttribute('data-enabled') === 'true') {
                    console.log('üé® Re-applying custom styling after chart recreation...');
                    setTimeout(() => {
                        applyChartOverrides();
                    }, 500); // Small delay to ensure chart is fully ready
                } else {
                    console.log('üîÑ Skipping custom styling - toggle not checked or flag not set');
                }
                
                // Debug chart container after ready
                const chartContainer = document.getElementById('tv_chart_container');
                console.log('üìä Chart container after ready:', {
                    exists: !!chartContainer,
                    width: chartContainer?.offsetWidth,
                    height: chartContainer?.offsetHeight,
                    visible: chartContainer?.offsetParent !== null,
                    children: chartContainer?.children?.length || 0
                });
                
                const currentTokenName = document.getElementById('tokenName')?.value || 'Custom animated token';
                let currentTokenNameWithSOL = currentTokenName;
                if (!currentTokenNameWithSOL.endsWith('/SOL')) {
                    currentTokenNameWithSOL = currentTokenName + '/SOL';
                }
                console.log('üîÑ Updating chart name to:', currentTokenNameWithSOL);
                
                setTimeout(() => {
                    tvWidget.setSymbol(currentTokenNameWithSOL, '1', () => {
                        console.log('‚úÖ setSymbol callback executed');
                        
                        setTimeout(() => {
                            try {
                                tvWidget.chart().executeActionById('timeScaleReset');
                                tvWidget.chart().executeActionById('chartReset');
                                tvWidget.chart().executeActionById('dataReset');
                                console.log('‚úÖ Chart refresh commands sent');
                                
                                // Re-apply custom styling after symbol change if needed
                                const toggle = document.getElementById('customThemeToggle');
                                if (shouldApplyCustomStyling && toggle && toggle.getAttribute('data-enabled') === 'true') {
                                    console.log('üé® Re-applying custom styling after symbol change...');
                                    setTimeout(() => {
                                        applyChartOverrides();
                                    }, 200);
                                } else {
                                    console.log('üîÑ Skipping custom styling after symbol change - toggle not checked');
                                }
                            } catch (e) {
                                console.log('‚ùå Chart refresh failed:', e.message);
                            }
                        }, 100);
                    });
                }, 1000);
                
                document.getElementById('animation-status').textContent = 'Chart ready - Position as needed, then click "Apply & Start"';
                document.getElementById('animation-status').style.color = '#26a69a';
                
                window.chartWidget = tvWidget;
                
                console.log('üìä Chart ready - position as needed for marketing material');
            });
        }

        function startAnimationData(config) {
            console.log('üîç Config passed to startAnimationData:', config);
            
            const totalBars = config.totalSeconds;
            const rng = new SeededRandom(config.seed);
            
            let animationStartTime;
            if (config.enableHistoricalData && globalDatafeed.currentData.length > 0) {
                const lastHistoricalBar = globalDatafeed.currentData[globalDatafeed.currentData.length - 1];
                animationStartTime = lastHistoricalBar.time + 60;
                console.log(`üìà Animation starting after historical data at time: ${animationStartTime}`);
            } else {
                animationStartTime = Math.floor(Date.now() / 1000);
                console.log(`üìà Animation starting at current time: ${animationStartTime}`);
            }
            
            console.log(`Generating ${totalBars} bars for animation...`);
            
            const animatedBars = [];
            let lastClose = config.initialMarketCap;
            
            const totalChange = config.finalMarketCap - config.initialMarketCap;
            
            // Add phases for more realistic movement
            const phases = [
                { start: 0, end: 0.2, type: 'consolidation', strength: 0.1 },
                { start: 0.2, end: 0.4, type: 'trend', strength: 0.3 },
                { start: 0.4, end: 0.6, type: 'volatile', strength: 0.8 },
                { start: 0.6, end: 0.8, type: 'consolidation', strength: 0.2 },
                { start: 0.8, end: 1.0, type: 'trend', strength: 0.4 }
            ];
            
            for (let i = 0; i < totalBars - 2; i++) {
                const time = animationStartTime + (i * 60);
                const open = lastClose;
                
                const progressRatio = i / (totalBars - 1);
                
                // Determine current phase
                const currentPhase = phases.find(p => progressRatio >= p.start && progressRatio < p.end) || phases[phases.length - 1];
                
                // Calculate target price with more variation
                let targetPrice;
                if (currentPhase.type === 'consolidation') {
                    // Horizontal trading - stay near current level
                    targetPrice = lastClose + (rng.next() - 0.5) * config.rangeMarketCap * 0.1;
                } else if (currentPhase.type === 'volatile') {
                    // High volatility - large random movements
                    targetPrice = config.initialMarketCap + (totalChange * progressRatio) + (rng.next() - 0.5) * config.rangeMarketCap * 2;
                } else {
                    // Normal trend - gradual movement with some randomness
                    targetPrice = config.initialMarketCap + (totalChange * progressRatio) + (rng.next() - 0.5) * config.rangeMarketCap * 0.5;
                }
                
                const trendStrength = currentPhase.strength;
                const randomStrength = currentPhase.type === 'volatile' ? 1.5 : 0.8;
                
                const trendComponent = (targetPrice - open) * trendStrength;
                const randomComponent = (rng.next() - 0.5) * config.rangeMarketCap * randomStrength;
                
                // More frequent direction changes
                const randomDirectionChance = currentPhase.type === 'volatile' ? 0.6 : 0.4;
                const trendDirection = rng.next() < randomDirectionChance ? (rng.next() - 0.5) * 2 : 1;
                
                // More varied volatility based on phase
                const baseVolatility = currentPhase.type === 'volatile' ? 1.2 : 0.6;
                const volatility = baseVolatility + rng.next() * 0.8;
                
                // More frequent momentum changes
                const momentumChance = currentPhase.type === 'volatile' ? 0.4 : 0.2;
                const momentum = rng.next() < momentumChance ? (rng.next() - 0.5) * 0.6 : 0;
                
                // Add pullback chances
                const pullbackChance = currentPhase.type === 'consolidation' ? 0.3 : 0.1;
                const pullback = rng.next() < pullbackChance ? (rng.next() - 0.5) * config.rangeMarketCap * 0.3 : 0;
                
                let change = (trendComponent * trendDirection) + (randomComponent + momentum + pullback) * volatility;
                
                if (i === 0) {
                    change = Math.abs(change);
                }
                
                let close = open + change;
                
                const effectiveMin = Math.min(config.minMarketCap, config.finalMarketCap);
                if (close < effectiveMin) {
                    close = effectiveMin;
                }
                
                const totalDistance = Math.abs(config.finalMarketCap - config.initialMarketCap);
                const currentProgress = Math.abs(close - config.initialMarketCap) / totalDistance;
                const expectedProgress = i / (totalBars - 1);
                const progressDeviation = Math.abs(currentProgress - expectedProgress);
                
                // More lenient correction - allow more deviation
                if (progressDeviation > 0.7) {
                    const correctionStrength = 0.005 + (progressRatio * 0.01); // Reduced correction
                    const correction = (targetPrice - close) * correctionStrength;
                    close = close + correction;
                }
                
                let high = Math.max(open, close);
                let low = Math.min(open, close);
                
                if (rng.next() < 0.2) {
                    const wickSize = Math.abs(change) * (0.3 + rng.next() * 0.7);
                    if (close > open) {
                        high = Math.max(open, close) + rng.next() * wickSize;
                    } else {
                        low = Math.min(open, close) - rng.next() * wickSize;
                    }
                }
                
                const bar = {
                    time: time,
                    open: open,
                    high: high,
                    low: low,
                    close: close
                };

                animatedBars.push(bar);
                lastClose = close;
            }

            const finalTime = animationStartTime + ((totalBars - 2) * 60);
            const finalOpen = lastClose;
            const finalClose = config.finalMarketCap;
            const finalHigh = Math.max(finalOpen, finalClose);
            const finalLow = Math.min(finalOpen, finalClose);

            animatedBars.push({
                time: finalTime,
                open: finalOpen,
                high: finalHigh,
                low: finalLow,
                close: finalClose
            });

            const actionTime = animationStartTime + ((totalBars - 1) * 60);
            const actionOpen = config.finalMarketCap;
            const actionClose = config.finalActionMarketCap;
            const actionHigh = Math.max(actionOpen, actionClose);
            const actionLow = Math.min(actionOpen, actionClose);

            animatedBars.push({
                time: actionTime,
                open: actionOpen,
                high: actionHigh,
                low: actionLow,
                close: actionClose
            });

            console.log(`Generated ${animatedBars.length} bars for animation`);
            
            document.getElementById('animation-status').textContent = 'Starting animation...';
            document.getElementById('animation-status').style.color = '#26a69a';
            
            startAnimationLoop(animatedBars, config);
        }

        function startAnimationLoop(animatedBars, config) {
            let current = 0;
            const liveBars = [];
            
            console.log(`üìà Datafeed has ${globalDatafeed.currentData.length} bars (including historical data)`);
            
            const baseSpeed = 1000;
            const animationSpeed = baseSpeed / config.speedMultiplier;
            
            let finalAnimationSpeed = animationSpeed;
            if (animationSpeed < 50) {
                finalAnimationSpeed = 100;
            }
            
            document.getElementById('animation-status').textContent = `Speed: ${finalAnimationSpeed}ms per bar (${config.speedMultiplier}x multiplier)`;
            document.getElementById('animation-status').style.color = '#ff9800';
            
            function showNextBar() {
                console.log(`üîÑ Animation loop: current=${current}, animatedBars.length=${animatedBars.length}`);
                if (current < animatedBars.length) {
                    try {
                        liveBars.push(animatedBars[current]);
                        
                        const existingHistoricalData = globalDatafeed.currentData.filter(bar => 
                            animatedBars.length === 0 || bar.time < animatedBars[0].time
                        );
                        globalDatafeed.currentData = [...existingHistoricalData, ...liveBars];
                        
                        const currentBar = liveBars[liveBars.length - 1];
                        const tvBar = {
                            time: currentBar.time * 1000,
                            open: currentBar.open,
                            high: currentBar.high,
                            low: currentBar.low,
                            close: currentBar.close,
                            volume: currentBar.volume || 1000
                        };
                        
                        console.log(`üìä Calling realtime callback with bar:`, tvBar);
                        
                        // Update fakeDEX data based on chart price
                        updateFakeDEXDataFromChart(currentBar.close);
                        
                        if (globalDatafeed.onRealtimeCallback) {
                            try {
                                globalDatafeed.onRealtimeCallback(tvBar);
                                console.log(`üìä Realtime callback called successfully`);
                            } catch (error) {
                                console.error(`‚ùå Error calling realtime callback:`, error);
                            }
                        } else {
                            console.error(`‚ùå No realtime callback available!`);
                        }
                        
                        current++;
                        
                        if (current < animatedBars.length) {
                            const currentSpeed = baseSpeed / config.speedMultiplier;
                            const actualSpeed = currentSpeed < 50 ? 100 : currentSpeed;
                            console.log(`‚è±Ô∏è Setting timeout for next bar in ${actualSpeed}ms (speed multiplier: ${config.speedMultiplier})`);
                            setTimeout(showNextBar, actualSpeed);
                        } else {
                            console.log('‚úÖ Animation complete');
                            document.getElementById('animation-status').textContent = 'Animation complete!';
                            document.getElementById('animation-status').style.color = '#26a69a';
                            
                            // Set final data to use final action market cap
                            setFinalData();
                        }
                    } catch (error) {
                        console.error('Animation error:', error);
                    }
                }
            }
            
            console.log('üöÄ Starting animation loop...');
            showNextBar();
        }

        // Collapsible functionality
        function toggleCollapsible(sectionId) {
            const content = document.getElementById(sectionId + '-content');
            const icon = document.querySelector(`#${sectionId}-content`).previousElementSibling.querySelector('.collapsible-icon');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
                content.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
                content.classList.add('collapsed');
            }
        }

        // Marker management functions
        function addDevMarker() {
            const devMarkers = document.getElementById('dev-markers');
            const markerCount = devMarkers.children.length;
            const newMarker = document.createElement('div');
            newMarker.className = 'marker-item';
            newMarker.innerHTML = `
                <div class="config-item">
                    <label class="tooltip">Dev ${markerCount + 1}:
                        <span class="tooltiptext">Developer marker ${markerCount + 1}. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                    </label>
                    <input type="checkbox" id="showDev${markerCount + 1}" checked>
                </div>
                <div class="config-item">
                    <label class="tooltip">Type:
                        <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                    </label>
                    <select id="dev${markerCount + 1}Type">
                        <option value="buy">Buy</option>
                        <option value="sell">Sell</option>
                    </select>
                </div>
                <div class="config-item">
                    <label class="tooltip">Time:
                        <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                    </label>
                    <input type="number" id="dev${markerCount + 1}Time" value="${markerCount + 1}">
                </div>
                <button type="button" class="remove-marker" onclick="removeDevMarker(this)">üóëÔ∏è</button>
            `;
            devMarkers.appendChild(newMarker);
            updateRemoveButtons();
        }
        
        function removeDevMarker(button) {
            button.parentElement.remove();
            updateRemoveButtons();
        }
        
        function addUserMarker() {
            const userMarkers = document.getElementById('user-markers');
            const markerCount = userMarkers.children.length;
            const newMarker = document.createElement('div');
            newMarker.className = 'marker-item';
            newMarker.innerHTML = `
                <div class="config-item">
                    <label class="tooltip">User ${markerCount + 1}:
                        <span class="tooltiptext">User marker ${markerCount + 1}. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                    </label>
                    <input type="checkbox" id="showUser${markerCount + 1}">
                </div>
                <div class="config-item">
                    <label class="tooltip">Type:
                        <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                    </label>
                    <select id="user${markerCount + 1}Type">
                        <option value="buy" selected>Buy</option>
                        <option value="sell">Sell</option>
                    </select>
                </div>
                <div class="config-item">
                    <label class="tooltip">Time:
                        <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                    </label>
                    <input type="number" id="user${markerCount + 1}Time" value="${markerCount + 1}">
                </div>
                <button type="button" class="remove-marker" onclick="removeUserMarker(this)">üóëÔ∏è</button>
            `;
            userMarkers.appendChild(newMarker);
            updateRemoveButtons();
        }
        
        function removeUserMarker(button) {
            button.parentElement.remove();
            updateRemoveButtons();
        }
        
        function updateRemoveButtons() {
            const devMarkers = document.querySelectorAll('#dev-markers .marker-item');
            const userMarkers = document.querySelectorAll('#user-markers .marker-item');
            
            devMarkers.forEach((marker, index) => {
                const removeBtn = marker.querySelector('.remove-marker');
                if (removeBtn) {
                    const shouldShow = devMarkers.length > 1;
                    removeBtn.style.display = shouldShow ? 'flex' : 'none';
                }
            });
            
            userMarkers.forEach((marker, index) => {
                const removeBtn = marker.querySelector('.remove-marker');
                if (removeBtn) {
                    const shouldShow = userMarkers.length > 1;
                    removeBtn.style.display = shouldShow ? 'flex' : 'none';
                }
            });
        }
    </script>
</body>
</html>
