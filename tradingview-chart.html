<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TradingView Chart - Live Trading Simulation</title>
  
  <!-- TradingView Charting Library -->
  <script type="text/javascript" src="charting_library-master/charting_library/charting_library.standalone.js"></script>
  <script type="text/javascript" src="charting_library-master/datafeeds/udf/dist/bundle.js"></script>
  
  <script src="chart-config.js"></script>
  
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 10px 20px 20px 10px; /* Reduced padding for more space */
      gap: 15px; /* Reduced gap */
      box-sizing: border-box;
    }
    #chart-container {
      flex: 1;
      height: calc(100vh - 20px); /* Minimal padding for maximum height */
      width: calc(100vw - 300px); /* Account for smaller panel (280px + gaps) */
      min-width: 700px; /* Even larger minimum width */
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    /* Force TradingView widget to fill container */
    #chart-container .tv-widget-container {
      width: 100% !important;
      height: 100% !important;
    }
    
    #chart-container .tv-widget-container > div {
      width: 100% !important;
      height: 100% !important;
    }
    
    #chart-container iframe {
      width: 100% !important;
      height: 100% !important;
    }
    
    /* Responsive adjustments for smaller screens */
    @media (max-width: 1200px) {
      body {
        padding: 8px 15px 15px 8px;
        gap: 12px;
      }
      #chart-container {
        max-width: calc(100vw - 340px);
        height: calc(100vh - 30px);
        min-width: 450px;
      }
    }
    
    @media (max-width: 768px) {
      body {
        flex-direction: column;
        align-items: stretch;
        height: auto;
        min-height: 100vh;
        padding: 15px;
        gap: 15px;
      }
      
      #chart-container {
        width: 100%;
        height: 60vh;
        max-width: none;
        max-height: none;
        min-width: auto;
        border-radius: 8px;
      }
      
      #config-panel {
        position: relative;
        width: 100%;
        max-height: 35vh;
        border-radius: 8px;
      }
    }
    
    
    #config-panel {
      position: relative;
      width: 280px; /* Reduced from 320px */
      flex-shrink: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      color: #d1d4dc;
      font-family: Arial, sans-serif;
      font-size: 12px;
      max-height: calc(100vh - 40px); /* Increased height */
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    
    .config-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .config-section {
      margin-bottom: 20px;
      border-bottom: 1px solid #333;
      padding-bottom: 15px;
    }
    
    .config-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    
    .config-section h3 {
      margin: 0 0 10px 0;
      color: #fff;
      font-size: 14px;
      font-weight: bold;
    }
    
    .config-item {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .config-item label {
      flex: 1;
      margin-right: 10px;
      color: #d1d4dc;
    }
    
    .config-item input[type="number"],
    .config-item input[type="text"],
    .config-item select {
      width: 80px;
      padding: 4px 6px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #fff;
      font-size: 11px;
    }
    
    .config-item input[type="checkbox"] {
      margin-left: 10px;
    }
    
    .config-item input[type="number"] {
      width: 50px;
    }
    
    .config-item select {
      width: 60px;
    }
    
    .marker-item {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    
    .marker-item .config-item {
      margin-bottom: 0;
    }
    
    .remove-marker {
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 10px;
      margin-left: auto;
    }
    
    .remove-marker:hover {
      background: #ff6666;
    }
    
    .add-marker {
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 11px;
      margin-bottom: 10px;
      width: 100%;
    }
    
    .add-marker:hover {
      background: #45a049;
    }
    
    .apply-button {
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 12px 20px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      width: 100%;
      margin-top: auto;
    }
    
    .apply-button:hover {
      background: #1976D2;
    }
    
    .apply-button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    /* Tooltip styles */
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #333;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 11px;
      line-height: 1.4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .tooltip .tooltiptext::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -5px;
      border-width: 5px;
      border-style: solid;
      border-color: #333 transparent transparent transparent;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>

<body>
  <div id="config-panel">
    <div class="config-content">
      <div class="config-section">
        <h3>Market Cap</h3>
        <div class="config-item">
          <label class="tooltip">Initial MC:
            <span class="tooltiptext">Starting market cap value for the animation (e.g., 10000).</span>
          </label>
          <input type="number" id="initialMarketCap" value="10000" min="1">
        </div>
        <div class="config-item">
          <label class="tooltip">Final MC:
            <span class="tooltiptext">Target market cap value to reach by the end of animation (e.g., 50000).</span>
          </label>
          <input type="number" id="finalMarketCap" value="50000" min="1">
        </div>
        <div class="config-item">
          <label class="tooltip">Range MC:
            <span class="tooltiptext">Price variation range per candle. Each candle can move +/- this amount from its starting point (e.g., 2000 = Â±2000 variation).</span>
          </label>
          <input type="number" id="rangeMarketCap" value="2000" min="0">
        </div>
      </div>

      <div class="config-section">
        <h3>Animation Timing</h3>
        <div class="config-item">
          <label class="tooltip">Duration (s):
            <span class="tooltiptext">Total animation duration in seconds (e.g., 60).</span>
          </label>
          <input type="number" id="duration" value="60" min="1">
        </div>
        <div class="config-item">
          <label class="tooltip">Candle Interval (s):
            <span class="tooltiptext">Time between each candle update in seconds (e.g., 1).</span>
          </label>
          <input type="number" id="candleInterval" value="1" min="0.1" step="0.1">
        </div>
        <div class="config-item">
          <label class="tooltip">Pre-animation (s):
            <span class="tooltiptext">Historical data duration before animation starts (e.g., 30s, 2h).</span>
          </label>
          <input type="text" id="preAnimationTime" value="30s" placeholder="30s">
        </div>
      </div>

      <div class="config-section">
        <h3>Randomness Control</h3>
        <div class="config-item">
          <label class="tooltip">Seed:
            <span class="tooltiptext">Random seed for reproducible animation (leave empty for random).</span>
          </label>
          <input type="text" id="seed" value="" placeholder="Random">
        </div>
        <div class="config-item">
          <label class="tooltip">Trend Strength:
            <span class="tooltiptext">How strongly the price trends toward the final market cap (0-1, higher = more trending).</span>
          </label>
          <input type="number" id="trendStrength" value="0.3" min="0" max="1" step="0.1">
        </div>
        <div class="config-item">
          <label class="tooltip">Random Strength:
            <span class="tooltiptext">Amount of random variation in price movements (0-1, higher = more random).</span>
          </label>
          <input type="number" id="randomStrength" value="0.4" min="0" max="1" step="0.1">
        </div>
      </div>

      <div class="config-section">
        <h3>Historical Data</h3>
        <div class="config-item">
          <label class="tooltip">Enable Historical:
            <span class="tooltiptext">Generate historical data before animation starts.</span>
          </label>
          <input type="checkbox" id="enableHistorical" checked>
        </div>
      </div>

      <div class="config-section">
        <h3>Final Action</h3>
        <div class="config-item">
          <label class="tooltip">Enable Final Action:
            <span class="tooltiptext">Show a final action marker at the end of animation.</span>
          </label>
          <input type="checkbox" id="enableFinalAction" checked>
        </div>
        <div class="config-item">
          <label class="tooltip">Type:
            <span class="tooltiptext">Type of final action (Pump = Buy, Dump = Sell).</span>
          </label>
          <select id="finalActionType">
            <option value="pump">Pump</option>
            <option value="dump">Dump</option>
          </select>
        </div>
      </div>

      <div class="config-section">
        <h3>Dev Markers</h3>
        <div class="marker-item">
          <div class="config-item">
            <label class="tooltip">Dev 1:
              <span class="tooltiptext">First developer marker at the beginning of animation.</span>
            </label>
            <input type="checkbox" id="showFirstCandle" checked>
          </div>
          <div class="config-item">
            <label class="tooltip">Type:
              <span class="tooltiptext">Marker type (Buy or Sell).</span>
            </label>
            <select id="firstCandleType">
              <option value="buy">Buy</option>
              <option value="sell">Sell</option>
            </select>
          </div>
          <div class="config-item">
            <label class="tooltip">Time:
              <span class="tooltiptext">Time in seconds when marker appears.</span>
            </label>
            <input type="number" id="firstCandleTime" value="1">
          </div>
          <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">ðï¸</button>
        </div>
        
        <div class="marker-item">
          <div class="config-item">
            <label class="tooltip">Dev 2:
              <span class="tooltiptext">Second developer marker at the end of animation.</span>
            </label>
            <input type="checkbox" id="showFinalCandle" checked>
          </div>
          <div class="config-item">
            <label class="tooltip">Type:
              <span class="tooltiptext">Marker type (Buy or Sell).</span>
            </label>
            <select id="finalCandleType">
              <option value="buy">Buy</option>
              <option value="sell">Sell</option>
            </select>
          </div>
          <div class="config-item">
            <label class="tooltip">Time:
              <span class="tooltiptext">Time in seconds when marker appears.</span>
            </label>
            <input type="number" id="finalCandleTime" value="59">
          </div>
          <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">ðï¸</button>
        </div>
        
        <button type="button" class="add-marker" onclick="addDevMarker()">+ Add Dev Marker</button>
        <div id="devMarkers"></div>
      </div>

      <div class="config-section">
        <h3>User Markers</h3>
        <div class="marker-item">
          <div class="config-item">
            <label class="tooltip">User 1:
              <span class="tooltiptext">First user marker during animation.</span>
            </label>
            <input type="checkbox" id="showBMarker" checked>
          </div>
          <div class="config-item">
            <label class="tooltip">Type:
              <span class="tooltiptext">Marker type (Buy or Sell).</span>
            </label>
            <select id="bType">
              <option value="buy">Buy</option>
              <option value="sell">Sell</option>
            </select>
          </div>
          <div class="config-item">
            <label class="tooltip">Time:
              <span class="tooltiptext">Time in seconds when marker appears.</span>
            </label>
            <input type="number" id="bTime" value="30">
          </div>
          <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">ðï¸</button>
        </div>
        
        <div class="marker-item">
          <div class="config-item">
            <label class="tooltip">User 2:
              <span class="tooltiptext">Second user marker during animation.</span>
            </label>
            <input type="checkbox" id="showSMarker" checked>
          </div>
          <div class="config-item">
            <label class="tooltip">Type:
              <span class="tooltiptext">Marker type (Buy or Sell).</span>
            </label>
            <select id="sType">
              <option value="buy">Buy</option>
              <option value="sell">Sell</option>
            </select>
          </div>
          <div class="config-item">
            <label class="tooltip">Time:
              <span class="tooltiptext">Time in seconds when marker appears.</span>
            </label>
            <input type="number" id="sTime" value="45">
          </div>
          <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">ðï¸</button>
        </div>
        
        <button type="button" class="add-marker" onclick="addUserMarker()">+ Add User Marker</button>
        <div id="userMarkers"></div>
      </div>
    </div>
    
    <div style="padding: 20px; border-top: 1px solid #333;">
      <button class="apply-button" onclick="applyAndStart()">Apply & Start</button>
    </div>
  </div>

  <div id="chart-container"></div>

  <script>
    // Global variables
    let tvWidget;
    let animationData = [];
    let currentBarIndex = 0;
    let isAnimating = false;
    let devMarkerCount = 2;
    let userMarkerCount = 2;

    // Custom Datafeed for TradingView
    class CustomDatafeed {
      constructor() {
        this.symbolInfo = {
          ticker: 'CUSTOM',
          name: 'Custom Token',
          description: 'Custom animated token',
          type: 'crypto',
          session: '24x7',
          timezone: 'UTC',
          exchange: 'Custom',
          minmov: 1,
          pricescale: 100,
          has_intraday: true,
          has_weekly_and_monthly: true,
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          volume_precision: 0,
          data_status: 'streaming',
        };
        this.currentData = [];
        this.realtimeCallback = null;
      }

      onReady(callback) {
        setTimeout(() => callback(this.symbolInfo), 0);
      }

      searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {
        onResultReadyCallback([]);
      }

      resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
        setTimeout(() => onSymbolResolvedCallback(this.symbolInfo), 0);
      }

      getBars(symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) {
        console.log('getBars called with data length:', this.currentData.length);
        if (this.currentData.length > 0) {
          onHistoryCallback(this.currentData, { noData: false });
        } else {
          onHistoryCallback([], { noData: true });
        }
      }

      subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) {
        this.realtimeCallback = onRealtimeCallback;
      }

      unsubscribeBars(subscribeUID) {
        this.realtimeCallback = null;
      }

      updateData(newData) {
        console.log('updateData called with', newData.length, 'bars');
        this.currentData = newData;
        if (this.realtimeCallback && newData.length > 0) {
          const latestBar = newData[newData.length - 1];
          console.log('Sending real-time update:', latestBar);
          this.realtimeCallback(latestBar);
        }
      }
    }

    // Global datafeed reference
    let globalDatafeed;

    // Initialize TradingView widget
    function initTradingView() {
      globalDatafeed = new CustomDatafeed();
      
      tvWidget = new TradingView.widget({
        fullscreen: false,
        symbol: 'CUSTOM',
        interval: '1',
        container: 'chart-container',
        datafeed: globalDatafeed,
        library_path: 'charting_library-master/charting_library/',
        locale: 'en',
        theme: 'dark',
        disabled_features: [
          'volume_force_overlay',
          'save_chart_properties_to_local_storage',
          'use_localstorage_for_settings',
          'create_volume_indicator_by_default'
        ],
        enabled_features: [
          'move_logo_to_main_pane',
          'study_templates'
        ],
        // Removed custom_themes due to API error - using default dark theme
        overrides: {
          'mainSeriesProperties.style': 1, // Candlestick
          'mainSeriesProperties.candleStyle.upColor': '#26a69a',
          'mainSeriesProperties.candleStyle.downColor': '#ef5350',
          'mainSeriesProperties.candleStyle.borderUpColor': '#26a69a',
          'mainSeriesProperties.candleStyle.borderDownColor': '#ef5350',
          'mainSeriesProperties.candleStyle.wickUpColor': '#26a69a',
          'mainSeriesProperties.candleStyle.wickDownColor': '#ef5350',
          'paneProperties.background': '#000000',
          'paneProperties.crossHairProperties.color': '#758696',
          'scalesProperties.textColor': '#d1d4dc',
          'scalesProperties.lineColor': '#2a2a2a',
          'volumePaneSize': 'none', // Disable volume pane
          'paneProperties.vertGridProperties.color': '#2a2a2a',
          'paneProperties.horzGridProperties.color': '#2a2a2a',
          'scalesProperties.showSeriesLastValue': true,
          'scalesProperties.showStudyLastValue': false,
          'scalesProperties.showStudyPlotLabels': false,
          'scalesProperties.showBidAskLabels': false,
          'scalesProperties.showSeriesPrevCloseValue': false,
          'scalesProperties.showStudyLastValue': false,
          // Dark theme overrides
          'paneProperties.topMargin': 10,
          'paneProperties.bottomMargin': 10,
          'scalesProperties.backgroundColor': '#000000',
          'scalesProperties.textColor': '#d1d4dc',
          'scalesProperties.lineColor': '#2a2a2a',
          'scalesProperties.showBidAskLabels': false,
          'scalesProperties.showSeriesPrevCloseValue': false,
          'scalesProperties.showStudyLastValue': false,
          'scalesProperties.showStudyPlotLabels': false,
          'scalesProperties.showBidAskLabels': false,
          'scalesProperties.showSeriesPrevCloseValue': false,
          'scalesProperties.showStudyLastValue': false
        },
        studies_overrides: {
          // No volume study overrides needed
        }
      });

      tvWidget.onChartReady(() => {
        console.log('TradingView chart ready');
        // Remove any existing studies to ensure single pane
        tvWidget.chart().removeAllStudies();
        console.log('Removed all studies');
        
        // Force widget to fill container
        setTimeout(() => {
          try {
            const chartContainer = document.getElementById('chart-container');
            if (chartContainer) {
              // Force all child elements to fill container
              const allElements = chartContainer.querySelectorAll('*');
              allElements.forEach(el => {
                if (el.style) {
                  el.style.width = '100%';
                  el.style.height = '100%';
                }
              });
              console.log('Forced widget sizing');
            }
          } catch (e) {
            console.log('Error forcing widget size:', e);
          }
        }, 500);
      });
    }

    // Initialize when page loads
    window.addEventListener('DOMContentLoaded', () => {
      initTradingView();
    });

    // Animation and marker management functions
    function addDevMarker() {
      devMarkerCount++;
      const markerItem = document.createElement('div');
      markerItem.className = 'marker-item';
      markerItem.innerHTML = `
        <div class="config-item">
          <label>Dev Marker ${devMarkerCount}:</label>
          <input type="checkbox" id="showDevMarker${devMarkerCount}" checked>
        </div>
        <div class="config-item">
          <label>Type:</label>
          <select id="devMarkerType${devMarkerCount}">
            <option value="buy">Buy</option>
            <option value="sell">Sell</option>
          </select>
        </div>
        <div class="config-item">
          <label>Time (s):</label>
          <input type="number" id="devMarkerTime${devMarkerCount}" value="30">
        </div>
        <button type="button" class="remove-marker" onclick="removeDevMarker(this)">ðï¸</button>
      `;
      document.getElementById('devMarkers').appendChild(markerItem);
      updateRemoveButtons();
    }

    function addUserMarker() {
      userMarkerCount++;
      const markerItem = document.createElement('div');
      markerItem.className = 'marker-item';
      markerItem.innerHTML = `
        <div class="config-item">
          <label>User Marker ${userMarkerCount}:</label>
          <input type="checkbox" id="showUserMarker${userMarkerCount}" checked>
        </div>
        <div class="config-item">
          <label>Type:</label>
          <select id="userMarkerType${userMarkerCount}">
            <option value="buy">Buy</option>
            <option value="sell">Sell</option>
          </select>
        </div>
        <div class="config-item">
          <label>Time (s):</label>
          <input type="number" id="userMarkerTime${userMarkerCount}" value="30">
        </div>
        <button type="button" class="remove-marker" onclick="removeUserMarker(this)">ðï¸</button>
      `;
      document.getElementById('userMarkers').appendChild(markerItem);
      updateRemoveButtons();
    }

    function removeDevMarker(button) {
      button.parentElement.remove();
      updateRemoveButtons();
    }

    function removeUserMarker(button) {
      button.parentElement.remove();
      updateRemoveButtons();
    }

    function updateRemoveButtons() {
      const devMarkers = document.querySelectorAll('#devMarkers .marker-item');
      const userMarkers = document.querySelectorAll('#userMarkers .marker-item');
      
      // Show remove buttons only if there's more than 2 markers
      devMarkers.forEach((marker, index) => {
        const removeBtn = marker.querySelector('.remove-marker');
        if (removeBtn) {
          removeBtn.style.display = devMarkers.length > 2 ? 'block' : 'none';
        }
      });
      
      userMarkers.forEach((marker, index) => {
        const removeBtn = marker.querySelector('.remove-marker');
        if (removeBtn) {
          removeBtn.style.display = userMarkers.length > 2 ? 'block' : 'none';
        }
      });
    }

    // Seeded Random Number Generator
    class SeededRandom {
      constructor(seed) {
        this.seed = seed || Math.floor(Math.random() * 2147483647);
      }

      next() {
        this.seed = (this.seed * 16807) % 2147483647;
        return (this.seed - 1) / 2147483646;
      }
    }

    // Parse time string to seconds
    function parseTimeToSeconds(timeStr) {
      const time = timeStr.toLowerCase().trim();
      const match = time.match(/^(\d+)([smhd])$/);
      if (!match) return 0;
      
      const value = parseInt(match[1]);
      const unit = match[2];
      
      switch (unit) {
        case 's': return value;
        case 'm': return value * 60;
        case 'h': return value * 3600;
        case 'd': return value * 86400;
        default: return 0;
      }
    }

    // Apply configuration and start animation
    function applyAndStart() {
      if (isAnimating) {
        console.log('Animation already running, stopping first...');
        stopAnimation();
      }
      
      // Get configuration from form
      const config = {
        initialMarketCap: parseInt(document.getElementById('initialMarketCap').value),
        finalMarketCap: parseInt(document.getElementById('finalMarketCap').value),
        rangeMarketCap: parseInt(document.getElementById('rangeMarketCap').value),
        duration: parseInt(document.getElementById('duration').value),
        candleInterval: parseFloat(document.getElementById('candleInterval').value),
        preAnimationTime: document.getElementById('preAnimationTime').value,
        seed: document.getElementById('seed').value || Math.floor(Math.random() * 1000000),
        trendStrength: parseFloat(document.getElementById('trendStrength').value),
        randomStrength: parseFloat(document.getElementById('randomStrength').value),
        enableHistorical: document.getElementById('enableHistorical').checked,
        enableFinalAction: document.getElementById('enableFinalAction').checked,
        finalActionType: document.getElementById('finalActionType').value,
        markers: {
          showFirstCandle: document.getElementById('showFirstCandle').checked,
          firstCandleType: document.getElementById('firstCandleType').value,
          firstCandleTime: parseInt(document.getElementById('firstCandleTime').value),
          showFinalCandle: document.getElementById('showFinalCandle').checked,
          finalCandleType: document.getElementById('finalCandleType').value,
          finalCandleTime: parseInt(document.getElementById('finalCandleTime').value),
          showB: document.getElementById('showBMarker').checked,
          bType: document.getElementById('bType').value,
          bTime: parseInt(document.getElementById('bTime').value),
          showS: document.getElementById('showSMarker').checked,
          sType: document.getElementById('sType').value,
          sTime: parseInt(document.getElementById('sTime').value)
        }
      };

      console.log('Starting animation with config:', config);
      startAnimation(config);
    }

    // Start animation
    function startAnimation(config) {
      isAnimating = true;
      currentBarIndex = 0;
      animationData = [];

      // Initialize seeded random generator
      const rng = new SeededRandom(config.seed);
      console.log(`Using seed: ${config.seed} for reproducible animation`);

      // Generate historical data if enabled
      const preAnimationSeconds = config.enableHistorical ? parseTimeToSeconds(config.preAnimationTime) : 0;
      const historicalData = [];
      
      if (config.enableHistorical && preAnimationSeconds > 0) {
        console.log(`Generating ${preAnimationSeconds} seconds of historical data...`);
        
        let historicalPrice = config.initialMarketCap * (0.5 + rng.next() * 1.0); // 50% to 150% of initial
        
        for (let i = 0; i < preAnimationSeconds; i++) {
          const time = Date.now() - (preAnimationSeconds - i) * 1000;
          const open = historicalPrice;
          
          // Generate realistic price movement
          const change = (rng.next() - 0.5) * config.rangeMarketCap * 0.3;
          const close = Math.max(1, open + change);
          
          const high = Math.max(open, close) + rng.next() * config.rangeMarketCap * 0.1;
          const low = Math.min(open, close) - rng.next() * config.rangeMarketCap * 0.1;
          
          historicalData.push({
            time: time / 1000,
            open: open,
            high: high,
            low: low,
            close: close,
            volume: rng.next() * 2000 + 1000
          });
          
          historicalPrice = close;
        }
        
        // Ensure last historical candle ends at initial market cap
        if (historicalData.length > 0) {
          const lastBar = historicalData[historicalData.length - 1];
          lastBar.close = config.initialMarketCap;
          lastBar.high = Math.max(lastBar.high, config.initialMarketCap);
          lastBar.low = Math.min(lastBar.low, config.initialMarketCap);
        }
      }

      // Generate animation data
      const totalBars = Math.floor(config.duration / config.candleInterval);
      const startTime = Date.now();
      let lastClose = config.initialMarketCap;

      for (let i = 0; i < totalBars; i++) {
        const time = startTime + i * config.candleInterval * 1000;
        const open = lastClose;
        
        // Calculate target price progression
        const progress = i / (totalBars - 1);
        const targetPrice = config.initialMarketCap + (config.finalMarketCap - config.initialMarketCap) * progress;
        
        // Generate price change with trend and randomness
        const trendComponent = (targetPrice - open) * config.trendStrength;
        const randomComponent = (rng.next() - 0.5) * config.rangeMarketCap * config.randomStrength;
        const change = trendComponent + randomComponent;
        
        const close = Math.max(1, open + change);
        const high = Math.max(open, close) + rng.next() * config.rangeMarketCap * 0.1;
        const low = Math.min(open, close) - rng.next() * config.rangeMarketCap * 0.1;
        
        animationData.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
          volume: rng.next() * 2000 + 1000
        });
        
        lastClose = close;
      }

      // Add final action if enabled
      if (config.enableFinalAction) {
        const finalTime = startTime + totalBars * config.candleInterval * 1000;
        const finalOpen = lastClose;
        const finalClose = config.finalActionType === 'pump' ? 
          finalOpen * 1.5 : finalOpen * 0.5;
        
        animationData.push({
          time: finalTime / 1000,
          open: finalOpen,
          high: Math.max(finalOpen, finalClose) * 1.1,
          low: Math.min(finalOpen, finalClose) * 0.9,
          close: finalClose,
          volume: rng.next() * 5000 + 5000
        });
      }

      // Start the animation
      let currentData = [...historicalData];
      
      console.log('Starting animation with', animationData.length, 'bars');
      
      // Set initial data
      if (globalDatafeed) {
        globalDatafeed.updateData(currentData);
      }

      // Animate the data
      const animate = () => {
        if (currentBarIndex < animationData.length && isAnimating) {
          currentData.push(animationData[currentBarIndex]);
          
          // Update datafeed with new data
          if (globalDatafeed) {
            globalDatafeed.updateData(currentData);
          }
          
          // Add markers as needed
          addMarkersForCurrentBar(currentBarIndex, animationData[currentBarIndex], config);
          
          currentBarIndex++;
          setTimeout(animate, config.candleInterval * 1000);
        } else {
          isAnimating = false;
          console.log('Animation completed');
        }
      };

      animate();
    }

    // Add markers for current bar
    function addMarkersForCurrentBar(barIndex, bar, config) {
      if (!tvWidget || !tvWidget.chart) return;
      
      const currentTime = barIndex + 1; // 1-based time
      const markers = [];
      
      // Check for Dev markers
      if (config.markers.showFirstCandle && currentTime === config.markers.firstCandleTime) {
        const type = config.markers.firstCandleType;
        markers.push({
          time: bar.time,
          position: 'aboveBar',
          color: type === 'buy' ? '#26a69a' : '#ef5350',
          shape: 'circle',
          text: `D${type.charAt(0).toUpperCase()}`,
          size: 3
        });
      }
      
      if (config.markers.showFinalCandle && currentTime === config.markers.finalCandleTime) {
        const type = config.markers.finalCandleType;
        markers.push({
          time: bar.time,
          position: 'aboveBar',
          color: type === 'buy' ? '#26a69a' : '#ef5350',
          shape: 'circle',
          text: `D${type.charAt(0).toUpperCase()}`,
          size: 3
        });
      }
      
      // Check for User markers
      if (config.markers.showB && currentTime === config.markers.bTime) {
        const type = config.markers.bType;
        markers.push({
          time: bar.time,
          position: 'aboveBar',
          color: type === 'buy' ? '#26a69a' : '#ef5350',
          shape: 'circle',
          text: type.charAt(0).toUpperCase(),
          size: 3
        });
      }
      
      if (config.markers.showS && currentTime === config.markers.sTime) {
        const type = config.markers.sType;
        markers.push({
          time: bar.time,
          position: 'aboveBar',
          color: type === 'buy' ? '#26a69a' : '#ef5350',
          shape: 'circle',
          text: type.charAt(0).toUpperCase(),
          size: 3
        });
      }
      
      // Add markers to chart
      if (markers.length > 0) {
        // Note: TradingView Charting Library handles markers differently
        // This is a simplified approach - you may need to use TradingView's marker API
        console.log('Markers to add:', markers);
      }
    }

    // Stop animation
    function stopAnimation() {
      isAnimating = false;
    }
  </script>
</body>
</html>
