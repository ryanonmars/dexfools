<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lightweight Chart Test - Live Trading Simulation</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #chart-container {
      width: 900px;
      height: 540px;
      margin: 0 auto;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    #main-chart {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Try to override marker text color */
    #main-chart canvas {
      filter: none;
    }
    
    /* Custom marker styling */
    .tv-lightweight-charts .marker-text {
      color: white !important;
      fill: white !important;
    }
    
  </style>
</head>
<body>
  <div id="chart-container">
    <div id="main-chart"></div>
  </div>
  <script>
    // Robust market cap formatter
    function marketCapFormatter(price) {
      if (price >= 1_000_000_000) {
        return (price / 1_000_000_000) % 1 === 0
          ? `${(price / 1_000_000_000).toFixed(0)}B`
          : `${(price / 1_000_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}B`;
      }
      if (price >= 1_000_000) {
        return (price / 1_000_000) % 1 === 0
          ? `${(price / 1_000_000).toFixed(0)}M`
          : `${(price / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (price >= 1_000) {
        return (price / 1_000) % 1 === 0
          ? `${(price / 1_000).toFixed(0)}K`
          : `${(price / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return price.toFixed(0);
    }

    // Volume formatter
    function volumeFormatter(volume) {
      if (volume >= 1_000_000) {
        return (volume / 1_000_000) % 1 === 0
          ? `${(volume / 1_000_000).toFixed(0)}M`
          : `${(volume / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (volume >= 1_000) {
        return (volume / 1_000) % 1 === 0
          ? `${(volume / 1_000).toFixed(0)}K`
          : `${(volume / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return volume.toFixed(0);
    }

    const mainChartDiv = document.getElementById('main-chart');
    
    // Wait for DOM to be ready and ensure dimensions are available
    setTimeout(() => {
      const chart = LightweightCharts.createChart(mainChartDiv, {
        width: mainChartDiv.clientWidth,
        height: mainChartDiv.clientHeight,
        layout: {
          background: { color: '#000' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#222' },
          horzLines: { color: '#222' },
        },
        rightPriceScale: {
          priceFormatter: marketCapFormatter,
        },
        leftPriceScale: {
          visible: false,
        },
        timeScale: {
          rightOffset: 20,
          timeVisible: true,
          secondsVisible: true,
          borderVisible: false,
        },
      });

      const series = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: marketCapFormatter,
        },
        priceScaleId: 'right',
      });

      // Adjust main price scale to use top 70% of chart
      chart.priceScale('right').applyOptions({
        scaleMargins: {
          top: 0,
          bottom: 0.3,  // Candlesticks take up top 70% of chart
        },
      });

      const volumeSeries = chart.addHistogramSeries({
        color: 'rgba(38, 166, 154, 0.3)', // 30% opacity for up volume
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: volumeFormatter,
        },
        priceScaleId: 'volume',
      });

      // Add a separate price scale for volume
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.7,  // Volume takes up bottom 30% of chart
          bottom: 0,
        },
        priceFormatter: volumeFormatter,
      });

      // Don't add marker here - wait for animation to complete

      // Try to override marker text color after chart is created
      setTimeout(() => {
        const style = document.createElement('style');
        style.textContent = `
          .tv-lightweight-charts .marker-text,
          .tv-lightweight-charts text,
          .tv-lightweight-charts tspan {
            fill: white !important;
            color: white !important;
          }
        `;
        document.head.appendChild(style);
        console.log('Added marker text color override');
      }, 1000);

      // Start the animation after chart is ready
      startAnimation(series, volumeSeries);
    }, 100);

    function startAnimation(series, volumeSeries) {
      // Generate data
      const bars = [];
      const volumeData = [];
      const startTime = Date.now() - 50 * 1000; // 50 seconds ago
      const basePrice = 10_000; // Start at 10K market cap
      let lastClose = basePrice;

      // First 8 bars are forced uptrend
      for (let i = 0; i < 8; i++) {
        const time = startTime + i * 1000; // 1 second intervals
        const open = lastClose;
        const change = Math.random() * 2000 + 500; // 500-2500 increase
        const close = open + change;
        const high = close + Math.random() * 1000;
        const low = open - Math.random() * 500;
        
        bars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        const volume = Math.random() * 2000 + 1000;
        volumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
        lastClose = close;
      }

      // Random trading between 3K and 40K
      for (let i = 8; i < 49; i++) {
        const time = startTime + i * 1000; // 1 second intervals
        const open = lastClose;
        const change = (Math.random() - 0.5) * 4000; // -2000 to +2000
        let close = open + change;
        
        // Clamp between 3K and 40K
        close = Math.max(3_000, Math.min(40_000, close));
        
        const high = Math.max(open, close) + Math.random() * 1000;
        const low = Math.min(open, close) - Math.random() * 1000;
        
        bars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        const volume = Math.random() * 2000 + 1000;
        volumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
        lastClose = close;
      }

      // Final candle (the big one)
      const finalTime = startTime + 49 * 1000; // 1 second intervals
      const finalOpen = lastClose;
      const finalClose = 1_000_000; // 1M market cap
      const finalHigh = finalClose + Math.random() * 100_000;
      const finalLow = finalOpen - Math.random() * 10_000;
      
      bars.push({
        time: finalTime / 1000,
        open: finalOpen,
        high: finalHigh,
        low: finalLow,
        close: finalClose,
      });
      
      const finalVolume = Math.random() * 5000 + 5000;
      volumeData.push({
        time: finalTime / 1000,
        value: finalVolume,
        color: 'rgba(38, 166, 154, 0.3)',
      });

      let current = 0;
      const liveBars = [];
      const liveVolume = [];

      function animateFinalCandle(liveBars, liveVolume, openValue, targetValue, steps, duration) {
        let step = 0;
        const stepDuration = duration / steps;
        const stepSize = (targetValue - openValue) / steps;
        
        function grow() {
          if (step < steps) {
            const currentValue = openValue + (stepSize * step);
            const currentHigh = currentValue + Math.random() * 1000;
            const currentLow = Math.min(openValue, currentValue) - Math.random() * 500;
            
            liveBars[liveBars.length - 1] = {
              ...liveBars[liveBars.length - 1],
              close: currentValue,
              high: currentHigh,
              low: currentLow,
            };
            
            series.setData(liveBars);
            volumeSeries.setData(liveVolume);
            step++;
            setTimeout(grow, stepDuration);
          }
        }
        grow();
      }

      function showNextBar() {
        if (current < bars.length) {
          try {
            liveBars.push(bars[current]);
            liveVolume.push(volumeData[current]);
            series.setData(liveBars);
            volumeSeries.setData(liveVolume);
            
            // Add green circle above the first candle when it appears
            if (current === 0) {
              // Use built-in marker for correct positioning
              const myMarkers = [
                {
                  time: bars[0].time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: '',  // No text, just circle
                  size: 3  // Bigger circle for better visibility
                }
              ];
              series.setMarkers(myMarkers);
              console.log('Added larger green circle above first candle');
            }
            
            current++;
            
            // Check if this was the last bar
            if (current === bars.length) {
              // Animate the final candle's growth
              const openValue = liveBars[liveBars.length - 1].open;
              const targetValue = 1_000_000;
              animateFinalCandle(liveBars, liveVolume, openValue, targetValue, 60, 4000);
            } else if (current === bars.length - 1) {
              setTimeout(showNextBar, 1000); // 1 second pause before the last candle
            } else {
              setTimeout(showNextBar, 200); // 0.2 second per candle
            }
          } catch (error) {
            console.error('Animation error:', error);
          }
        }
      }
      showNextBar();
    }
  </script>
</body>
</html>