<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lightweight Chart Test - Live Trading Simulation</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="chart-config.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #chart-container {
      width: 900px;
      height: 540px;
      margin: 0 auto;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    #main-chart {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Try to override marker text color */
    #main-chart canvas {
      filter: none;
    }
    
    /* Custom marker styling */
    .tv-lightweight-charts .marker-text {
      color: white !important;
      fill: white !important;
    }
    
  </style>
</head>
<body>
  <div id="chart-container">
    <div id="main-chart"></div>
  </div>
  <script>
    // Robust market cap formatter
    function marketCapFormatter(price) {
      if (price >= 1_000_000_000) {
        return (price / 1_000_000_000) % 1 === 0
          ? `${(price / 1_000_000_000).toFixed(0)}B`
          : `${(price / 1_000_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}B`;
      }
      if (price >= 1_000_000) {
        return (price / 1_000_000) % 1 === 0
          ? `${(price / 1_000_000).toFixed(0)}M`
          : `${(price / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (price >= 1_000) {
        return (price / 1_000) % 1 === 0
          ? `${(price / 1_000).toFixed(0)}K`
          : `${(price / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return price.toFixed(0);
    }

    // Volume formatter
    function volumeFormatter(volume) {
      if (volume >= 1_000_000) {
        return (volume / 1_000_000) % 1 === 0
          ? `${(volume / 1_000_000).toFixed(0)}M`
          : `${(volume / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (volume >= 1_000) {
        return (volume / 1_000) % 1 === 0
          ? `${(volume / 1_000).toFixed(0)}K`
          : `${(volume / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return volume.toFixed(0);
    }

    const mainChartDiv = document.getElementById('main-chart');
    
    // Wait for DOM to be ready and ensure dimensions are available
    setTimeout(() => {
      const chart = LightweightCharts.createChart(mainChartDiv, {
        width: mainChartDiv.clientWidth,
        height: mainChartDiv.clientHeight,
        layout: {
          background: { color: '#000' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#222' },
          horzLines: { color: '#222' },
        },
        rightPriceScale: {
          priceFormatter: marketCapFormatter,
        },
        leftPriceScale: {
          visible: false,
        },
        timeScale: {
          rightOffset: 20,
          timeVisible: true,
          secondsVisible: true,
          borderVisible: false,
        },
      });

      const series = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: marketCapFormatter,
        },
        priceScaleId: 'right',
      });

      // Adjust main price scale to use top 70% of chart
      chart.priceScale('right').applyOptions({
        scaleMargins: {
          top: 0,
          bottom: 0.3,  // Candlesticks take up top 70% of chart
        },
      });

      const volumeSeries = chart.addHistogramSeries({
        color: 'rgba(38, 166, 154, 0.3)', // 30% opacity for up volume
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: volumeFormatter,
        },
        priceScaleId: 'volume',
      });

      // Add a separate price scale for volume
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.7,  // Volume takes up bottom 30% of chart
          bottom: 0,
        },
        priceFormatter: volumeFormatter,
      });

      // Don't add marker here - wait for animation to complete

      // Try to override marker text color after chart is created
      setTimeout(() => {
        const style = document.createElement('style');
        style.textContent = `
          .tv-lightweight-charts .marker-text,
          .tv-lightweight-charts text,
          .tv-lightweight-charts tspan {
            fill: white !important;
            color: white !important;
          }
        `;
        document.head.appendChild(style);
        console.log('Added marker text color override');
      }, 1000);

      // Start the animation after chart is ready
      startAnimation(series, volumeSeries);
    }, 100);

    function startAnimation(series, volumeSeries) {
      // Use configuration values
      const config = chartConfig;
      const totalBars = config.totalSeconds; // Number of bars = number of seconds
      
      // Generate data
      const bars = [];
      const volumeData = [];
      const startTime = Date.now() - totalBars * 1000; // X seconds ago
      const basePrice = config.initialMarketCap; // Start at configured market cap
      let lastClose = basePrice;

      // Start with initial market cap and begin random trading
      for (let i = 0; i < totalBars - 2; i++) { // -2 because we'll add final candle and action candle
        const time = startTime + i * 1000; // 1 second intervals
        const open = lastClose;
        
        // Random trading within the configured range
        let change = (Math.random() - 0.5) * config.rangeMarketCap * 2; // +/- range
        
        // First candle should always be a buy (green)
        if (i === 0) {
          change = Math.abs(change); // Force positive change for first candle
        }
        
        let close = open + change;
        
        // Clamp within range around initial market cap, but never below minMarketCap
        const minPrice = Math.max(config.minMarketCap, config.initialMarketCap - config.rangeMarketCap);
        const maxPrice = config.initialMarketCap + config.rangeMarketCap;
        close = Math.max(minPrice, Math.min(maxPrice, close));
        
        const high = Math.max(open, close) + Math.random() * (config.rangeMarketCap * 0.1);
        const low = Math.min(open, close) - Math.random() * (config.rangeMarketCap * 0.1);
        
        bars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        const volume = Math.random() * 2000 + 1000;
        volumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
        lastClose = close;
      }


      // Final candle (the big one)
      const finalTime = startTime + (totalBars - 1) * 1000; // 1 second intervals
      const finalOpen = lastClose;
      const finalClose = Math.max(config.minMarketCap, config.finalMarketCap); // Use configured final market cap, never below minMarketCap
      const finalHigh = finalClose + Math.random() * (finalClose * 0.1); // 10% of final MC
      const finalLow = Math.max(config.minMarketCap, finalOpen - Math.random() * (finalOpen * 0.05)); // 5% of open, never below minMarketCap
      
      bars.push({
        time: finalTime / 1000,
        open: finalOpen,
        high: finalHigh,
        low: finalLow,
        close: finalClose,
      });
      
      const finalVolume = Math.random() * 5000 + 5000;
      volumeData.push({
        time: finalTime / 1000,
        value: finalVolume,
        color: 'rgba(38, 166, 154, 0.3)',
      });

      // Add dump/pump action candle
      const actionTime = startTime + totalBars * 1000;
      const actionOpen = finalClose;
      const actionClose = Math.max(config.minMarketCap, config.finalAction.marketCap); // Never below minMarketCap
      const actionHigh = Math.max(actionOpen, actionClose) + Math.random() * (Math.abs(actionClose - actionOpen) * 0.1);
      const actionLow = Math.max(config.minMarketCap, Math.min(actionOpen, actionClose) - Math.random() * (Math.abs(actionClose - actionOpen) * 0.1)); // Never below minMarketCap
      
      bars.push({
        time: actionTime / 1000,
        open: actionOpen,
        high: actionHigh,
        low: actionLow,
        close: actionClose,
      });
      
      const actionVolume = Math.random() * 10000 + 10000; // Higher volume for action
      volumeData.push({
        time: actionTime / 1000,
        value: actionVolume,
        color: actionClose > actionOpen ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
      });

      let current = 0;
      const liveBars = [];
      const liveVolume = [];


      function showNextBar() {
        if (current < bars.length) {
          try {
            liveBars.push(bars[current]);
            liveVolume.push(volumeData[current]);
            series.setData(liveBars);
            volumeSeries.setData(liveVolume);
            
            // Add green circle above the first candle when it appears
            if (current === 0) {
              // Use built-in marker for correct positioning
              const myMarkers = [
                {
                  time: bars[0].time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: '',  // No text, just circle
                  size: 3  // Bigger circle for better visibility
                }
              ];
              series.setMarkers(myMarkers);
              console.log('Added larger green circle above first candle');
            }
            
            current++;
            
            // Check if this was the last bar
            if (current === bars.length) {
              // No animation - just show the final values as they are
              console.log('Animation complete - showing final values');
            } else {
              setTimeout(showNextBar, config.chartStyle.candleSpeed); // Configurable speed per candle
            }
          } catch (error) {
            console.error('Animation error:', error);
          }
        }
      }
      showNextBar();
    }
  </script>
</body>
</html>