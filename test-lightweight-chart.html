<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lightweight Chart Test - Live Trading Simulation</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="chart-config.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #chart-container {
      width: 900px;
      height: 540px;
      margin: 0 auto;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    #restart-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #26a69a;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
      transition: background-color 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #restart-button:hover {
      background: #1e8b7f;
    }
    
    #restart-button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    #main-chart {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Try to override marker text color */
    #main-chart canvas {
      filter: none;
    }
    
    /* Custom marker styling */
    .tv-lightweight-charts .marker-text {
      color: white !important;
      fill: white !important;
    }
    
  </style>
</head>
<body>
  <button id="restart-button">Restart Animation</button>
  <div id="chart-container">
    <div id="main-chart"></div>
  </div>
  <script>
    // Robust market cap formatter
    function marketCapFormatter(price) {
      if (price >= 1_000_000_000) {
        return (price / 1_000_000_000) % 1 === 0
          ? `${(price / 1_000_000_000).toFixed(0)}B`
          : `${(price / 1_000_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}B`;
      }
      if (price >= 1_000_000) {
        return (price / 1_000_000) % 1 === 0
          ? `${(price / 1_000_000).toFixed(0)}M`
          : `${(price / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (price >= 1_000) {
        return (price / 1_000) % 1 === 0
          ? `${(price / 1_000).toFixed(0)}K`
          : `${(price / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return price.toFixed(0);
    }

    // Volume formatter
    function volumeFormatter(volume) {
      if (volume >= 1_000_000) {
        return (volume / 1_000_000) % 1 === 0
          ? `${(volume / 1_000_000).toFixed(0)}M`
          : `${(volume / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (volume >= 1_000) {
        return (volume / 1_000) % 1 === 0
          ? `${(volume / 1_000).toFixed(0)}K`
          : `${(volume / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return volume.toFixed(0);
    }

    const mainChartDiv = document.getElementById('main-chart');
    const restartButton = document.getElementById('restart-button');
    
    // Global variables to store chart references
    let chart = null;
    let series = null;
    let volumeSeries = null;
    let currentAnimation = null;
    
    // Function to configure chart for auto-following animation
    function configureAutoFollow() {
      if (!chart) return;
      
      // Enable auto-scaling to follow the animation
      chart.timeScale().applyOptions({
        shiftVisibleRangeOnNewBar: true,
        rightBarStaysOnScroll: true
      });
      
      // Configure main chart with proper separation
      chart.priceScale('right').applyOptions({
        autoScale: true,
        scaleMargins: {
          top: 0.15,  // 15% buffer at top for markers
          bottom: 0.4  // Candlesticks take up top 60% of chart
        }
      });
      
      // Configure volume with proper separation
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.6,  // Volume takes up bottom 40% of chart
          bottom: 0
        }
      });
    }
    
    // Function to clear all data and markers
    function clearChartData() {
      if (series) {
        series.setData([]);
        series.setMarkers([]);
      }
      if (volumeSeries) {
        volumeSeries.setData([]);
      }
    }
    
    
    // Function to restart animation
    function restartAnimation() {
      if (!chart || !series || !volumeSeries) {
        console.error('Chart or series not available');
        return;
      }
      
      console.log('Starting animation restart...');
      
      // Disable button during animation
      restartButton.disabled = true;
      restartButton.textContent = 'Animating...';
      
      // Configure chart to auto-follow the animation
      configureAutoFollow();
      
      // Clear existing data
      clearChartData();
      
      // Clear any existing animation
      if (currentAnimation) {
        clearTimeout(currentAnimation);
        currentAnimation = null;
      }
      
      // Start new animation
      startAnimation(series, volumeSeries, () => {
        console.log('Animation completed');
        // Animation complete callback
        restartButton.disabled = false;
        restartButton.textContent = 'Restart Animation';
      });
    }
    
    // Add event listener to restart button
    restartButton.addEventListener('click', restartAnimation);
    
    // Wait for DOM to be ready and ensure dimensions are available
    setTimeout(() => {
      chart = LightweightCharts.createChart(mainChartDiv, {
        width: mainChartDiv.clientWidth,
        height: mainChartDiv.clientHeight,
        layout: {
          background: { color: '#000' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#222' },
          horzLines: { color: '#222' },
        },
        rightPriceScale: {
          priceFormatter: marketCapFormatter,
        },
        leftPriceScale: {
          visible: false,
        },
        timeScale: {
          rightOffset: 20,
          timeVisible: true,
          secondsVisible: true,
          borderVisible: false,
        },
      });

      series = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: marketCapFormatter,
        },
        priceScaleId: 'right',
      });

      // Adjust main price scale to use top 60% of chart
      chart.priceScale('right').applyOptions({
        scaleMargins: {
          top: 0,
          bottom: 0.4,  // Candlesticks take up top 60% of chart
        },
      });

      volumeSeries = chart.addHistogramSeries({
        color: 'rgba(38, 166, 154, 0.3)', // 30% opacity for up volume
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: volumeFormatter,
        },
        priceScaleId: 'volume',
      });

      // Add a separate price scale for volume
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.6,  // Volume takes up bottom 40% of chart
          bottom: 0,
        },
        priceFormatter: volumeFormatter,
      });

      // Don't add marker here - wait for animation to complete

      // Try to override marker text color after chart is created
      setTimeout(() => {
        const style = document.createElement('style');
        style.textContent = `
          .tv-lightweight-charts .marker-text,
          .tv-lightweight-charts text,
          .tv-lightweight-charts tspan {
            fill: white !important;
            color: white !important;
          }
        `;
        document.head.appendChild(style);
        console.log('Added marker text color override');
      }, 1000);

      // Configure chart to auto-follow the animation
      configureAutoFollow();
      
      // Start the animation after chart is ready
      startAnimation(series, volumeSeries, () => {
        console.log('Initial animation completed');
      });
    }, 100);

    function startAnimation(series, volumeSeries, onComplete) {
      console.log('startAnimation called with onComplete:', !!onComplete);
      
      // Use configuration values
      const config = chartConfig;
      const totalBars = config.totalSeconds; // Number of bars = number of seconds
      
      // Generate data
      const bars = [];
      const volumeData = [];
      const startTime = Date.now() - totalBars * 1000; // X seconds ago
      const basePrice = config.initialMarketCap; // Start at configured market cap
      let lastClose = basePrice;

      // Start with initial market cap and begin random trading
      for (let i = 0; i < totalBars - 2; i++) { // -2 because we'll add final candle and action candle
        const time = startTime + i * 1000; // 1 second intervals
        const open = lastClose;
        
        // Random trading within the configured range
        let change = (Math.random() - 0.5) * config.rangeMarketCap * 2; // +/- range
        
        // First candle should always be a buy (green)
        if (i === 0) {
          change = Math.abs(change); // Force positive change for first candle
        }
        
        let close = open + change;
        
        // Clamp within range around initial market cap, but never below minMarketCap
        const minPrice = Math.max(config.minMarketCap, config.initialMarketCap - config.rangeMarketCap);
        const maxPrice = config.initialMarketCap + config.rangeMarketCap;
        close = Math.max(minPrice, Math.min(maxPrice, close));
        
        const high = Math.max(open, close) + Math.random() * (config.rangeMarketCap * 0.1);
        const low = Math.min(open, close) - Math.random() * (config.rangeMarketCap * 0.1);
        
        bars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        const volume = Math.random() * 2000 + 1000;
        volumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
        lastClose = close;
      }


      // Final candle (the big one)
      const finalTime = startTime + (totalBars - 1) * 1000; // 1 second intervals
      const finalOpen = lastClose;
      const finalClose = Math.max(config.minMarketCap, config.finalMarketCap); // Use configured final market cap, never below minMarketCap
      const finalHigh = finalClose + Math.random() * (finalClose * 0.1); // 10% of final MC
      const finalLow = Math.max(config.minMarketCap, finalOpen - Math.random() * (finalOpen * 0.05)); // 5% of open, never below minMarketCap
      
      bars.push({
        time: finalTime / 1000,
        open: finalOpen,
        high: finalHigh,
        low: finalLow,
        close: finalClose,
      });
      
      const finalVolume = Math.random() * 5000 + 5000;
      volumeData.push({
        time: finalTime / 1000,
        value: finalVolume,
        color: 'rgba(38, 166, 154, 0.3)',
      });

      // Add dump/pump action candle
      const actionTime = startTime + totalBars * 1000;
      const actionOpen = finalClose;
      const actionClose = Math.max(config.minMarketCap, config.finalAction.marketCap); // Never below minMarketCap
      const actionHigh = Math.max(actionOpen, actionClose) + Math.random() * (Math.abs(actionClose - actionOpen) * 0.1);
      const actionLow = Math.max(config.minMarketCap, Math.min(actionOpen, actionClose) - Math.random() * (Math.abs(actionClose - actionOpen) * 0.1)); // Never below minMarketCap
      
      bars.push({
        time: actionTime / 1000,
        open: actionOpen,
        high: actionHigh,
        low: actionLow,
        close: actionClose,
      });
      
      const actionVolume = Math.random() * 10000 + 10000; // Higher volume for action
      volumeData.push({
        time: actionTime / 1000,
        value: actionVolume,
        color: actionClose > actionOpen ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
      });

      let current = 0;
      const liveBars = [];
      const liveVolume = [];

      function showNextBar() {
        if (current < bars.length) {
          try {
            liveBars.push(bars[current]);
            liveVolume.push(volumeData[current]);
            series.setData(liveBars);
            volumeSeries.setData(liveVolume);
            
            // Add green circle above the first candle when it appears
            if (current === 0 && config.markers.showFirstCandle) {
              // Use built-in marker for correct positioning
              const myMarkers = [
                {
                  time: bars[0].time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: config.markers.firstCandleText || 'B',  // Use config text
                  size: 3  // Bigger circle for better visibility
                }
              ];
              series.setMarkers(myMarkers);
              console.log('Added marker above first candle:', config.markers.firstCandleText);
            }
            
            current++;
            
            // Check if this was the last bar
            if (current === bars.length) {
              // Add marker to final action candle if enabled
              if (config.markers.showFinalCandle) {
                // Build array of all markers (preserve existing ones)
                const allMarkers = [];
                
                // Add first candle marker if enabled
                if (config.markers.showFirstCandle) {
                  allMarkers.push({
                    time: bars[0].time,
                    position: 'aboveBar',
                    color: '#26a69a',
                    shape: 'circle',
                    text: config.markers.firstCandleText || 'B',
                    size: 3
                  });
                }
                
                // Add final action marker
                allMarkers.push({
                  time: bars[bars.length - 1].time,
                  position: 'aboveBar',
                  color: config.finalAction.type === 'pump' ? '#26a69a' : '#ef5350',  // Green for pump, red for dump
                  shape: 'circle',
                  text: config.markers.finalCandleText || (config.finalAction.type === 'pump' ? 'B' : 'S'),
                  size: 3
                });
                
                series.setMarkers(allMarkers);
                console.log('Added all markers - first and final');
              }
              console.log('Animation complete - showing final values');
              
              // Call completion callback if provided
              if (onComplete) {
                onComplete();
              }
            } else {
              currentAnimation = setTimeout(showNextBar, config.chartStyle.candleSpeed); // Configurable speed per candle
            }
          } catch (error) {
            console.error('Animation error:', error);
          }
        }
      }
      showNextBar();
    }
  </script>
</body>
</html>