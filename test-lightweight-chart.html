<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lightweight Chart Test - Live Trading Simulation</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="chart-config.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #chart-container {
      width: 900px;
      height: 540px;
      margin: 0 auto;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    #restart-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #26a69a;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
      transition: background-color 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #restart-button:hover {
      background: #1e8b7f;
    }
    
    #restart-button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    
    #config-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 300px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 20px;
      color: #d1d4dc;
      font-family: Arial, sans-serif;
      font-size: 12px;
      z-index: 1000;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #config-panel h3 {
      margin: 0 0 15px 0;
      color: #26a69a;
      font-size: 16px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }
    
    .config-group {
      margin-bottom: 20px;
    }
    
    .config-group h4 {
      margin: 0 0 10px 0;
      color: #fff;
      font-size: 14px;
    }
    
    .config-item {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .config-item label {
      flex: 1;
      margin-right: 10px;
    }
    
    .config-item input, .config-item select {
      width: 80px;
      padding: 4px 6px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #d1d4dc;
      font-size: 11px;
    }
    
    .config-item input[type="checkbox"] {
      width: auto;
    }
    
    .config-item input[type="number"] {
      width: 60px;
    }
    
    .config-item input[type="text"] {
      width: 100px;
    }
    
    #apply-config {
      width: 100%;
      padding: 8px;
      background: #26a69a;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-top: 10px;
    }
    
    #apply-config:hover {
      background: #1e8b7f;
    }
    #main-chart {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Try to override marker text color */
    #main-chart canvas {
      filter: none;
    }
    
    /* Custom marker styling */
    .tv-lightweight-charts .marker-text {
      color: white !important;
      fill: white !important;
    }
    
  </style>
</head>
<body>
  <button id="restart-button">Restart Animation</button>
  
  <div id="config-panel">
    <h3>Chart Configuration</h3>
    
    <div class="config-group">
      <h4>Market Cap Settings</h4>
      <div class="config-item">
        <label>Initial MC:</label>
        <input type="number" id="initialMarketCap" value="16000">
      </div>
      <div class="config-item">
        <label>Final MC:</label>
        <input type="number" id="finalMarketCap" value="20000">
      </div>
      <div class="config-item">
        <label>Min MC:</label>
        <input type="number" id="minMarketCap" value="2000">
      </div>
      <div class="config-item">
        <label>Range MC:</label>
        <input type="number" id="rangeMarketCap" value="5000">
      </div>
    </div>
    
    <div class="config-group">
      <h4>Animation Timing</h4>
      <div class="config-item">
        <label>Duration (s):</label>
        <input type="number" id="totalSeconds" value="60">
      </div>
      <div class="config-item">
        <label>Speed Multiplier:</label>
        <input type="number" id="speedMultiplier" value="2" step="0.1">
      </div>
    </div>
    
    <div class="config-group">
      <h4>Randomness Control</h4>
      <div class="config-item">
        <label>Seed:</label>
        <input type="number" id="seed" value="1">
      </div>
    </div>
    
    <div class="config-group">
      <h4>Historical Data</h4>
      <div class="config-item">
        <label>Enable:</label>
        <input type="checkbox" id="enableHistoricalData">
      </div>
      <div class="config-item">
        <label>Time:</label>
        <input type="text" id="preAnimationTime" value="2h" placeholder="e.g., 2h, 60s">
      </div>
    </div>
    
    <div class="config-group">
      <h4>Final Action</h4>
      <div class="config-item">
        <label>Type:</label>
        <select id="finalActionType">
          <option value="dump">Dump</option>
          <option value="pump">Pump</option>
        </select>
      </div>
      <div class="config-item">
        <label>Target MC:</label>
        <input type="number" id="finalActionMarketCap" value="1000">
      </div>
    </div>
    
    <div class="config-group">
      <h4>Markers</h4>
      <div class="config-item">
        <label>Show First:</label>
        <input type="checkbox" id="showFirstCandle" checked>
      </div>
      <div class="config-item">
        <label>First Text:</label>
        <input type="text" id="firstCandleText" value="DB">
      </div>
      <div class="config-item">
        <label>Show Final:</label>
        <input type="checkbox" id="showFinalCandle" checked>
      </div>
      <div class="config-item">
        <label>Final Text:</label>
        <input type="text" id="finalCandleText" value="DS">
      </div>
      <div class="config-item">
        <label>Show B Marker:</label>
        <input type="checkbox" id="showB" checked>
      </div>
      <div class="config-item">
        <label>B Time (s):</label>
        <input type="number" id="bTime" value="57">
      </div>
      <div class="config-item">
        <label>Show S Marker:</label>
        <input type="checkbox" id="showS">
      </div>
      <div class="config-item">
        <label>S Time (s):</label>
        <input type="number" id="sTime" value="15">
      </div>
    </div>
    
    <button id="apply-config">Apply & Restart</button>
  </div>
  
  <div id="chart-container">
    <div id="main-chart"></div>
  </div>
  <script>
    // Robust market cap formatter
    function marketCapFormatter(price) {
      if (price >= 1_000_000_000) {
        return (price / 1_000_000_000) % 1 === 0
          ? `${(price / 1_000_000_000).toFixed(0)}B`
          : `${(price / 1_000_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}B`;
      }
      if (price >= 1_000_000) {
        return (price / 1_000_000) % 1 === 0
          ? `${(price / 1_000_000).toFixed(0)}M`
          : `${(price / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (price >= 1_000) {
        return (price / 1_000) % 1 === 0
          ? `${(price / 1_000).toFixed(0)}K`
          : `${(price / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return price.toFixed(0);
    }

    // Volume formatter
    function volumeFormatter(volume) {
      if (volume >= 1_000_000) {
        return (volume / 1_000_000) % 1 === 0
          ? `${(volume / 1_000_000).toFixed(0)}M`
          : `${(volume / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (volume >= 1_000) {
        return (volume / 1_000) % 1 === 0
          ? `${(volume / 1_000).toFixed(0)}K`
          : `${(volume / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return volume.toFixed(0);
    }

    // Parse time string to seconds
    function parseTimeToSeconds(timeString) {
      const timeStr = timeString.toLowerCase().trim();
      const match = timeStr.match(/^(\d+)([smhd])$/);
      
      if (!match) {
        console.warn(`Invalid time format: ${timeString}. Using default 1 hour.`);
        return 3600; // Default to 1 hour
      }
      
      const value = parseInt(match[1]);
      const unit = match[2];
      
      switch (unit) {
        case 's': return value; // seconds
        case 'm': return value * 60; // minutes
        case 'h': return value * 3600; // hours
        case 'd': return value * 86400; // days
        default: return 3600; // Default to 1 hour
      }
    }

    // Seeded random number generator (Linear Congruential Generator)
    class SeededRandom {
      constructor(seed) {
        this.seed = seed;
      }
      
      // Generate next random number between 0 and 1
      next() {
        this.seed = (this.seed * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.seed / Math.pow(2, 32);
      }
      
      // Generate random number between min and max
      range(min, max) {
        return min + this.next() * (max - min);
      }
      
      // Generate random integer between min and max (inclusive)
      int(min, max) {
        return Math.floor(this.range(min, max + 1));
      }
      
      // Generate random boolean
      bool() {
        return this.next() < 0.5;
      }
    }

    const mainChartDiv = document.getElementById('main-chart');
    const restartButton = document.getElementById('restart-button');
    const applyConfigButton = document.getElementById('apply-config');
    
    // Global variables to store chart references
    let chart = null;
    let series = null;
    let volumeSeries = null;
    let currentAnimation = null;
    
    // Function to populate config form with current values
    function populateConfigForm() {
      const config = chartConfig;
      
      // Market Cap Settings
      document.getElementById('initialMarketCap').value = config.initialMarketCap;
      document.getElementById('finalMarketCap').value = config.finalMarketCap;
      document.getElementById('minMarketCap').value = config.minMarketCap;
      document.getElementById('rangeMarketCap').value = config.rangeMarketCap;
      
      // Animation Timing
      document.getElementById('totalSeconds').value = config.totalSeconds;
      document.getElementById('speedMultiplier').value = config.speedMultiplier;
      
      // Randomness Control
      document.getElementById('seed').value = config.seed;
      
      // Historical Data
      document.getElementById('enableHistoricalData').checked = config.enableHistoricalData;
      document.getElementById('preAnimationTime').value = config.preAnimationTime;
      
      // Final Action
      document.getElementById('finalActionType').value = config.finalAction.type;
      document.getElementById('finalActionMarketCap').value = config.finalAction.marketCap;
      
      // Markers
      document.getElementById('showFirstCandle').checked = config.markers.showFirstCandle;
      document.getElementById('firstCandleText').value = config.markers.firstCandleText;
      document.getElementById('showFinalCandle').checked = config.markers.showFinalCandle;
      document.getElementById('finalCandleText').value = config.markers.finalCandleText;
      document.getElementById('showB').checked = config.markers.userMarkers.showB;
      document.getElementById('bTime').value = config.markers.userMarkers.bTime;
      document.getElementById('showS').checked = config.markers.userMarkers.showS;
      document.getElementById('sTime').value = config.markers.userMarkers.sTime;
    }
    
    // Function to apply config changes
    function applyConfigChanges() {
      const config = chartConfig;
      
      // Market Cap Settings
      config.initialMarketCap = parseInt(document.getElementById('initialMarketCap').value);
      config.finalMarketCap = parseInt(document.getElementById('finalMarketCap').value);
      config.minMarketCap = parseInt(document.getElementById('minMarketCap').value);
      config.rangeMarketCap = parseInt(document.getElementById('rangeMarketCap').value);
      
      // Animation Timing
      config.totalSeconds = parseInt(document.getElementById('totalSeconds').value);
      config.speedMultiplier = parseFloat(document.getElementById('speedMultiplier').value);
      
      // Randomness Control
      config.seed = parseInt(document.getElementById('seed').value);
      
      // Historical Data
      config.enableHistoricalData = document.getElementById('enableHistoricalData').checked;
      config.preAnimationTime = document.getElementById('preAnimationTime').value;
      
      // Final Action
      config.finalAction.type = document.getElementById('finalActionType').value;
      config.finalAction.marketCap = parseInt(document.getElementById('finalActionMarketCap').value);
      
      // Markers
      config.markers.showFirstCandle = document.getElementById('showFirstCandle').checked;
      config.markers.firstCandleText = document.getElementById('firstCandleText').value;
      config.markers.showFinalCandle = document.getElementById('showFinalCandle').checked;
      config.markers.finalCandleText = document.getElementById('finalCandleText').value;
      config.markers.userMarkers.showB = document.getElementById('showB').checked;
      config.markers.userMarkers.bTime = parseInt(document.getElementById('bTime').value);
      config.markers.userMarkers.showS = document.getElementById('showS').checked;
      config.markers.userMarkers.sTime = parseInt(document.getElementById('sTime').value);
      
      console.log('Configuration updated:', config);
      
      // Restart animation with new config
      restartAnimation();
    }
    
    // Function to configure chart for auto-following animation
    function configureAutoFollow() {
      if (!chart) return;
      
      // Enable auto-scaling to follow the animation
      chart.timeScale().applyOptions({
        shiftVisibleRangeOnNewBar: true,
        rightBarStaysOnScroll: true
      });
      
      // Configure main chart with proper separation
      chart.priceScale('right').applyOptions({
        autoScale: true,
        scaleMargins: {
          top: 0.15,  // 15% buffer at top for markers
          bottom: 0.4  // Candlesticks take up top 60% of chart
        }
      });
      
      // Configure volume with proper separation
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.6,  // Volume takes up bottom 40% of chart
          bottom: 0
        }
      });
    }
    
    // Function to clear all data and markers
    function clearChartData() {
      if (series) {
        series.setData([]);
        series.setMarkers([]);
      }
      if (volumeSeries) {
        volumeSeries.setData([]);
      }
    }
    
    
    
    // Function to restart animation
    function restartAnimation() {
      if (!chart || !series || !volumeSeries) {
        console.error('Chart or series not available');
        return;
      }
      
      console.log('Starting animation restart...');
      
      // Disable button during animation
      restartButton.disabled = true;
      restartButton.textContent = 'Animating...';
      
      // Configure chart to auto-follow the animation
      configureAutoFollow();
      
      // Clear existing data
      clearChartData();
      
      // Clear any existing animation
      if (currentAnimation) {
        clearTimeout(currentAnimation);
        currentAnimation = null;
      }
      
      // Start new animation
      startAnimation(series, volumeSeries, () => {
        console.log('Animation completed');
        // Animation complete callback
        restartButton.disabled = false;
        restartButton.textContent = 'Restart Animation';
      });
    }
    
    // Add event listeners
    restartButton.addEventListener('click', restartAnimation);
    applyConfigButton.addEventListener('click', applyConfigChanges);
    
    // Initialize config form
    populateConfigForm();
    
    // Wait for DOM to be ready and ensure dimensions are available
    setTimeout(() => {
      chart = LightweightCharts.createChart(mainChartDiv, {
        width: mainChartDiv.clientWidth,
        height: mainChartDiv.clientHeight,
        layout: {
          background: { color: '#000' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#222' },
          horzLines: { color: '#222' },
        },
        rightPriceScale: {
          priceFormatter: marketCapFormatter,
        },
        leftPriceScale: {
          visible: false,
        },
        timeScale: {
          rightOffset: 20,
          timeVisible: true,
          secondsVisible: true,
          borderVisible: false,
        },
      });

      series = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: marketCapFormatter,
        },
        priceScaleId: 'right',
      });

      // Adjust main price scale to use top 60% of chart
      chart.priceScale('right').applyOptions({
        scaleMargins: {
          top: 0,
          bottom: 0.4,  // Candlesticks take up top 60% of chart
        },
      });

      volumeSeries = chart.addHistogramSeries({
        color: 'transparent', // Hide the volume line
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: volumeFormatter,
        },
        priceScaleId: 'volume',
        priceLineVisible: false, // Hide the horizontal price line
        lastValueVisible: false, // Hide the last value label
      });

      // Add a separate price scale for volume
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.6,  // Volume takes up bottom 40% of chart
          bottom: 0,
        },
        priceFormatter: volumeFormatter,
      });

      // Don't add marker here - wait for animation to complete

      // Try to override marker text color after chart is created
      setTimeout(() => {
        const style = document.createElement('style');
        style.textContent = `
          .tv-lightweight-charts .marker-text,
          .tv-lightweight-charts text,
          .tv-lightweight-charts tspan {
            fill: white !important;
            color: white !important;
          }
        `;
        document.head.appendChild(style);
        console.log('Added marker text color override');
      }, 1000);

      // Configure chart to auto-follow the animation
      configureAutoFollow();
      
      // Start the animation after chart is ready
      startAnimation(series, volumeSeries, () => {
        console.log('Initial animation completed');
      });
    }, 100);

    function startAnimation(series, volumeSeries, onComplete) {
      console.log('startAnimation called with onComplete:', !!onComplete);
      
      // Use configuration values
      const config = chartConfig;
      const totalBars = config.totalSeconds; // Number of bars = number of seconds
      const preAnimationSeconds = config.enableHistoricalData ? parseTimeToSeconds(config.preAnimationTime) : 0;
      
      // Initialize seeded random generator
      const rng = new SeededRandom(config.seed);
      console.log(`Using seed: ${config.seed} for reproducible animation`);
      
      // Generate data
      const bars = [];
      const volumeData = [];
      const animationStartTime = Date.now() - totalBars * 1000; // When animation starts
      const historicalStartTime = animationStartTime - preAnimationSeconds * 1000; // Historical data starts here
      const basePrice = config.initialMarketCap; // Start at configured market cap
      let lastClose = basePrice;

      // Generate pre-animation historical data with completely natural variation (if enabled)
      if (config.enableHistoricalData && preAnimationSeconds > 0) {
        console.log(`Generating ${preAnimationSeconds} seconds of pre-animation history...`);
        
        // Start historical data from a completely random point - no constraints
        let historicalPrice = config.initialMarketCap * (0.1 + rng.next() * 1.8); // 10% to 190% of initial MC
        
        // Add some momentum and trend variables for more realistic behavior
        let momentum = 0;
        let trend = 0;
        let lastTrendChange = 0;
        
        for (let i = 0; i < preAnimationSeconds; i++) {
        const time = historicalStartTime + i * 1000; // 1 second intervals
        const open = historicalPrice;
        
        // Create more natural price movements with reduced volatility
        // Base volatility that changes over time - much smaller range
        const baseVolatility = config.rangeMarketCap * (0.1 + rng.next() * 0.3); // 0.1x to 0.4x range (much smaller)
        
        // Add momentum (price tends to continue in same direction) - reduced impact
        momentum = momentum * 0.95 + (rng.next() - 0.5) * 0.05; // Decay momentum with less randomness
        
        // Add trend changes (market can trend up or down for periods) - less frequent
        if (i - lastTrendChange > 100 + rng.next() * 300) { // Change trend every 100-400 seconds (less frequent)
          trend = (rng.next() - 0.5) * 0.5; // -0.5 to 0.5 trend (smaller trend impact)
          lastTrendChange = i;
        }
        
        // Calculate price change with multiple factors - much smaller changes
        let change = 0;
        
        // Random walk component - reduced
        change += (rng.next() - 0.5) * baseVolatility * 0.5; // Half the random walk impact
        
        // Momentum component - reduced
        change += momentum * baseVolatility * 0.1; // Much smaller momentum impact
        
        // Trend component - reduced
        change += trend * baseVolatility * 0.05; // Much smaller trend impact
        
        // Occasional big moves (news events, etc.) - much less frequent and smaller
        if (rng.next() < 0.005) { // 0.5% chance of big move (was 2%)
          const bigMoveDirection = rng.next() < 0.5 ? 1 : -1;
          change += bigMoveDirection * baseVolatility * (1 + rng.next() * 1.5); // 1-2.5x normal move (was 2-5x)
        }
        
        // Add some mean reversion (prices tend to come back toward a "fair value")
        const meanReversion = (config.initialMarketCap - historicalPrice) * 0.01; // 1% pull toward initial
        change += meanReversion;
        
        let close = open + change;
        
        // NO HARD CONSTRAINTS - let the price be completely natural
        // Only prevent completely unrealistic values (negative prices or astronomical values)
        if (close < 1) close = 1; // Minimum $1
        if (close > config.initialMarketCap * 100) close = config.initialMarketCap * 100; // Maximum 100x initial
        
        // Create realistic high/low - only add wicks occasionally (like real charts)
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Only add wicks 20% of the time (more realistic)
        if (rng.next() < 0.2) {
          const wickSize = Math.abs(change) * (0.3 + rng.next() * 0.7); // 0.3-1x the change (smaller wicks)
          
          if (close > open) {
            // Green candle: only add wick on top
            high = Math.max(open, close) + rng.next() * wickSize;
          } else {
            // Red candle: only add wick on bottom
            low = Math.min(open, close) - rng.next() * wickSize;
          }
        }
        
        bars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        // More realistic volume that correlates with price movement
        const baseVolume = 200 + rng.next() * 1500; // 200-1700 base
        const volumeMultiplier = 1 + Math.abs(change) / config.rangeMarketCap; // Higher volume on bigger moves
        const volume = baseVolume * volumeMultiplier + rng.next() * 1000;
        
        volumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
          historicalPrice = close;
        }
        
        // Ensure the last historical candle always ends at the initial market cap
        if (bars.length > 0) {
          const lastBar = bars[bars.length - 1];
          const lastVolume = volumeData[volumeData.length - 1];
          
          // Adjust the last candle to close at initial market cap
          lastBar.close = config.initialMarketCap;
          lastBar.high = Math.max(lastBar.high, config.initialMarketCap);
          lastBar.low = Math.min(lastBar.low, config.initialMarketCap);
          
          // Update volume color based on new close price
          lastVolume.color = config.initialMarketCap > lastBar.open ? 
            'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)';
          
          // Update historical price to match
          historicalPrice = config.initialMarketCap;
        }
        
        // Set the historical data immediately (no animation for this part)
        series.setData(bars);
        volumeSeries.setData(volumeData);
        console.log(`Pre-animation history loaded: ${bars.length} bars, ending at MC: ${config.initialMarketCap}`);
      } else {
        console.log('Historical data disabled - starting animation immediately');
        // Set empty data to start fresh
        series.setData([]);
        volumeSeries.setData([]);
      }

      // Now generate the animated data starting from the initial market cap
      const startTime = animationStartTime;
      lastClose = config.initialMarketCap;


      // Generate animated data (this will be added to the existing historical data)
      const animatedBars = [];
      const animatedVolumeData = [];
      
      // Start with initial market cap and begin random trading
      for (let i = 0; i < totalBars - 2; i++) { // -2 because we'll add final candle and action candle
        const time = startTime + i * 1000; // 1 second intervals
        const open = lastClose;
        
        // Random trading within the configured range - much smaller movements
        let change = (rng.next() - 0.5) * config.rangeMarketCap * 0.3; // +/- 30% of range (was 200%)
        
        // First candle should always be a buy (green)
        if (i === 0) {
          change = Math.abs(change); // Force positive change for first candle
        }
        
        let close = open + change;
        
        // Apply soft resistance beyond the normal range for more natural movement
        const normalMin = Math.max(config.minMarketCap, config.initialMarketCap - config.rangeMarketCap);
        const normalMax = config.initialMarketCap + config.rangeMarketCap;
        const bufferZone = config.rangeMarketCap * 0.3; // 30% buffer zone
        
        // Soft resistance: gradually reduce movement as we go beyond normal range
        if (close < normalMin) {
          const excess = normalMin - close;
          const resistance = Math.min(excess / bufferZone, 1); // 0 to 1 resistance factor
          close = normalMin - (excess * (1 - resistance * 0.7)); // Reduce excess by up to 70%
        } else if (close > normalMax) {
          const excess = close - normalMax;
          const resistance = Math.min(excess / bufferZone, 1); // 0 to 1 resistance factor
          close = normalMax + (excess * (1 - resistance * 0.7)); // Reduce excess by up to 70%
        }
        
        // Hard limits only at extreme values
        const absoluteMin = Math.max(config.minMarketCap, config.initialMarketCap - config.rangeMarketCap - bufferZone);
        const absoluteMax = config.initialMarketCap + config.rangeMarketCap + bufferZone;
        close = Math.max(absoluteMin, Math.min(absoluteMax, close));
        
        // Create realistic high/low - only add wicks occasionally (like real charts)
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Only add wicks 20% of the time (more realistic)
        if (rng.next() < 0.2) {
          const wickSize = config.rangeMarketCap * (0.02 + rng.next() * 0.08); // 2-10% of range (smaller wicks)
          
          if (close > open) {
            // Green candle: only add wick on top
            high = Math.max(open, close) + rng.next() * wickSize;
          } else {
            // Red candle: only add wick on bottom
            low = Math.min(open, close) - rng.next() * wickSize;
          }
        }
        
        animatedBars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        const volume = rng.next() * 2000 + 1000;
        animatedVolumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
        lastClose = close;
      }

      // Final candle (the big one)
      const finalTime = startTime + (totalBars - 1) * 1000; // 1 second intervals
      const finalOpen = lastClose;
      const finalClose = Math.max(config.minMarketCap, config.finalMarketCap); // Use configured final market cap, never below minMarketCap
      
      // Create realistic high/low - only add wicks occasionally
      let finalHigh = Math.max(finalOpen, finalClose);
      let finalLow = Math.min(finalOpen, finalClose);
      
      // Only add wicks 20% of the time (more realistic)
      if (rng.next() < 0.2) {
        const wickSize = Math.abs(finalClose - finalOpen) * (0.2 + rng.next() * 0.8); // 0.2-1x the change (smaller wicks)
        
        if (finalClose > finalOpen) {
          // Green candle: only add wick on top
          finalHigh = Math.max(finalOpen, finalClose) + rng.next() * wickSize;
        } else {
          // Red candle: only add wick on bottom
          finalLow = Math.min(finalOpen, finalClose) - rng.next() * wickSize;
        }
      }
      
      animatedBars.push({
        time: finalTime / 1000,
        open: finalOpen,
        high: finalHigh,
        low: finalLow,
        close: finalClose,
      });
      
      const finalVolume = rng.next() * 5000 + 5000;
      animatedVolumeData.push({
        time: finalTime / 1000,
        value: finalVolume,
        color: 'rgba(38, 166, 154, 0.3)',
      });

      // Add dump/pump action candle
      const actionTime = startTime + totalBars * 1000;
      const actionOpen = finalClose;
      const actionClose = Math.max(config.minMarketCap, config.finalAction.marketCap); // Never below minMarketCap
      
      // Create realistic high/low - only add wicks occasionally
      let actionHigh = Math.max(actionOpen, actionClose);
      let actionLow = Math.min(actionOpen, actionClose);
      
      // Only add wicks 20% of the time (more realistic)
      if (rng.next() < 0.2) {
        const wickSize = Math.abs(actionClose - actionOpen) * (0.2 + rng.next() * 0.8); // 0.2-1x the change (smaller wicks)
        
        if (actionClose > actionOpen) {
          // Green candle: only add wick on top
          actionHigh = Math.max(actionOpen, actionClose) + rng.next() * wickSize;
        } else {
          // Red candle: only add wick on bottom
          actionLow = Math.min(actionOpen, actionClose) - rng.next() * wickSize;
        }
      }
      
      animatedBars.push({
        time: actionTime / 1000,
        open: actionOpen,
        high: actionHigh,
        low: actionLow,
        close: actionClose,
      });
      
      const actionVolume = rng.next() * 10000 + 10000; // Higher volume for action
      animatedVolumeData.push({
        time: actionTime / 1000,
        value: actionVolume,
        color: actionClose > actionOpen ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
      });

      let current = 0;
      const liveBars = [...bars]; // Start with historical data
      const liveVolume = [...volumeData]; // Start with historical volume data

      function showNextBar() {
        if (current < animatedBars.length) {
          try {
            liveBars.push(animatedBars[current]);
            liveVolume.push(animatedVolumeData[current]);
            series.setData(liveBars);
            volumeSeries.setData(liveVolume);
            
            // Add green circle above the first animated candle when it appears
            if (current === 0 && config.markers.showFirstCandle) {
              // Use built-in marker for correct positioning
              const myMarkers = [
                {
                  time: animatedBars[0].time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: config.markers.firstCandleText || 'DB',  // Use config text
                  size: 3,  // Bigger circle for better visibility
                  offsetY: -20  // Move marker higher above the candle
                }
              ];
              series.setMarkers(myMarkers);
              console.log('Added marker above first animated candle:', config.markers.firstCandleText);
            }
            
            // Check for user markers (B and S) as we progress through the animation
            const currentBar = animatedBars[current];
            const userMarkers = config.markers.userMarkers;
            const existingMarkers = series.markers() || [];
            let markersToAdd = [];
            
            // Calculate current time in seconds (each bar is 1 second)
            const currentTime = current;
            
            console.log(`Bar ${current}: Time=${currentTime}s, MC=${currentBar.close}, B target=${userMarkers.bTime}s, S target=${userMarkers.sTime}s`);
            
            // Check for B marker at specific time
            if (userMarkers.showB && userMarkers.bTime !== undefined && !existingMarkers.some(m => m.text === (userMarkers.bText || 'B'))) {
              if (currentTime === userMarkers.bTime) {
                markersToAdd.push({
                  time: currentBar.time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: userMarkers.bText || 'B',
                  size: 3,
                  offsetY: -20
                });
                console.log(`B marker triggered at time: ${currentTime}s (target: ${userMarkers.bTime}s)`);
              }
            }
            
            // Check for S marker at specific time
            if (userMarkers.showS && userMarkers.sTime !== undefined && !existingMarkers.some(m => m.text === (userMarkers.sText || 'S'))) {
              if (currentTime === userMarkers.sTime) {
                markersToAdd.push({
                  time: currentBar.time,
                  position: 'aboveBar',
                  color: '#ef5350',
                  shape: 'circle',
                  text: userMarkers.sText || 'S',
                  size: 3,
                  offsetY: -20
                });
                console.log(`S marker triggered at time: ${currentTime}s (target: ${userMarkers.sTime}s)`);
              }
            }
            
            // Add new markers if any were triggered
            if (markersToAdd.length > 0) {
              const allMarkers = [...existingMarkers, ...markersToAdd];
              series.setMarkers(allMarkers);
              console.log(`Added ${markersToAdd.length} new markers`);
            }
            
            current++;
            
            // Check if this was the last bar
            if (current === animatedBars.length) {
              // Add marker to final action candle if enabled
              if (config.markers.showFinalCandle) {
                // Get existing markers (including user markers added during animation)
                const existingMarkers = series.markers() || [];
                const allMarkers = [...existingMarkers];
                
                // Add first animated candle marker if enabled and not already present
                if (config.markers.showFirstCandle && !existingMarkers.some(m => m.text === config.markers.firstCandleText)) {
                  allMarkers.push({
                    time: animatedBars[0].time,
                    position: 'aboveBar',
                    color: '#26a69a',
                    shape: 'circle',
                    text: config.markers.firstCandleText || 'DB',
                    size: 3,
                    offsetY: -20  // Move marker higher above the candle
                  });
                }
                
                // Add final action marker if not already present
                const finalMarkerText = config.markers.finalCandleText || (config.finalAction.type === 'pump' ? 'B' : 'S');
                if (!existingMarkers.some(m => m.text === finalMarkerText)) {
                  allMarkers.push({
                    time: animatedBars[animatedBars.length - 1].time,
                    position: 'aboveBar',
                    color: config.finalAction.type === 'pump' ? '#26a69a' : '#ef5350',  // Green for pump, red for dump
                    shape: 'circle',
                    text: finalMarkerText,
                    size: 3,
                    offsetY: -20  // Move marker higher above the candle
                  });
                }
                
                series.setMarkers(allMarkers);
                console.log('Added all markers - preserved user markers and added first/final');
              }
              console.log('Animation complete - showing final values');
              
              // Call completion callback if provided
              if (onComplete) {
                onComplete();
              }
            } else {
              // Apply speed multiplier to candle speed
              const actualCandleSpeed = config.chartStyle.candleSpeed / config.speedMultiplier;
              currentAnimation = setTimeout(showNextBar, actualCandleSpeed);
            }
          } catch (error) {
            console.error('Animation error:', error);
          }
        }
      }
      showNextBar();
    }
  </script>
</body>
</html>