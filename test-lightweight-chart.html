<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lightweight Chart Test - Live Trading Simulation</title>
  <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="chart-config.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #chart-container {
      width: 900px;
      height: 540px;
      margin: 0 auto;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    #restart-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #26a69a;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
      transition: background-color 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    #restart-button:hover {
      background: #1e8b7f;
    }
    
    #restart-button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    #main-chart {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    /* Try to override marker text color */
    #main-chart canvas {
      filter: none;
    }
    
    /* Custom marker styling */
    .tv-lightweight-charts .marker-text {
      color: white !important;
      fill: white !important;
    }
    
  </style>
</head>
<body>
  <button id="restart-button">Restart Animation</button>
  <div id="chart-container">
    <div id="main-chart"></div>
  </div>
  <script>
    // Robust market cap formatter
    function marketCapFormatter(price) {
      if (price >= 1_000_000_000) {
        return (price / 1_000_000_000) % 1 === 0
          ? `${(price / 1_000_000_000).toFixed(0)}B`
          : `${(price / 1_000_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}B`;
      }
      if (price >= 1_000_000) {
        return (price / 1_000_000) % 1 === 0
          ? `${(price / 1_000_000).toFixed(0)}M`
          : `${(price / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (price >= 1_000) {
        return (price / 1_000) % 1 === 0
          ? `${(price / 1_000).toFixed(0)}K`
          : `${(price / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return price.toFixed(0);
    }

    // Volume formatter
    function volumeFormatter(volume) {
      if (volume >= 1_000_000) {
        return (volume / 1_000_000) % 1 === 0
          ? `${(volume / 1_000_000).toFixed(0)}M`
          : `${(volume / 1_000_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}M`;
      }
      if (volume >= 1_000) {
        return (volume / 1_000) % 1 === 0
          ? `${(volume / 1_000).toFixed(0)}K`
          : `${(volume / 1_000).toFixed(2).replace(/0+$/, '').replace(/\.$/, '')}K`;
      }
      return volume.toFixed(0);
    }

    // Parse time string to seconds
    function parseTimeToSeconds(timeString) {
      const timeStr = timeString.toLowerCase().trim();
      const match = timeStr.match(/^(\d+)([smhd])$/);
      
      if (!match) {
        console.warn(`Invalid time format: ${timeString}. Using default 1 hour.`);
        return 3600; // Default to 1 hour
      }
      
      const value = parseInt(match[1]);
      const unit = match[2];
      
      switch (unit) {
        case 's': return value; // seconds
        case 'm': return value * 60; // minutes
        case 'h': return value * 3600; // hours
        case 'd': return value * 86400; // days
        default: return 3600; // Default to 1 hour
      }
    }

    const mainChartDiv = document.getElementById('main-chart');
    const restartButton = document.getElementById('restart-button');
    
    // Global variables to store chart references
    let chart = null;
    let series = null;
    let volumeSeries = null;
    let currentAnimation = null;
    
    // Function to configure chart for auto-following animation
    function configureAutoFollow() {
      if (!chart) return;
      
      // Enable auto-scaling to follow the animation
      chart.timeScale().applyOptions({
        shiftVisibleRangeOnNewBar: true,
        rightBarStaysOnScroll: true
      });
      
      // Configure main chart with proper separation
      chart.priceScale('right').applyOptions({
        autoScale: true,
        scaleMargins: {
          top: 0.15,  // 15% buffer at top for markers
          bottom: 0.4  // Candlesticks take up top 60% of chart
        }
      });
      
      // Configure volume with proper separation
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.6,  // Volume takes up bottom 40% of chart
          bottom: 0
        }
      });
    }
    
    // Function to clear all data and markers
    function clearChartData() {
      if (series) {
        series.setData([]);
        series.setMarkers([]);
      }
      if (volumeSeries) {
        volumeSeries.setData([]);
      }
    }
    
    
    
    // Function to restart animation
    function restartAnimation() {
      if (!chart || !series || !volumeSeries) {
        console.error('Chart or series not available');
        return;
      }
      
      console.log('Starting animation restart...');
      
      // Disable button during animation
      restartButton.disabled = true;
      restartButton.textContent = 'Animating...';
      
      // Configure chart to auto-follow the animation
      configureAutoFollow();
      
      // Clear existing data
      clearChartData();
      
      // Clear any existing animation
      if (currentAnimation) {
        clearTimeout(currentAnimation);
        currentAnimation = null;
      }
      
      // Start new animation
      startAnimation(series, volumeSeries, () => {
        console.log('Animation completed');
        // Animation complete callback
        restartButton.disabled = false;
        restartButton.textContent = 'Restart Animation';
      });
    }
    
    // Add event listener to restart button
    restartButton.addEventListener('click', restartAnimation);
    
    // Wait for DOM to be ready and ensure dimensions are available
    setTimeout(() => {
      chart = LightweightCharts.createChart(mainChartDiv, {
        width: mainChartDiv.clientWidth,
        height: mainChartDiv.clientHeight,
        layout: {
          background: { color: '#000' },
          textColor: '#d1d4dc',
        },
        grid: {
          vertLines: { color: '#222' },
          horzLines: { color: '#222' },
        },
        rightPriceScale: {
          priceFormatter: marketCapFormatter,
        },
        leftPriceScale: {
          visible: false,
        },
        timeScale: {
          rightOffset: 20,
          timeVisible: true,
          secondsVisible: true,
          borderVisible: false,
        },
      });

      series = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: marketCapFormatter,
        },
        priceScaleId: 'right',
      });

      // Adjust main price scale to use top 60% of chart
      chart.priceScale('right').applyOptions({
        scaleMargins: {
          top: 0,
          bottom: 0.4,  // Candlesticks take up top 60% of chart
        },
      });

      volumeSeries = chart.addHistogramSeries({
        color: 'transparent', // Hide the volume line
        priceFormat: {
          type: 'custom',
          minMove: 1,
          formatter: volumeFormatter,
        },
        priceScaleId: 'volume',
        priceLineVisible: false, // Hide the horizontal price line
        lastValueVisible: false, // Hide the last value label
      });

      // Add a separate price scale for volume
      chart.priceScale('volume').applyOptions({
        scaleMargins: {
          top: 0.6,  // Volume takes up bottom 40% of chart
          bottom: 0,
        },
        priceFormatter: volumeFormatter,
      });

      // Don't add marker here - wait for animation to complete

      // Try to override marker text color after chart is created
      setTimeout(() => {
        const style = document.createElement('style');
        style.textContent = `
          .tv-lightweight-charts .marker-text,
          .tv-lightweight-charts text,
          .tv-lightweight-charts tspan {
            fill: white !important;
            color: white !important;
          }
        `;
        document.head.appendChild(style);
        console.log('Added marker text color override');
      }, 1000);

      // Configure chart to auto-follow the animation
      configureAutoFollow();
      
      // Start the animation after chart is ready
      startAnimation(series, volumeSeries, () => {
        console.log('Initial animation completed');
      });
    }, 100);

    function startAnimation(series, volumeSeries, onComplete) {
      console.log('startAnimation called with onComplete:', !!onComplete);
      
      // Use configuration values
      const config = chartConfig;
      const totalBars = config.totalSeconds; // Number of bars = number of seconds
      const preAnimationSeconds = config.enableHistoricalData ? parseTimeToSeconds(config.preAnimationTime) : 0;
      
      // Generate data
      const bars = [];
      const volumeData = [];
      const animationStartTime = Date.now() - totalBars * 1000; // When animation starts
      const historicalStartTime = animationStartTime - preAnimationSeconds * 1000; // Historical data starts here
      const basePrice = config.initialMarketCap; // Start at configured market cap
      let lastClose = basePrice;

      // Generate pre-animation historical data with completely natural variation (if enabled)
      if (config.enableHistoricalData && preAnimationSeconds > 0) {
        console.log(`Generating ${preAnimationSeconds} seconds of pre-animation history...`);
        
        // Start historical data from a completely random point - no constraints
        let historicalPrice = config.initialMarketCap * (0.1 + Math.random() * 1.8); // 10% to 190% of initial MC
        
        // Add some momentum and trend variables for more realistic behavior
        let momentum = 0;
        let trend = 0;
        let lastTrendChange = 0;
        
        for (let i = 0; i < preAnimationSeconds; i++) {
        const time = historicalStartTime + i * 1000; // 1 second intervals
        const open = historicalPrice;
        
        // Create more natural price movements
        // Base volatility that changes over time
        const baseVolatility = config.rangeMarketCap * (0.5 + Math.random() * 1.5); // 0.5x to 2x range
        
        // Add momentum (price tends to continue in same direction)
        momentum = momentum * 0.9 + (Math.random() - 0.5) * 0.1; // Decay momentum with some randomness
        
        // Add trend changes (market can trend up or down for periods)
        if (i - lastTrendChange > 50 + Math.random() * 200) { // Change trend every 50-250 seconds
          trend = (Math.random() - 0.5) * 2; // -1 to 1 trend
          lastTrendChange = i;
        }
        
        // Calculate price change with multiple factors
        let change = 0;
        
        // Random walk component
        change += (Math.random() - 0.5) * baseVolatility;
        
        // Momentum component
        change += momentum * baseVolatility * 0.3;
        
        // Trend component
        change += trend * baseVolatility * 0.2;
        
        // Occasional big moves (news events, etc.) - but not too frequent
        if (Math.random() < 0.02) { // 2% chance of big move
          const bigMoveDirection = Math.random() < 0.5 ? 1 : -1;
          change += bigMoveDirection * baseVolatility * (2 + Math.random() * 3); // 2-5x normal move
        }
        
        // Add some mean reversion (prices tend to come back toward a "fair value")
        const meanReversion = (config.initialMarketCap - historicalPrice) * 0.01; // 1% pull toward initial
        change += meanReversion;
        
        let close = open + change;
        
        // NO HARD CONSTRAINTS - let the price be completely natural
        // Only prevent completely unrealistic values (negative prices or astronomical values)
        if (close < 1) close = 1; // Minimum $1
        if (close > config.initialMarketCap * 100) close = config.initialMarketCap * 100; // Maximum 100x initial
        
        // Create realistic high/low - only add wicks occasionally (like real charts)
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Only add wicks 20% of the time (more realistic)
        if (Math.random() < 0.2) {
          const wickSize = Math.abs(change) * (0.5 + Math.random() * 1.5); // 0.5-2x the change
          
          if (close > open) {
            // Green candle: only add wick on top
            high = Math.max(open, close) + Math.random() * wickSize;
          } else {
            // Red candle: only add wick on bottom
            low = Math.min(open, close) - Math.random() * wickSize;
          }
        }
        
        bars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        // More realistic volume that correlates with price movement
        const baseVolume = 200 + Math.random() * 1500; // 200-1700 base
        const volumeMultiplier = 1 + Math.abs(change) / config.rangeMarketCap; // Higher volume on bigger moves
        const volume = baseVolume * volumeMultiplier + Math.random() * 1000;
        
        volumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
          historicalPrice = close;
        }
        
        // Ensure the last historical candle always ends at the initial market cap
        if (bars.length > 0) {
          const lastBar = bars[bars.length - 1];
          const lastVolume = volumeData[volumeData.length - 1];
          
          // Adjust the last candle to close at initial market cap
          lastBar.close = config.initialMarketCap;
          lastBar.high = Math.max(lastBar.high, config.initialMarketCap);
          lastBar.low = Math.min(lastBar.low, config.initialMarketCap);
          
          // Update volume color based on new close price
          lastVolume.color = config.initialMarketCap > lastBar.open ? 
            'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)';
          
          // Update historical price to match
          historicalPrice = config.initialMarketCap;
        }
        
        // Set the historical data immediately (no animation for this part)
        series.setData(bars);
        volumeSeries.setData(volumeData);
        console.log(`Pre-animation history loaded: ${bars.length} bars, ending at MC: ${config.initialMarketCap}`);
      } else {
        console.log('Historical data disabled - starting animation immediately');
        // Set empty data to start fresh
        series.setData([]);
        volumeSeries.setData([]);
      }

      // Now generate the animated data starting from the initial market cap
      const startTime = animationStartTime;
      lastClose = config.initialMarketCap;


      // Generate animated data (this will be added to the existing historical data)
      const animatedBars = [];
      const animatedVolumeData = [];
      
      // Start with initial market cap and begin random trading
      for (let i = 0; i < totalBars - 2; i++) { // -2 because we'll add final candle and action candle
        const time = startTime + i * 1000; // 1 second intervals
        const open = lastClose;
        
        // Random trading within the configured range
        let change = (Math.random() - 0.5) * config.rangeMarketCap * 2; // +/- range
        
        // First candle should always be a buy (green)
        if (i === 0) {
          change = Math.abs(change); // Force positive change for first candle
        }
        
        let close = open + change;
        
        // Clamp within range around initial market cap, but never below minMarketCap
        const minPrice = Math.max(config.minMarketCap, config.initialMarketCap - config.rangeMarketCap);
        const maxPrice = config.initialMarketCap + config.rangeMarketCap;
        close = Math.max(minPrice, Math.min(maxPrice, close));
        
        // Create realistic high/low - only add wicks occasionally (like real charts)
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Only add wicks 20% of the time (more realistic)
        if (Math.random() < 0.2) {
          const wickSize = config.rangeMarketCap * (0.05 + Math.random() * 0.15); // 5-20% of range
          
          if (close > open) {
            // Green candle: only add wick on top
            high = Math.max(open, close) + Math.random() * wickSize;
          } else {
            // Red candle: only add wick on bottom
            low = Math.min(open, close) - Math.random() * wickSize;
          }
        }
        
        animatedBars.push({
          time: time / 1000,
          open: open,
          high: high,
          low: low,
          close: close,
        });
        
        const volume = Math.random() * 2000 + 1000;
        animatedVolumeData.push({
          time: time / 1000,
          value: volume,
          color: close > open ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
        });
        
        lastClose = close;
      }

      // Final candle (the big one)
      const finalTime = startTime + (totalBars - 1) * 1000; // 1 second intervals
      const finalOpen = lastClose;
      const finalClose = Math.max(config.minMarketCap, config.finalMarketCap); // Use configured final market cap, never below minMarketCap
      
      // Create realistic high/low - only add wicks occasionally
      let finalHigh = Math.max(finalOpen, finalClose);
      let finalLow = Math.min(finalOpen, finalClose);
      
      // Only add wicks 20% of the time (more realistic)
      if (Math.random() < 0.2) {
        const wickSize = Math.abs(finalClose - finalOpen) * (0.5 + Math.random() * 1.5);
        
        if (finalClose > finalOpen) {
          // Green candle: only add wick on top
          finalHigh = Math.max(finalOpen, finalClose) + Math.random() * wickSize;
        } else {
          // Red candle: only add wick on bottom
          finalLow = Math.min(finalOpen, finalClose) - Math.random() * wickSize;
        }
      }
      
      animatedBars.push({
        time: finalTime / 1000,
        open: finalOpen,
        high: finalHigh,
        low: finalLow,
        close: finalClose,
      });
      
      const finalVolume = Math.random() * 5000 + 5000;
      animatedVolumeData.push({
        time: finalTime / 1000,
        value: finalVolume,
        color: 'rgba(38, 166, 154, 0.3)',
      });

      // Add dump/pump action candle
      const actionTime = startTime + totalBars * 1000;
      const actionOpen = finalClose;
      const actionClose = Math.max(config.minMarketCap, config.finalAction.marketCap); // Never below minMarketCap
      
      // Create realistic high/low - only add wicks occasionally
      let actionHigh = Math.max(actionOpen, actionClose);
      let actionLow = Math.min(actionOpen, actionClose);
      
      // Only add wicks 20% of the time (more realistic)
      if (Math.random() < 0.2) {
        const wickSize = Math.abs(actionClose - actionOpen) * (0.5 + Math.random() * 1.5);
        
        if (actionClose > actionOpen) {
          // Green candle: only add wick on top
          actionHigh = Math.max(actionOpen, actionClose) + Math.random() * wickSize;
        } else {
          // Red candle: only add wick on bottom
          actionLow = Math.min(actionOpen, actionClose) - Math.random() * wickSize;
        }
      }
      
      animatedBars.push({
        time: actionTime / 1000,
        open: actionOpen,
        high: actionHigh,
        low: actionLow,
        close: actionClose,
      });
      
      const actionVolume = Math.random() * 10000 + 10000; // Higher volume for action
      animatedVolumeData.push({
        time: actionTime / 1000,
        value: actionVolume,
        color: actionClose > actionOpen ? 'rgba(38, 166, 154, 0.3)' : 'rgba(239, 83, 80, 0.3)',
      });

      let current = 0;
      const liveBars = [...bars]; // Start with historical data
      const liveVolume = [...volumeData]; // Start with historical volume data

      function showNextBar() {
        if (current < animatedBars.length) {
          try {
            liveBars.push(animatedBars[current]);
            liveVolume.push(animatedVolumeData[current]);
            series.setData(liveBars);
            volumeSeries.setData(liveVolume);
            
            // Add green circle above the first animated candle when it appears
            if (current === 0 && config.markers.showFirstCandle) {
              // Use built-in marker for correct positioning
              const myMarkers = [
                {
                  time: animatedBars[0].time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: config.markers.firstCandleText || 'DB',  // Use config text
                  size: 3,  // Bigger circle for better visibility
                  offsetY: -20  // Move marker higher above the candle
                }
              ];
              series.setMarkers(myMarkers);
              console.log('Added marker above first animated candle:', config.markers.firstCandleText);
            }
            
            // Check for user markers (B and S) as we progress through the animation
            const currentBar = animatedBars[current];
            const userMarkers = config.markers.userMarkers;
            const existingMarkers = series.markers() || [];
            let markersToAdd = [];
            
            // Calculate current time in seconds (each bar is 1 second)
            const currentTime = current;
            
            console.log(`Bar ${current}: Time=${currentTime}s, MC=${currentBar.close}, B target=${userMarkers.bTime}s, S target=${userMarkers.sTime}s`);
            
            // Check for B marker at specific time
            if (userMarkers.showB && userMarkers.bTime !== undefined && !existingMarkers.some(m => m.text === (userMarkers.bText || 'B'))) {
              if (currentTime === userMarkers.bTime) {
                markersToAdd.push({
                  time: currentBar.time,
                  position: 'aboveBar',
                  color: '#26a69a',
                  shape: 'circle',
                  text: userMarkers.bText || 'B',
                  size: 3,
                  offsetY: -20
                });
                console.log(`B marker triggered at time: ${currentTime}s (target: ${userMarkers.bTime}s)`);
              }
            }
            
            // Check for S marker at specific time
            if (userMarkers.showS && userMarkers.sTime !== undefined && !existingMarkers.some(m => m.text === (userMarkers.sText || 'S'))) {
              if (currentTime === userMarkers.sTime) {
                markersToAdd.push({
                  time: currentBar.time,
                  position: 'aboveBar',
                  color: '#ef5350',
                  shape: 'circle',
                  text: userMarkers.sText || 'S',
                  size: 3,
                  offsetY: -20
                });
                console.log(`S marker triggered at time: ${currentTime}s (target: ${userMarkers.sTime}s)`);
              }
            }
            
            // Add new markers if any were triggered
            if (markersToAdd.length > 0) {
              const allMarkers = [...existingMarkers, ...markersToAdd];
              series.setMarkers(allMarkers);
              console.log(`Added ${markersToAdd.length} new markers`);
            }
            
            current++;
            
            // Check if this was the last bar
            if (current === animatedBars.length) {
              // Add marker to final action candle if enabled
              if (config.markers.showFinalCandle) {
                // Get existing markers (including user markers added during animation)
                const existingMarkers = series.markers() || [];
                const allMarkers = [...existingMarkers];
                
                // Add first animated candle marker if enabled and not already present
                if (config.markers.showFirstCandle && !existingMarkers.some(m => m.text === config.markers.firstCandleText)) {
                  allMarkers.push({
                    time: animatedBars[0].time,
                    position: 'aboveBar',
                    color: '#26a69a',
                    shape: 'circle',
                    text: config.markers.firstCandleText || 'DB',
                    size: 3,
                    offsetY: -20  // Move marker higher above the candle
                  });
                }
                
                // Add final action marker if not already present
                const finalMarkerText = config.markers.finalCandleText || (config.finalAction.type === 'pump' ? 'B' : 'S');
                if (!existingMarkers.some(m => m.text === finalMarkerText)) {
                  allMarkers.push({
                    time: animatedBars[animatedBars.length - 1].time,
                    position: 'aboveBar',
                    color: config.finalAction.type === 'pump' ? '#26a69a' : '#ef5350',  // Green for pump, red for dump
                    shape: 'circle',
                    text: finalMarkerText,
                    size: 3,
                    offsetY: -20  // Move marker higher above the candle
                  });
                }
                
                series.setMarkers(allMarkers);
                console.log('Added all markers - preserved user markers and added first/final');
              }
              console.log('Animation complete - showing final values');
              
              // Call completion callback if provided
              if (onComplete) {
                onComplete();
              }
            } else {
              // Apply speed multiplier to candle speed
              const actualCandleSpeed = config.chartStyle.candleSpeed / config.speedMultiplier;
              currentAnimation = setTimeout(showNextBar, actualCandleSpeed);
            }
          } catch (error) {
            console.error('Animation error:', error);
          }
        }
      }
      showNextBar();
    }
  </script>
</body>
</html>