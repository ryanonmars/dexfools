<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TradingView Advanced Chart - Live Trading Simulation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
  <meta http-equiv="Permissions-Policy" content="unload=()">
  
  <!-- TradingView Advanced Chart Library -->
  <script type="text/javascript" src="charting_library-master/charting_library/charting_library.standalone.js"></script>
  <script src="chart-config.js"></script>
  
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px 40px 40px 20px;
      gap: 20px;
      box-sizing: border-box;
    }
    #chart-container {
      flex: 1;
      height: calc(100vh - 100px);
      max-width: calc(100vw - 400px);
      min-width: 400px;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    #config-panel {
      position: relative;
      width: 320px;
      flex-shrink: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      color: #d1d4dc;
      font-family: Arial, sans-serif;
      font-size: 12px;
      max-height: calc(100vh - 100px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    
    .config-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .config-button-container {
      flex-shrink: 0;
      padding: 20px;
      border-top: 1px solid #333;
      background: #1a1a1a;
      border-radius: 0 0 8px 8px;
    }
    
    #config-panel h3 {
      margin: 0 0 15px 0;
      color: #26a69a;
      font-size: 16px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }
    
    .config-group {
      margin-bottom: 20px;
    }
    
    .config-group h4 {
      margin: 0 0 10px 0;
      color: #fff;
      font-size: 14px;
    }
    
    .config-item {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .config-item label {
      flex: 1;
      margin-right: 10px;
    }
    
    .config-item input, .config-item select {
      width: 80px;
      padding: 4px 6px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #d1d4dc;
      font-size: 11px;
    }
    
    .config-item input[type="checkbox"] {
      width: auto;
    }
    
    .config-item input[type="number"] {
      width: 50px;
    }
    
    /* Marker section styles */
    .marker-section {
      margin-bottom: 20px;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
      background: #222;
    }
    
    .marker-section h5 {
      margin: 0 0 12px 0;
      color: #26a69a;
      font-size: 13px;
      font-weight: bold;
    }
    
    .marker-item {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      padding: 8px;
      background: #1a1a1a;
      border-radius: 6px;
      border: 1px solid #333;
    }
    
    .marker-item .config-item {
      margin-bottom: 0;
      flex: 0 0 auto;
    }
    
    .marker-item .config-item label {
      font-size: 11px;
      margin-right: 4px;
    }
    
    .marker-item .config-item input, 
    .marker-item .config-item select {
      width: 60px;
      font-size: 11px;
      padding: 4px 6px;
    }
    
    .remove-marker {
      width: 24px;
      height: 24px;
      background: #ef5350;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .remove-marker:hover {
      background: #d32f2f;
      opacity: 1;
      transform: scale(1.1);
    }
    
    .add-marker-btn {
      background: #26a69a;
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      width: 100%;
    }
    
    .add-marker-btn:hover {
      background: #2dd4aa;
    }
    
    /* Tooltip styles */
    .tooltip {
      position: relative;
      display: inline-block;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #000;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 11px;
      line-height: 1.3;
      border: 1px solid #333;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    #apply-config {
      width: 100%;
      padding: 15px 24px;
      background: #26a69a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(38, 166, 154, 0.3);
    }
    
    #apply-config:hover {
      background: #2bbbad;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(38, 166, 154, 0.4);
    }
    
    #apply-config:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    #animation-status {
      margin-top: 10px;
      padding: 10px;
      background: #333;
      border-radius: 4px;
      text-align: center;
      font-size: 12px;
      color: #d1d4dc;
    }
    
    #tv_chart_container {
      width: 100%;
      height: 100%;
      position: relative;
    }
  </style>
</head>
<body>
  <div id="config-panel">
    <div class="config-content">
      <h3>Chart Configuration</h3>
      
      <div class="config-group">
        <h4>Market Cap Settings</h4>
        <div class="config-item">
          <label>Initial MC:</label>
          <input type="number" id="initialMarketCap" value="10000">
        </div>
        <div class="config-item">
          <label>Final MC:</label>
          <input type="number" id="finalMarketCap" value="50000">
        </div>
        <div class="config-item">
          <label>Min MC:</label>
          <input type="number" id="minMarketCap" value="5000">
        </div>
        <div class="config-item">
          <label>Range MC:</label>
          <input type="number" id="rangeMarketCap" value="2000">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Animation Timing</h4>
        <div class="config-item">
          <label>Duration (s):</label>
          <input type="number" id="totalSeconds" value="10">
        </div>
        <div class="config-item">
          <label>Speed Multiplier:</label>
          <input type="number" id="speedMultiplier" value="1" step="0.1">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Randomness Control</h4>
        <div class="config-item">
          <label>Seed:</label>
          <input type="number" id="seed" value="1">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Historical Data</h4>
        <div class="config-item">
          <label>Enable:</label>
          <input type="checkbox" id="enableHistoricalData">
        </div>
        <div class="config-item">
          <label>Time:</label>
          <input type="text" id="preAnimationTime" value="1h" placeholder="e.g., 2h, 60s">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Final Action</h4>
        <div class="config-item">
          <label>Type:</label>
          <select id="finalActionType">
            <option value="dump">Dump</option>
            <option value="pump">Pump</option>
          </select>
        </div>
        <div class="config-item">
          <label>Target MC:</label>
          <input type="number" id="finalActionMarketCap" value="5000">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Markers</h4>
        
        <!-- Dev Markers -->
        <div class="marker-section">
          <h5>Developer Markers</h5>
          <div id="dev-markers">
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">Dev 1:
                  <span class="tooltiptext">Developer marker 1. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showFirstCandle" checked>
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="firstCandleType">
                  <option value="buy">Buy</option>
                  <option value="sell">Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="firstCandleTime" value="1">
              </div>
              <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">Dev 2:
                  <span class="tooltiptext">Developer marker 2. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showFinalCandle" checked>
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="finalCandleType">
                  <option value="buy">Buy</option>
                  <option value="sell" selected>Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="finalCandleTime" value="10">
              </div>
              <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
          </div>
          <button type="button" class="add-marker-btn" onclick="addDevMarker()">+ Add Dev Marker</button>
        </div>
        
        <!-- User Markers -->
        <div class="marker-section">
          <h5>User Markers</h5>
          <div id="user-markers">
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">User 1:
                  <span class="tooltiptext">User marker 1. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showB">
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="bType">
                  <option value="buy" selected>Buy</option>
                  <option value="sell">Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="bTime" value="5">
              </div>
              <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">User 2:
                  <span class="tooltiptext">User marker 2. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showS">
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="sType">
                  <option value="buy">Buy</option>
                  <option value="sell" selected>Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="sTime" value="8">
              </div>
              <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
          </div>
          <button type="button" class="add-marker-btn" onclick="addUserMarker()">+ Add User Marker</button>
        </div>
      </div>
    </div>
    
    <div class="config-button-container">
      <button id="apply-config">Apply & Start Animation</button>
      <button id="refresh-marks" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Refresh Marks</button>
      <button id="test-realtime" style="margin-top: 10px; background: #9c27b0; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Test Realtime</button>
      <div id="animation-status">Chart ready - click "Apply & Start" to begin</div>
    </div>
  </div>
  
  <div id="chart-container">
    <div id="tv_chart_container"></div>
  </div>

  <script>
    // Global variables
    let tvWidget = null;
    let globalDatafeed = null;
    let isAnimating = false;
    let currentAnimation = null;

    // Seeded random number generator
    class SeededRandom {
      constructor(seed) {
        this.seed = seed;
      }
      
      next() {
        this.seed = (this.seed * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.seed / Math.pow(2, 32);
      }
      
      range(min, max) {
        return min + this.next() * (max - min);
      }
    }

    // Custom Datafeed for TradingView Advanced Chart
    class CustomDatafeed {
      constructor() {
        this.currentData = [];
        this.animationIndex = 0;
        this.onRealtimeCallback = null;
      }

      onReady(callback) {
        console.log('üì° TradingView Advanced Chart onReady called');
        setTimeout(() => callback({
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          supports_marks: true,
          supports_timescale_marks: true,
          supports_time: true,
        }), 0);
      }

      searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {
        console.log('üîç searchSymbols called');
        onResultReadyCallback([]);
      }

      resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
        console.log('üîó resolveSymbol called for:', symbolName);
        
        const symbolInfo = {
          ticker: 'CUSTOM',
          name: 'Custom Token',
          description: 'Custom animated token',
          type: 'crypto',
          session: '24x7',
          timezone: 'UTC',
          exchange: 'Custom',
          minmov: 1,
          pricescale: 100,
          has_intraday: true,
          has_weekly_and_monthly: false,
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          volume_precision: 0,
          data_status: 'streaming',
        };

        setTimeout(() => onSymbolResolvedCallback(symbolInfo), 0);
      }

      getBars(symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) {
        console.log('üìä getBars called with:', { 
          resolution, 
          periodParams, 
          dataLength: this.currentData.length,
          from: new Date(periodParams.from * 1000).toISOString(),
          to: new Date(periodParams.to * 1000).toISOString()
        });
        
        try {
          if (this.currentData.length > 0) {
            // Filter data based on the requested time range
            const fromTime = periodParams.from;
            const toTime = periodParams.to;
            
            console.log('üìä Filtering data from', fromTime, 'to', toTime);
            console.log('üìä Available data times:', this.currentData.map(bar => ({
              time: bar.time,
              timestamp: new Date(bar.time * 1000).toISOString()
            })));
            
            // Filter bars that fall within the requested time range
            const filteredBars = this.currentData.filter(bar => {
              const barTime = bar.time;
              return barTime >= fromTime && barTime <= toTime;
            });
            
            console.log('üìä Filtered to', filteredBars.length, 'bars in range');
            
            // Convert to TradingView format
            const tvData = filteredBars.map(bar => ({
              time: bar.time * 1000, // Convert to milliseconds for 1-minute resolution
              open: bar.open,
              high: bar.high,
              low: bar.low,
              close: bar.close,
              volume: bar.volume || 1000
            }));

            console.log('‚úÖ Sending', tvData.length, 'bars to TradingView');
            if (tvData.length > 0) {
              console.log('üìà Sample data:', tvData[0]);
              console.log('üìà Time range:', {
                first: new Date(tvData[0].time).toISOString(),
                last: new Date(tvData[tvData.length - 1].time).toISOString()
              });
            }

            setTimeout(() => {
              console.log('üìä Calling onHistoryCallback with filtered data');
              onHistoryCallback(tvData, { noData: false });
            }, 0);
          } else {
            console.log('üìä No data available, sending empty response');
            setTimeout(() => onHistoryCallback([], { noData: true }), 0);
          }
        } catch (error) {
          console.error('‚ùå Error in getBars:', error);
          if (onErrorCallback) {
            onErrorCallback(error);
          }
        }
      }

      subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) {
        console.log('üì° subscribeBars called with:', { symbolInfo, resolution, subscribeUID });
        console.log('üì° onRealtimeCallback type:', typeof onRealtimeCallback);
        this.onRealtimeCallback = onRealtimeCallback;
        console.log('üì° Realtime callback stored:', !!this.onRealtimeCallback);
      }

      unsubscribeBars(subscribeUID) {
        console.log('üì° unsubscribeBars called');
      }

      // Method to add a new bar during animation
      addBar(bar) {
        this.currentData.push(bar);
        
        if (this.onRealtimeCallback) {
          const tvBar = {
            time: bar.time * 1000,
            open: bar.open,
            high: bar.high,
            low: bar.low,
            close: bar.close,
            volume: bar.volume || 1000
          };
          
          console.log('üìä Sending real-time bar:', tvBar);
          this.onRealtimeCallback(tvBar);
        }
      }

      // Method to clear data
      clearData() {
        this.currentData = [];
        this.animationIndex = 0;
      }

      // Get marks (chart markers)
      getMarks(symbolInfo, from, to, onDataCallback, resolution) {
        console.log('üéØ getMarks called:', { symbolInfo, from, to, resolution });
        console.log('üéØ Current data length:', this.currentData ? this.currentData.length : 0);
        console.log('üéØ Current data:', this.currentData);
        
        // Return marks from our current data
        const marks = this.getCurrentMarks(from, to);
        console.log('üéØ Returning marks:', marks.length, marks);
        
        // Log each mark in detail
        marks.forEach((mark, index) => {
          console.log(`üéØ Mark ${index}:`, {
            id: mark.id,
            time: mark.time,
            color: mark.color,
            text: mark.text,
            shape: mark.shape,
            minSize: mark.minSize
          });
        });
        
        onDataCallback(marks);
      }

      // Get current marks for the specified time range
      getCurrentMarks(from, to) {
        const marks = [];
        
        if (!this.currentData || this.currentData.length === 0) {
          return marks;
        }

        // Find bars in the time range
        for (let i = 0; i < this.currentData.length; i++) {
          const bar = this.currentData[i];
          const barTime = bar.time;
          
          if (barTime >= from && barTime <= to) {
            // Check if this bar should have a mark
            if (bar.mark) {
              marks.push({
                id: bar.mark.id,
                time: barTime,
                color: bar.mark.color,
                text: bar.mark.text,
                minSize: 14,
                shape: bar.mark.shape || 'circle'
              });
            }
          }
        }

        // Sort marks by time
        marks.sort((a, b) => a.time - b.time);
        return marks;
      }

      // Add a mark to a specific bar
      addMark(barTime, markData) {
        console.log('üéØ addMark called:', { barTime, markData, currentDataLength: this.currentData.length });
        
        // Find the bar and add mark data
        for (let i = 0; i < this.currentData.length; i++) {
          if (this.currentData[i].time === barTime) {
            this.currentData[i].mark = markData;
            console.log('üéØ Mark added to bar at index', i, 'time', barTime);
            
            // Trigger marks refresh by calling getMarks for the current visible range
            this.refreshMarks(barTime);
            break;
          }
        }
      }

      // Refresh marks for the chart
      refreshMarks(centerTime) {
        console.log('üîÑ Refreshing marks around time:', centerTime);
        
        // Calculate a time range around the mark
        const from = centerTime - 3600; // 1 hour before
        const to = centerTime + 3600;   // 1 hour after
        
        // Get marks for this range
        const marks = this.getCurrentMarks(from, to);
        console.log('üîÑ Found marks to refresh:', marks.length, marks);
        
        // Try to force a marks refresh by changing the visible range
        if (window.chartWidget && window.chartWidget.chart) {
          try {
            console.log('üîÑ Attempting to force marks refresh via chart API...');
            
            const chart = window.chartWidget.chart();
            if (chart && chart.getVisibleRange && chart.setVisibleRange) {
              console.log('üîÑ Found chart methods, triggering marks refresh...');
              
              // Get current visible range
              const currentRange = chart.getVisibleRange();
              if (currentRange && currentRange.from > 0 && currentRange.to > 0) {
                console.log('üîÑ Current visible range:', currentRange);
                
                // Slightly adjust the range to trigger marks refresh
                const newRange = {
                  from: currentRange.from - 1, // 1ms before
                  to: currentRange.to + 1      // 1ms after
                };
                console.log('üîÑ Setting new visible range to trigger marks:', newRange);
                chart.setVisibleRange(newRange);
                
                // Set it back after a short delay
                setTimeout(() => {
                  console.log('üîÑ Restoring original visible range...');
                  chart.setVisibleRange(currentRange);
                }, 50);
              } else {
                console.log('üîÑ Chart visible range not ready yet, will retry later');
                // Retry after a delay
                setTimeout(() => {
                  this.refreshMarks(centerTime);
                }, 500);
              }
            }
          } catch (error) {
            console.error('‚ùå Error trying to force marks refresh:', error);
          }
        }
      }

      // Get timescale marks
      getTimescaleMarks(symbolInfo, from, to, onDataCallback, resolution) {
        console.log('üìÖ getTimescaleMarks called:', { symbolInfo, from, to, resolution });
        onDataCallback([]);
      }
    }

    // Parse time string to seconds (from working version)
    function parseTimeToSeconds(timeString) {
      const timeStr = timeString.toLowerCase().trim();
      const match = timeStr.match(/^(\d+)([smhd])$/);
      
      if (!match) {
        console.warn(`Invalid time format: ${timeString}. Using default 1 hour.`);
        return 3600; // Default to 1 hour
      }
      
      const value = parseInt(match[1]);
      const unit = match[2];
      
      switch (unit) {
        case 's': return value; // seconds
        case 'm': return value * 60; // minutes
        case 'h': return value * 3600; // hours
        case 'd': return value * 86400; // days
        default: return 3600; // Default to 1 hour
      }
    }


    // Add marks to data before animation starts
    function addMarksToData(animatedBars, config) {
      console.log('üéØ Pre-adding marks to animation data...');
      
      // Dev 1 marker - TradingView displays first bar as second candle, so adjust timing
      if (config.markers.showFirstCandle && config.markers.firstCandleTime <= animatedBars.length) {
        // If user wants marker on "first candle" (time 1), put it on bar 0 (which TradingView shows as second candle)
        // If user wants marker on "second candle" (time 2), put it on bar 1 (which TradingView shows as third candle)
        const barIndex = config.markers.firstCandleTime - 1; // Convert to 0-based index
        console.log('üéØ Dev 1 marker config:', {
          firstCandleTime: config.markers.firstCandleTime,
          barIndex: barIndex,
          totalBars: animatedBars.length,
          note: 'TradingView displays bar 0 as second candle, bar 1 as third candle, etc.'
        });
        console.log('üéØ Bar details:', {
          bar0: animatedBars[0] ? { time: animatedBars[0].time, index: 0, displayAs: '2nd candle' } : 'undefined',
          bar1: animatedBars[1] ? { time: animatedBars[1].time, index: 1, displayAs: '3rd candle' } : 'undefined',
          targetBar: animatedBars[barIndex] ? { time: animatedBars[barIndex].time, index: barIndex, displayAs: `${barIndex + 2}th candle` } : 'undefined'
        });
        
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'dev1',
            color: config.markers.firstCandleType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'D1',
            shape: 'circle'
          };
          console.log('üéØ Pre-added Dev 1 mark to bar at index', barIndex, 'time', bar.time, `(TradingView will display as ${barIndex + 2}th candle)`);
          console.log('üéØ Full bar with mark:', bar);
        } else {
          console.log('‚ùå Dev 1 marker index out of range:', barIndex, 'not in range 0-', animatedBars.length - 1);
        }
      }
      
      // Dev 2 marker
      if (config.markers.showFinalCandle && config.markers.finalCandleTime <= animatedBars.length) {
        const barIndex = config.markers.finalCandleTime - 1; // Convert to 0-based index
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'dev2',
            color: config.markers.finalCandleType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'D2',
            shape: 'circle'
          };
          console.log('üéØ Pre-added Dev 2 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      // User markers
      if (config.markers.userMarkers.showB && config.markers.userMarkers.bTime <= animatedBars.length) {
        const barIndex = config.markers.userMarkers.bTime - 1;
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'user1',
            color: config.markers.userMarkers.bType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'U1',
            shape: 'circle'
          };
          console.log('üéØ Pre-added User 1 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      if (config.markers.userMarkers.showS && config.markers.userMarkers.sTime <= animatedBars.length) {
        const barIndex = config.markers.userMarkers.sTime - 1;
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'user2',
            color: config.markers.userMarkers.sType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'U2',
            shape: 'circle'
          };
          console.log('üéØ Pre-added User 2 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      console.log('üéØ Pre-added marks complete. Bars with marks:', animatedBars.filter(bar => bar.mark).length);
    }
    
    // Pre-load marks into the datafeed before animation starts
    function preloadMarksToDatafeed(animatedBars, config) {
      console.log('üéØ Pre-loading marks into datafeed...');
      
      if (!globalDatafeed || typeof globalDatafeed.addMark !== 'function') {
        console.log('‚ùå Datafeed not ready for pre-loading marks');
        return;
      }
      
      // Add all marks to the datafeed immediately
      animatedBars.forEach((bar, index) => {
        if (bar.mark) {
          console.log(`üéØ Pre-loading mark for bar ${index + 1} at time ${bar.time}:`, bar.mark);
          globalDatafeed.addMark(bar.time, bar.mark);
        }
      });
      
      console.log('üéØ Pre-loaded marks into datafeed complete');
    }
    
    // Pre-load all marks into the datafeed before animation starts
    function preloadAllMarks(animatedBars, config) {
      console.log('üéØ Pre-loading ALL marks into datafeed before animation...');
      
      if (!globalDatafeed || typeof globalDatafeed.addMark !== 'function') {
        console.log('‚ùå Datafeed not ready for pre-loading marks');
        return;
      }
      
      // Add all marks to the datafeed immediately
      animatedBars.forEach((bar, index) => {
        if (bar.mark) {
          console.log(`üéØ Pre-loading mark for bar ${index + 1} at time ${bar.time}:`, bar.mark);
          globalDatafeed.addMark(bar.time, bar.mark);
        }
      });
      
      console.log('üéØ Pre-loaded ALL marks into datafeed complete');
    }
    
    // Pre-load ALL data and marks into the datafeed before animation starts (like real trading platforms)
    function preloadAllDataAndMarks(animatedBars, config) {
      console.log('üéØ Pre-loading ALL data and marks into datafeed (real trading platform approach)...');
      
      if (!globalDatafeed) {
        console.log('‚ùå Datafeed not ready for pre-loading');
        return;
      }
      
      // Add all bars to the datafeed
      animatedBars.forEach((bar, index) => {
        globalDatafeed.addBar(bar);
        console.log(`üìä Pre-loaded bar ${index + 1}/${animatedBars.length} at time ${bar.time}`);
        
        // Add mark if this bar has one
        if (bar.mark) {
          globalDatafeed.addMark(bar.time, bar.mark);
          console.log(`üéØ Pre-loaded mark for bar ${index + 1}: ${bar.mark.text}`);
        }
      });
      
      console.log('üéØ Pre-loaded ALL data and marks into datafeed complete');
    }
    

    // Marker management functions
    function addDevMarker() {
      const devMarkers = document.getElementById('dev-markers');
      const markerCount = devMarkers.children.length;
      const newMarker = document.createElement('div');
      newMarker.className = 'marker-item';
      newMarker.innerHTML = `
        <div class="config-item">
          <label class="tooltip">Dev ${markerCount + 1}:
            <span class="tooltiptext">Developer marker ${markerCount + 1}. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
          </label>
          <input type="checkbox" id="showDev${markerCount + 1}" checked>
        </div>
        <div class="config-item">
          <label class="tooltip">Type:
            <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
          </label>
          <select id="dev${markerCount + 1}Type">
            <option value="buy">Buy</option>
            <option value="sell">Sell</option>
          </select>
        </div>
        <div class="config-item">
          <label class="tooltip">Time:
            <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
          </label>
          <input type="number" id="dev${markerCount + 1}Time" value="${markerCount + 1}">
        </div>
        <button type="button" class="remove-marker" onclick="removeDevMarker(this)">üóëÔ∏è</button>
      `;
      devMarkers.appendChild(newMarker);
      updateRemoveButtons();
    }
    
    function removeDevMarker(button) {
      button.parentElement.remove();
      updateRemoveButtons();
    }
    
    function addUserMarker() {
      const userMarkers = document.getElementById('user-markers');
      const markerCount = userMarkers.children.length;
      const newMarker = document.createElement('div');
      newMarker.className = 'marker-item';
      newMarker.innerHTML = `
        <div class="config-item">
          <label class="tooltip">User ${markerCount + 1}:
            <span class="tooltiptext">User marker ${markerCount + 1}. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
          </label>
          <input type="checkbox" id="showUser${markerCount + 1}">
        </div>
        <div class="config-item">
          <label class="tooltip">Type:
            <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
          </label>
          <select id="user${markerCount + 1}Type">
            <option value="buy" selected>Buy</option>
            <option value="sell">Sell</option>
          </select>
        </div>
        <div class="config-item">
          <label class="tooltip">Time:
            <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
          </label>
          <input type="number" id="user${markerCount + 1}Time" value="${markerCount + 1}">
        </div>
        <button type="button" class="remove-marker" onclick="removeUserMarker(this)">üóëÔ∏è</button>
      `;
      userMarkers.appendChild(newMarker);
      updateRemoveButtons();
    }
    
    function removeUserMarker(button) {
      button.parentElement.remove();
      updateRemoveButtons();
    }
    
    function updateRemoveButtons() {
      // Show remove buttons only if there are more than 1 markers
      const devMarkers = document.querySelectorAll('#dev-markers .marker-item');
      const userMarkers = document.querySelectorAll('#user-markers .marker-item');
      
      devMarkers.forEach((marker, index) => {
        const removeBtn = marker.querySelector('.remove-marker');
        if (removeBtn) {
          const shouldShow = devMarkers.length > 1;
          removeBtn.style.display = shouldShow ? 'flex' : 'none';
        }
      });
      
      userMarkers.forEach((marker, index) => {
        const removeBtn = marker.querySelector('.remove-marker');
        if (removeBtn) {
          const shouldShow = userMarkers.length > 1;
          removeBtn.style.display = shouldShow ? 'flex' : 'none';
        }
      });
    }

    // Initialize TradingView Advanced Chart
    function initTradingView() {
      if (tvWidget) {
        tvWidget.remove();
        tvWidget = null;
      }

      // Always create a new datafeed instance for each chart
      globalDatafeed = new CustomDatafeed();
      
      // Add initial data so chart has something to display
      const initialTime = Math.floor(Date.now() / 1000);
      const initialBar = {
        time: initialTime,
        open: 10000,
        high: 10100,
        low: 9900,
        close: 10000,
      };
      globalDatafeed.currentData.push(initialBar);
      console.log('üöÄ Added initial bar to datafeed:', initialBar);
      console.log('üöÄ Datafeed currentData length:', globalDatafeed.currentData.length);
      
      console.log('üöÄ Datafeed created:', globalDatafeed);
      console.log('üöÄ addMark method available:', typeof globalDatafeed.addMark);

      console.log('üöÄ Initializing TradingView Advanced Chart...');
      
      // Debug: Check if container exists
      const container = document.getElementById('tv_chart_container');
      console.log('üöÄ Chart container found:', !!container);
      console.log('üöÄ Container dimensions:', container ? {
        width: container.offsetWidth,
        height: container.offsetHeight,
        visible: container.offsetParent !== null
      } : 'Container not found');

      tvWidget = new TradingView.widget({
        symbol: 'CUSTOM',
        interval: '1',
        container: 'tv_chart_container',
        datafeed: globalDatafeed,
        library_path: 'charting_library-master/charting_library/',
        locale: 'en',
        disabled_features: [
          'save_chart_properties_to_local_storage',
          'use_localstorage_for_settings',
          'right_bar_stays_on_scroll',
          'study_templates',
          'timeframes_toolbar',
          'scales_context_menu',
          'pane_context_menu',
          'create_volume_indicator_by_default',
          'header_symbol_search',
          'header_compare',
          'header_screenshot',
          'header_widget',
          'header_saveload',
          'header_settings',
          'header_chart_type',
          'header_resolutions',
          'header_snapshot_trading_drawing_tools',
          'header_indicators',
          'header_fullscreen_button',
          'header_undo_redo',
          'header_interval_dialog_button',
          'show_interval_dialog_on_key_press',
          'header_chart_type_dialog_button',
          'show_chart_type_dialog_on_key_press',
          'header_symbol_search_dialog_button',
          'show_symbol_search_dialog_on_key_press',
          'header_resolutions_dialog_button',
          'show_resolutions_dialog_on_key_press',
          'header_screenshot_dialog_button',
          'show_screenshot_dialog_on_key_press',
          'header_widget_dialog_button',
          'show_widget_dialog_on_key_press',
          'header_saveload_dialog_button',
          'show_saveload_dialog_on_key_press',
          'header_settings_dialog_button',
          'show_settings_dialog_on_key_press',
          'header_indicators_dialog_button',
          'show_indicators_dialog_on_key_press',
          'header_fullscreen_button_dialog_button',
          'show_fullscreen_button_dialog_on_key_press',
          'header_undo_redo_dialog_button',
          'show_undo_redo_dialog_on_key_press',
          'header_interval_dialog_button_dialog_button',
          'show_interval_dialog_button_dialog_on_key_press',
          'header_chart_type_dialog_button_dialog_button',
          'show_chart_type_dialog_button_dialog_on_key_press',
          'header_symbol_search_dialog_button_dialog_button',
          'show_symbol_search_dialog_button_dialog_on_key_press',
          'header_resolutions_dialog_button_dialog_button',
          'show_resolutions_dialog_button_dialog_on_key_press',
          'header_screenshot_dialog_button_dialog_button',
          'show_screenshot_dialog_button_dialog_on_key_press',
          'header_widget_dialog_button_dialog_button',
          'show_widget_dialog_button_dialog_on_key_press',
          'header_saveload_dialog_button_dialog_button',
          'show_saveload_dialog_button_dialog_on_key_press',
          'header_settings_dialog_button_dialog_button',
          'show_settings_dialog_button_dialog_on_key_press',
          'header_indicators_dialog_button_dialog_button',
          'show_indicators_dialog_button_dialog_on_key_press',
          'header_fullscreen_button_dialog_button_dialog_button',
          'show_fullscreen_button_dialog_button_dialog_on_key_press',
          'header_undo_redo_dialog_button_dialog_button',
          'show_undo_redo_dialog_button_dialog_on_key_press'
        ],
        enabled_features: [
          'move_logo_to_main_pane'
        ],
        fullscreen: false,
        autosize: true,
        theme: 'dark',
        // Add these to prevent page reload issues
        overrides: {
          'paneProperties.background': '#000000',
          'paneProperties.vertGridProperties.color': '#333333',
          'paneProperties.horzGridProperties.color': '#333333'
        },
        // Disable features that might cause page reload
        studies_overrides: {},
        // Prevent any unload events that might cause page reload
        custom_css_url: null
      });

      tvWidget.onChartReady(() => {
        console.log('‚úÖ TradingView Advanced Chart ready');
        document.getElementById('animation-status').textContent = 'Chart ready - Position as needed, then click "Apply & Start"';
        document.getElementById('animation-status').style.color = '#26a69a';
        
        // Store chart reference for marker support
        window.chartWidget = tvWidget;
        
        // Debug: Check if realtime callback is available
        console.log('üîç Chart ready - checking realtime callback status:');
        console.log('üîç globalDatafeed.onRealtimeCallback:', !!globalDatafeed.onRealtimeCallback);
        console.log('üîç globalDatafeed properties:', Object.keys(globalDatafeed));
        
        // Let chart load naturally without forcing initial zoom
        // User can position chart as needed for marketing material
        console.log('üìä Chart ready - position as needed for marketing material');
        
        // Debug: Check if chart is actually visible
        const chartContainer = document.getElementById('tv_chart_container');
        console.log('üìä Chart container after ready:', {
          exists: !!chartContainer,
          width: chartContainer?.offsetWidth,
          height: chartContainer?.offsetHeight,
          visible: chartContainer?.offsetParent !== null,
          children: chartContainer?.children?.length || 0
        });
        
        // Try to access the chart's internal API for marks
        console.log('üîç Chart widget methods:', Object.getOwnPropertyNames(tvWidget));
        console.log('üîç Chart widget prototype:', Object.getOwnPropertyNames(Object.getPrototypeOf(tvWidget)));
        
        // Try to find marks-related methods
        if (tvWidget.chart) {
          console.log('üîç Chart object methods:', Object.getOwnPropertyNames(tvWidget.chart));
        }
      });
    }

    // Start animation function
    function startAnimation() {
      console.log('üé¨ startAnimation function called!');
      // Stop any existing animation first
      if (isAnimating) {
        console.log('üõë Stopping existing animation...');
        isAnimating = false;
        if (currentAnimation) {
          clearTimeout(currentAnimation);
          currentAnimation = null;
        }
      }
      
      isAnimating = true;
      console.log('üîç About to call getConfig()...');
      const config = getConfig();
      console.log('üîç getConfig() returned:', config);
      
      console.log('üé¨ Starting TradingView Advanced Chart animation with config:', config);
      
      console.log('üéØ SEED DEBUGGING:');
      console.log('üéØ Seed from UI:', document.getElementById('seed').value);
      console.log('üéØ Seed parsed:', parseInt(document.getElementById('seed').value));
      console.log('üéØ Seed in config:', config.seed);
      document.getElementById('animation-status').textContent = 'Resetting chart and generating animation data...';
      document.getElementById('animation-status').style.color = '#26a69a';
      
      // COMPLETE CHART RESET - Recreate the entire chart widget
      console.log('üîÑ Performing complete chart reset...');
      
      // Remove the old chart completely
      if (tvWidget) {
        console.log('üîÑ Removing old chart widget...');
        tvWidget.remove();
        tvWidget = null;
      }
      
      // Create a completely fresh datafeed
      globalDatafeed = new CustomDatafeed();
      
      // Recreate the chart widget
      console.log('üîÑ Creating fresh chart widget...');
      initTradingView();
      
      // Wait for chart to be ready, then start animation
      setTimeout(() => {
        // Start animation with fresh chart
        console.log('üöÄ Fresh chart ready, starting animation');
        startAnimationData(config);
      }, 1000);
    }
    
    // Separate function to start the actual animation data generation
    function startAnimationData(config) {
      // Debug the config being passed
      console.log('üîç Config passed to startAnimationData:', config);
      console.log('üîç Speed multiplier in config:', config.speedMultiplier);
      
      // Generate data EXACTLY like the working index.html version
      const totalBars = config.totalSeconds;
      const rng = new SeededRandom(config.seed);
      
      // Use current time as base for animation
      const animationStartTime = Date.now();
      
      console.log(`Generating ${totalBars} bars for animation...`);
      
      // Generate ALL data upfront like working version
      const animatedBars = [];
      let lastClose = config.initialMarketCap;
      
      // Calculate the target progression toward final market cap
      const totalChange = config.finalMarketCap - config.initialMarketCap;
      const progressPerBar = totalChange / (totalBars - 1);
      
      console.log(`üéØ Data generation config (WORKING LOGIC):`, {
        initialMC: config.initialMarketCap,
        finalMC: config.finalMarketCap,
        totalChange,
        progressPerBar,
        totalBars
      });
      
      // Generate animated data exactly like working version
      for (let i = 0; i < totalBars - 2; i++) {
        const time = animationStartTime + (i * 1000); // 1 second intervals in milliseconds
        const open = lastClose;
        
        // Calculate where we should be at this point in the animation
        const targetPrice = config.initialMarketCap + (progressPerBar * (i + 1));
        
        // Random trading with balanced trend and variation (EXACT copy from working version)
        const progressRatio = (i + 1) / (totalBars - 1);
        const trendStrength = 0.03 + (progressRatio * 0.12);
        const randomStrength = 0.7;
        
        const trendComponent = (targetPrice - open) * trendStrength;
        const randomComponent = (rng.next() - 0.5) * config.rangeMarketCap * randomStrength;
        
        const randomDirectionChance = 0.3;
        const trendDirection = rng.next() < randomDirectionChance ? (rng.next() - 0.5) * 2 : 1;
        
        const volatility = 0.8 + rng.next() * 0.4;
        const momentum = rng.next() < 0.25 ? (rng.next() - 0.5) * 0.3 : 0;
        
        let change = (trendComponent * trendDirection) + (randomComponent + momentum) * volatility;
        
        // First candle should always be a buy (green)
        if (i === 0) {
          change = Math.abs(change);
        }
        
        let close = open + change;
        
        if (close < config.minMarketCap) {
          close = config.minMarketCap;
        }
        
        // Balanced correction toward target
        const totalDistance = Math.abs(config.finalMarketCap - config.initialMarketCap);
        const currentProgress = Math.abs(close - config.initialMarketCap) / totalDistance;
        const expectedProgress = (i + 1) / (totalBars - 1);
        const progressDeviation = Math.abs(currentProgress - expectedProgress);
        
        if (progressDeviation > 0.4) {
          const correctionStrength = 0.01 + (progressRatio * 0.03);
          const correction = (targetPrice - close) * correctionStrength;
          close = close + correction;
        }
        
        // Create realistic high/low
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Only add wicks 20% of the time
        if (rng.next() < 0.2) {
          const wickSize = Math.abs(change) * (0.3 + rng.next() * 0.7);
          if (close > open) {
            high = Math.max(open, close) + rng.next() * wickSize;
          } else {
            low = Math.min(open, close) - rng.next() * wickSize;
          }
        }
        
        const bar = {
          time: time, // Keep as milliseconds for 1-minute resolution
          open: open,
          high: high,
          low: low,
          close: close
        };

        animatedBars.push(bar);
        lastClose = close;
      }

      // Add final candle that hits the final market cap
      const finalTime = animationStartTime + ((totalBars - 2) * 1000);
      const finalOpen = lastClose;
      const finalClose = config.finalMarketCap;
      const finalHigh = Math.max(finalOpen, finalClose);
      const finalLow = Math.min(finalOpen, finalClose);

      animatedBars.push({
        time: finalTime,
        open: finalOpen,
        high: finalHigh,
        low: finalLow,
        close: finalClose
      });

      // Add final action candle
      const actionTime = animationStartTime + ((totalBars - 1) * 1000);
      const actionOpen = config.finalMarketCap;
      const actionClose = config.minMarketCap;
      const actionHigh = Math.max(actionOpen, actionClose);
      const actionLow = Math.min(actionOpen, actionClose);

      animatedBars.push({
        time: actionTime,
        open: actionOpen,
        high: actionHigh,
        low: actionLow,
        close: actionClose
      });

      console.log(`Generated ${animatedBars.length} bars for animation`);
      console.log(`Bar times:`, animatedBars.map((bar, i) => `Bar ${i}: time ${bar.time}`));
      
      // Update status
      document.getElementById('animation-status').textContent = 'Starting animation...';
      document.getElementById('animation-status').style.color = '#26a69a';
      
      // Now start the animation exactly like working version
      startAnimationLoop(animatedBars, config);
    }
    
    function startAnimationLoop(animatedBars, config) {
      let current = 0;
      const liveBars = [];
      
      // Clear any existing data before starting
      globalDatafeed.currentData = [];
      
      // Calculate animation speed based on speed multiplier
      const baseSpeed = 1000; // 1 second base speed
      
      console.log(`üîç DEBUGGING SPEED MULTIPLIER:`);
      console.log(`üîç Raw value from input: "${document.getElementById('speedMultiplier').value}"`);
      console.log(`üîç Parsed value: ${config.speedMultiplier}`);
      console.log(`üîç Type: ${typeof config.speedMultiplier}`);
      console.log(`üîç Is NaN: ${isNaN(config.speedMultiplier)}`);
      console.log(`üîç Is finite: ${isFinite(config.speedMultiplier)}`);
      
      // Force a valid speed multiplier
      if (isNaN(config.speedMultiplier) || config.speedMultiplier <= 0 || !isFinite(config.speedMultiplier)) {
        console.error(`‚ùå Invalid speed multiplier: ${config.speedMultiplier}, forcing to 1.0`);
        config.speedMultiplier = 1.0;
      }
      
      const animationSpeed = baseSpeed / config.speedMultiplier;
      console.log(`üöÄ Final speed multiplier: ${config.speedMultiplier}`);
      console.log(`üöÄ Base speed: ${baseSpeed}ms`);
      console.log(`üöÄ Calculated animation speed: ${animationSpeed}ms per bar`);
      console.log(`üöÄ This means each bar will show for ${animationSpeed}ms`);
      
      // Additional validation and force minimum speed
      let finalAnimationSpeed = animationSpeed;
      if (animationSpeed < 50) {
        console.error(`‚ùå Animation speed too fast: ${animationSpeed}ms - this will cause instant animation!`);
        console.error(`‚ùå Forcing minimum speed of 100ms`);
        finalAnimationSpeed = 100;
        console.log(`üöÄ Forced speed: ${finalAnimationSpeed}ms per bar`);
      }
      
      // Show speed info on the page for debugging
      document.getElementById('animation-status').textContent = `Speed: ${finalAnimationSpeed}ms per bar (${config.speedMultiplier}x multiplier)`;
      document.getElementById('animation-status').style.color = '#ff9800';
      
      console.log(`üöÄ Using finalAnimationSpeed: ${finalAnimationSpeed}ms for setTimeout`);
      
      function showNextBar() {
        if (current < animatedBars.length) {
          try {
            liveBars.push(animatedBars[current]);
            
            // Update TradingView chart with all data so far
            globalDatafeed.currentData = [...liveBars];
            
            // Force TradingView to refresh and show the data
            const currentBar = liveBars[liveBars.length - 1];
            const tvBar = {
              time: currentBar.time * 1000, // Convert to milliseconds for 1-minute resolution
              open: currentBar.open,
              high: currentBar.high,
              low: currentBar.low,
              close: currentBar.close,
              volume: currentBar.volume || 1000
            };
            
            console.log(`üìä Calling realtime callback with bar:`, tvBar);
            console.log(`üìä Realtime callback available:`, !!globalDatafeed.onRealtimeCallback);
            console.log(`üìä Realtime callback type:`, typeof globalDatafeed.onRealtimeCallback);
            
            if (globalDatafeed.onRealtimeCallback) {
              try {
                globalDatafeed.onRealtimeCallback(tvBar);
                console.log(`üìä Realtime callback called successfully`);
              } catch (error) {
                console.error(`‚ùå Error calling realtime callback:`, error);
              }
            } else {
              console.error(`‚ùå No realtime callback available!`);
              console.log(`üìä Available datafeed properties:`, Object.keys(globalDatafeed));
              
              // Fallback: Try to force chart refresh by triggering a data update
              console.log(`üîÑ Attempting fallback: forcing chart data refresh...`);
              // The chart should automatically call getBars when data changes
              // We've already updated globalDatafeed.currentData above
            }
            
            // Check for markers exactly like working version
            const currentTime = current + 1; // 1-based time like working version
            
            console.log(`üìä Bar ${current + 1}/${animatedBars.length}: Time=${currentTime}s, MC=${animatedBars[current].close}`);
            console.log(`üìä Datafeed has ${globalDatafeed.currentData.length} bars total`);
            console.log(`üìä Realtime callback available:`, !!globalDatafeed.onRealtimeCallback);
            
            // Add markers if triggered (simplified for now)
            if (config.markers.showFirstCandle && currentTime === config.markers.firstCandleTime) {
              console.log(`üéØ Dev 1 marker triggered at time: ${currentTime}s`);
            }
            
            if (config.markers.showFinalCandle && currentTime === config.markers.finalCandleTime) {
              console.log(`üéØ Dev 2 marker triggered at time: ${currentTime}s`);
            }
            
            current++;
            
            if (current < animatedBars.length) {
              // Recalculate speed each time to ensure we have the right value
              const currentSpeed = baseSpeed / config.speedMultiplier;
              const actualSpeed = currentSpeed < 50 ? 100 : currentSpeed;
              console.log(`‚è±Ô∏è Setting timeout for next bar in ${actualSpeed}ms (speed multiplier: ${config.speedMultiplier})`);
              setTimeout(showNextBar, actualSpeed);
            } else {
              console.log('‚úÖ Animation complete');
              document.getElementById('animation-status').textContent = 'Animation complete!';
              document.getElementById('animation-status').style.color = '#26a69a';
            }
          } catch (error) {
            console.error('Animation error:', error);
          }
        }
      }
      
      // Start the animation
      console.log('üöÄ Starting animation loop...');
      showNextBar();
    }

    // Remove the broken addMarksToData function - markers are handled in the animation loop

    function getConfig() {
      try {
        const speedMultiplierValue = document.getElementById('speedMultiplier').value;
        const parsedSpeedMultiplier = parseFloat(speedMultiplierValue);
        
        console.log('üîç getConfig() debugging:');
        console.log('üîç Raw speedMultiplier value:', speedMultiplierValue);
        console.log('üîç Parsed speedMultiplier:', parsedSpeedMultiplier);
        console.log('üîç Is NaN:', isNaN(parsedSpeedMultiplier));
        
        return {
          initialMarketCap: parseInt(document.getElementById('initialMarketCap').value),
          finalMarketCap: parseInt(document.getElementById('finalMarketCap').value),
          minMarketCap: parseInt(document.getElementById('minMarketCap').value),
          rangeMarketCap: parseInt(document.getElementById('rangeMarketCap').value),
          totalSeconds: parseInt(document.getElementById('totalSeconds').value),
          speedMultiplier: parsedSpeedMultiplier || 1.0,
          seed: parseInt(document.getElementById('seed').value) || 1,
          markers: {
            showFirstCandle: document.getElementById('showFirstCandle').checked,
            firstCandleType: document.getElementById('firstCandleType').value,
            firstCandleTime: parseInt(document.getElementById('firstCandleTime').value),
            showFinalCandle: document.getElementById('showFinalCandle').checked,
            finalCandleType: document.getElementById('finalCandleType').value,
            finalCandleTime: parseInt(document.getElementById('finalCandleTime').value),
            userMarkers: {
              showB: document.getElementById('showB').checked,
              bTime: parseInt(document.getElementById('bTime').value),
              bType: document.getElementById('bType').value,
              showS: document.getElementById('showS').checked,
              sTime: parseInt(document.getElementById('sTime').value),
              sType: document.getElementById('sType').value
            }
          }
        };
      } catch (error) {
        console.error('‚ùå Error in getConfig():', error);
        console.error('‚ùå Error stack:', error.stack);
        // Return a default config if there's an error
        return {
          initialMarketCap: 10000,
          finalMarketCap: 50000,
          minMarketCap: 5000,
          rangeMarketCap: 2000,
          totalSeconds: 10,
          speedMultiplier: 1.0,
          seed: 1,
          markers: {
            showFirstCandle: true,
            firstCandleType: 'buy',
            firstCandleTime: 1,
            showFinalCandle: true,
            finalCandleType: 'sell',
            finalCandleTime: 10,
            userMarkers: {
              showB: false,
              bTime: 5,
              bType: 'buy',
              showS: false,
              sTime: 8,
              sType: 'sell'
            }
          }
        };
      }
    }
    
    // Test function to manually test realtime callback
    function testRealtimeCallback() {
      console.log('üß™ Testing realtime callback...');
      console.log('üß™ globalDatafeed:', globalDatafeed);
      console.log('üß™ onRealtimeCallback:', globalDatafeed?.onRealtimeCallback);
      
      if (globalDatafeed && globalDatafeed.onRealtimeCallback) {
        const testBar = {
          time: Date.now(),
          open: 10000,
          high: 10100,
          low: 9900,
          close: 10050,
          volume: 1000
        };
        
        console.log('üß™ Sending test bar:', testBar);
        try {
          globalDatafeed.onRealtimeCallback(testBar);
          console.log('üß™ Test bar sent successfully!');
        } catch (error) {
          console.error('üß™ Error sending test bar:', error);
        }
      } else {
        console.error('üß™ No realtime callback available for testing');
      }
    }
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      console.log('üé¨ DOM loaded, setting up event listeners...');
      const button = document.getElementById('apply-config');
      console.log('üé¨ Button found:', !!button);
      if (button) {
        button.addEventListener('click', () => {
          console.log('üé¨ Apply & Start button clicked!');
          startAnimation();
        });
        console.log('üé¨ Event listener added to button');
      } else {
        console.error('‚ùå Apply & Start button not found!');
      }
      
      // Add test realtime button
      const testButton = document.getElementById('test-realtime');
      if (testButton) {
        testButton.addEventListener('click', () => {
          console.log('üß™ Test Realtime button clicked!');
          testRealtimeCallback();
        });
        console.log('üß™ Test realtime button event listener added');
      }
      
      setTimeout(initTradingView, 100);
      updateRemoveButtons(); // Hide trash cans initially
    });
  </script>
</body>
</html>
