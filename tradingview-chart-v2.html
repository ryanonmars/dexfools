<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TradingView Advanced Chart - Live Trading Simulation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
  
  <!-- TradingView Advanced Chart Library -->
  <script type="text/javascript" src="charting_library-master/charting_library/charting_library.standalone.js"></script>
  <script src="chart-config.js"></script>
  
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px 40px 40px 20px;
      gap: 20px;
      box-sizing: border-box;
    }
    #chart-container {
      flex: 1;
      height: calc(100vh - 100px);
      max-width: calc(100vw - 400px);
      min-width: 400px;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    #config-panel {
      position: relative;
      width: 320px;
      flex-shrink: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      color: #d1d4dc;
      font-family: Arial, sans-serif;
      font-size: 12px;
      max-height: calc(100vh - 100px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    
    .config-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .config-button-container {
      flex-shrink: 0;
      padding: 20px;
      border-top: 1px solid #333;
      background: #1a1a1a;
      border-radius: 0 0 8px 8px;
    }
    
    #config-panel h3 {
      margin: 0 0 15px 0;
      color: #26a69a;
      font-size: 16px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }
    
    .config-group {
      margin-bottom: 20px;
    }
    
    .config-group h4 {
      margin: 0 0 10px 0;
      color: #fff;
      font-size: 14px;
    }
    
    .config-item {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .config-item label {
      flex: 1;
      margin-right: 10px;
    }
    
    .config-item input, .config-item select {
      width: 80px;
      padding: 4px 6px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #d1d4dc;
      font-size: 11px;
    }
    
    .config-item input[type="checkbox"] {
      width: auto;
    }
    
    .config-item input[type="number"] {
      width: 50px;
    }
    
    /* Marker section styles */
    .marker-section {
      margin-bottom: 20px;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
      background: #222;
    }
    
    .marker-section h5 {
      margin: 0 0 12px 0;
      color: #26a69a;
      font-size: 13px;
      font-weight: bold;
    }
    
    .marker-item {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      padding: 8px;
      background: #1a1a1a;
      border-radius: 6px;
      border: 1px solid #333;
    }
    
    .marker-item .config-item {
      margin-bottom: 0;
      flex: 0 0 auto;
    }
    
    .marker-item .config-item label {
      font-size: 11px;
      margin-right: 4px;
    }
    
    .marker-item .config-item input, 
    .marker-item .config-item select {
      width: 60px;
      font-size: 11px;
      padding: 4px 6px;
    }
    
    .remove-marker {
      width: 24px;
      height: 24px;
      background: #ef5350;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    .remove-marker:hover {
      background: #d32f2f;
      opacity: 1;
      transform: scale(1.1);
    }
    
    .add-marker-btn {
      background: #26a69a;
      border: none;
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      width: 100%;
    }
    
    .add-marker-btn:hover {
      background: #2dd4aa;
    }
    
    /* Tooltip styles */
    .tooltip {
      position: relative;
      display: inline-block;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #000;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 8px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -100px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 11px;
      line-height: 1.3;
      border: 1px solid #333;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    #apply-config {
      width: 100%;
      padding: 15px 24px;
      background: #26a69a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(38, 166, 154, 0.3);
    }
    
    #apply-config:hover {
      background: #2bbbad;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(38, 166, 154, 0.4);
    }
    
    #apply-config:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    #animation-status {
      margin-top: 10px;
      padding: 10px;
      background: #333;
      border-radius: 4px;
      text-align: center;
      font-size: 12px;
      color: #d1d4dc;
    }
    
    #tv_chart_container {
      width: 100%;
      height: 100%;
      position: relative;
    }
  </style>
</head>
<body>
  <div id="config-panel">
    <div class="config-content">
      <h3>Chart Configuration</h3>
      
      <div class="config-group">
        <h4>Market Cap Settings</h4>
        <div class="config-item">
          <label>Initial MC:</label>
          <input type="number" id="initialMarketCap" value="10000">
        </div>
        <div class="config-item">
          <label>Final MC:</label>
          <input type="number" id="finalMarketCap" value="50000">
        </div>
        <div class="config-item">
          <label>Min MC:</label>
          <input type="number" id="minMarketCap" value="5000">
        </div>
        <div class="config-item">
          <label>Range MC:</label>
          <input type="number" id="rangeMarketCap" value="2000">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Animation Timing</h4>
        <div class="config-item">
          <label>Duration (s):</label>
          <input type="number" id="totalSeconds" value="10">
        </div>
        <div class="config-item">
          <label>Speed Multiplier:</label>
          <input type="number" id="speedMultiplier" value="1" step="0.1">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Randomness Control</h4>
        <div class="config-item">
          <label>Seed:</label>
          <input type="number" id="seed" value="1">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Historical Data</h4>
        <div class="config-item">
          <label>Enable:</label>
          <input type="checkbox" id="enableHistoricalData">
        </div>
        <div class="config-item">
          <label>Time:</label>
          <input type="text" id="preAnimationTime" value="1h" placeholder="e.g., 2h, 60s">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Final Action</h4>
        <div class="config-item">
          <label>Type:</label>
          <select id="finalActionType">
            <option value="dump">Dump</option>
            <option value="pump">Pump</option>
          </select>
        </div>
        <div class="config-item">
          <label>Target MC:</label>
          <input type="number" id="finalActionMarketCap" value="5000">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Markers</h4>
        
        <!-- Dev Markers -->
        <div class="marker-section">
          <h5>Developer Markers</h5>
          <div id="dev-markers">
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">Dev 1:
                  <span class="tooltiptext">Developer marker 1. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showFirstCandle" checked>
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="firstCandleType">
                  <option value="buy">Buy</option>
                  <option value="sell">Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="firstCandleTime" value="1">
              </div>
              <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">Dev 2:
                  <span class="tooltiptext">Developer marker 2. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showFinalCandle" checked>
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="finalCandleType">
                  <option value="buy">Buy</option>
                  <option value="sell" selected>Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="finalCandleTime" value="10">
              </div>
              <button type="button" class="remove-marker" onclick="removeDevMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
          </div>
          <button type="button" class="add-marker-btn" onclick="addDevMarker()">+ Add Dev Marker</button>
        </div>
        
        <!-- User Markers -->
        <div class="marker-section">
          <h5>User Markers</h5>
          <div id="user-markers">
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">User 1:
                  <span class="tooltiptext">User marker 1. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showB">
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="bType">
                  <option value="buy" selected>Buy</option>
                  <option value="sell">Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="bTime" value="5">
              </div>
              <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
            <div class="marker-item">
              <div class="config-item">
                <label class="tooltip">User 2:
                  <span class="tooltiptext">User marker 2. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
                </label>
                <input type="checkbox" id="showS">
              </div>
              <div class="config-item">
                <label class="tooltip">Type:
                  <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
                </label>
                <select id="sType">
                  <option value="buy">Buy</option>
                  <option value="sell" selected>Sell</option>
                </select>
              </div>
              <div class="config-item">
                <label class="tooltip">Time:
                  <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
                </label>
                <input type="number" id="sTime" value="8">
              </div>
              <button type="button" class="remove-marker" onclick="removeUserMarker(this)" style="display: none;">üóëÔ∏è</button>
            </div>
          </div>
          <button type="button" class="add-marker-btn" onclick="addUserMarker()">+ Add User Marker</button>
        </div>
      </div>
    </div>
    
    <div class="config-button-container">
      <button id="apply-config">Apply & Start Animation</button>
      <button id="refresh-marks" style="margin-top: 10px; background: #ff9800; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Refresh Marks</button>
      <div id="animation-status">Chart ready - click "Apply & Start" to begin</div>
    </div>
  </div>
  
  <div id="chart-container">
    <div id="tv_chart_container"></div>
  </div>

  <script>
    // Global variables
    let tvWidget = null;
    let globalDatafeed = null;
    let isAnimating = false;
    let currentAnimation = null;

    // Seeded random number generator
    class SeededRandom {
      constructor(seed) {
        this.seed = seed;
      }
      
      next() {
        this.seed = (this.seed * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.seed / Math.pow(2, 32);
      }
      
      range(min, max) {
        return min + this.next() * (max - min);
      }
    }

    // Custom Datafeed for TradingView Advanced Chart
    class CustomDatafeed {
      constructor() {
        this.currentData = [];
        this.animationIndex = 0;
        this.onRealtimeCallback = null;
      }

      onReady(callback) {
        console.log('üì° TradingView Advanced Chart onReady called');
        setTimeout(() => callback({
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          supports_marks: true,
          supports_timescale_marks: true,
          supports_time: true,
        }), 0);
      }

      searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {
        console.log('üîç searchSymbols called');
        onResultReadyCallback([]);
      }

      resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
        console.log('üîó resolveSymbol called for:', symbolName);
        
        const symbolInfo = {
          ticker: 'CUSTOM',
          name: 'Custom Token',
          description: 'Custom animated token',
          type: 'crypto',
          session: '24x7',
          timezone: 'UTC',
          exchange: 'Custom',
          minmov: 1,
          pricescale: 100,
          has_intraday: true,
          has_weekly_and_monthly: false,
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          volume_precision: 0,
          data_status: 'streaming',
        };

        setTimeout(() => onSymbolResolvedCallback(symbolInfo), 0);
      }

      getBars(symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) {
        console.log('üìä getBars called with:', { resolution, periodParams, dataLength: this.currentData.length });
        
        try {
          if (this.currentData.length > 0) {
            // Convert to TradingView format
            const tvData = this.currentData.map(bar => ({
              time: bar.time * 1000, // TradingView expects milliseconds
              open: bar.open,
              high: bar.high,
              low: bar.low,
              close: bar.close,
              volume: bar.volume || 1000
            }));

            console.log('‚úÖ Sending', tvData.length, 'bars to TradingView');
            console.log('üìà Sample data:', tvData[0]);

            setTimeout(() => onHistoryCallback(tvData, { noData: false }), 0);
          } else {
            console.log('üìä No data available, sending empty response');
            setTimeout(() => onHistoryCallback([], { noData: true }), 0);
          }
        } catch (error) {
          console.error('‚ùå Error in getBars:', error);
          if (onErrorCallback) {
            onErrorCallback(error);
          }
        }
      }

      subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) {
        console.log('üì° subscribeBars called');
        this.onRealtimeCallback = onRealtimeCallback;
      }

      unsubscribeBars(subscribeUID) {
        console.log('üì° unsubscribeBars called');
      }

      // Method to add a new bar during animation
      addBar(bar) {
        this.currentData.push(bar);
        
        if (this.onRealtimeCallback) {
          const tvBar = {
            time: bar.time * 1000,
            open: bar.open,
            high: bar.high,
            low: bar.low,
            close: bar.close,
            volume: bar.volume || 1000
          };
          
          console.log('üìä Sending real-time bar:', tvBar);
          this.onRealtimeCallback(tvBar);
        }
      }

      // Method to clear data
      clearData() {
        this.currentData = [];
        this.animationIndex = 0;
      }

      // Get marks (chart markers)
      getMarks(symbolInfo, from, to, onDataCallback, resolution) {
        console.log('üéØ getMarks called:', { symbolInfo, from, to, resolution });
        console.log('üéØ Current data length:', this.currentData ? this.currentData.length : 0);
        console.log('üéØ Current data:', this.currentData);
        
        // Return marks from our current data
        const marks = this.getCurrentMarks(from, to);
        console.log('üéØ Returning marks:', marks.length, marks);
        
        // Log each mark in detail
        marks.forEach((mark, index) => {
          console.log(`üéØ Mark ${index}:`, {
            id: mark.id,
            time: mark.time,
            color: mark.color,
            text: mark.text,
            shape: mark.shape,
            minSize: mark.minSize
          });
        });
        
        onDataCallback(marks);
      }

      // Get current marks for the specified time range
      getCurrentMarks(from, to) {
        const marks = [];
        
        if (!this.currentData || this.currentData.length === 0) {
          return marks;
        }

        // Find bars in the time range
        for (let i = 0; i < this.currentData.length; i++) {
          const bar = this.currentData[i];
          const barTime = bar.time;
          
          if (barTime >= from && barTime <= to) {
            // Check if this bar should have a mark
            if (bar.mark) {
              marks.push({
                id: bar.mark.id,
                time: barTime,
                color: bar.mark.color,
                text: bar.mark.text,
                minSize: 14,
                shape: bar.mark.shape || 'circle'
              });
            }
          }
        }

        // Sort marks by time
        marks.sort((a, b) => a.time - b.time);
        return marks;
      }

      // Add a mark to a specific bar
      addMark(barTime, markData) {
        console.log('üéØ addMark called:', { barTime, markData, currentDataLength: this.currentData.length });
        
        // Find the bar and add mark data
        for (let i = 0; i < this.currentData.length; i++) {
          if (this.currentData[i].time === barTime) {
            this.currentData[i].mark = markData;
            console.log('üéØ Mark added to bar at index', i, 'time', barTime);
            
            // Trigger marks refresh by calling getMarks for the current visible range
            this.refreshMarks(barTime);
            break;
          }
        }
      }

      // Refresh marks for the chart
      refreshMarks(centerTime) {
        console.log('üîÑ Refreshing marks around time:', centerTime);
        
        // Calculate a time range around the mark
        const from = centerTime - 3600; // 1 hour before
        const to = centerTime + 3600;   // 1 hour after
        
        // Get marks for this range
        const marks = this.getCurrentMarks(from, to);
        console.log('üîÑ Found marks to refresh:', marks.length, marks);
        
        // Try to force a marks refresh by changing the visible range
        if (window.chartWidget && window.chartWidget.chart) {
          try {
            console.log('üîÑ Attempting to force marks refresh via chart API...');
            
            const chart = window.chartWidget.chart();
            if (chart && chart.getVisibleRange && chart.setVisibleRange) {
              console.log('üîÑ Found chart methods, triggering marks refresh...');
              
              // Get current visible range
              const currentRange = chart.getVisibleRange();
              if (currentRange) {
                console.log('üîÑ Current visible range:', currentRange);
                
                // Slightly adjust the range to trigger marks refresh
                const newRange = {
                  from: currentRange.from - 1, // 1ms before
                  to: currentRange.to + 1      // 1ms after
                };
                console.log('üîÑ Setting new visible range to trigger marks:', newRange);
                chart.setVisibleRange(newRange);
                
                // Set it back after a short delay
                setTimeout(() => {
                  console.log('üîÑ Restoring original visible range...');
                  chart.setVisibleRange(currentRange);
                }, 50);
              }
            }
          } catch (error) {
            console.error('‚ùå Error trying to force marks refresh:', error);
          }
        }
      }

      // Get timescale marks
      getTimescaleMarks(symbolInfo, from, to, onDataCallback, resolution) {
        console.log('üìÖ getTimescaleMarks called:', { symbolInfo, from, to, resolution });
        onDataCallback([]);
      }
    }

    // Parse time string to seconds (from working version)
    function parseTimeToSeconds(timeString) {
      const timeStr = timeString.toLowerCase().trim();
      const match = timeStr.match(/^(\d+)([smhd])$/);
      
      if (!match) {
        console.warn(`Invalid time format: ${timeString}. Using default 1 hour.`);
        return 3600; // Default to 1 hour
      }
      
      const value = parseInt(match[1]);
      const unit = match[2];
      
      switch (unit) {
        case 's': return value; // seconds
        case 'm': return value * 60; // minutes
        case 'h': return value * 3600; // hours
        case 'd': return value * 86400; // days
        default: return 3600; // Default to 1 hour
      }
    }

    // Get config from form
    function getConfig() {
      return {
        initialMarketCap: parseInt(document.getElementById('initialMarketCap').value),
        finalMarketCap: parseInt(document.getElementById('finalMarketCap').value),
        minMarketCap: parseInt(document.getElementById('minMarketCap').value),
        rangeMarketCap: parseInt(document.getElementById('rangeMarketCap').value),
        totalSeconds: parseInt(document.getElementById('totalSeconds').value),
        speedMultiplier: parseFloat(document.getElementById('speedMultiplier').value),
        seed: parseInt(document.getElementById('seed').value),
        enableHistoricalData: document.getElementById('enableHistoricalData').checked,
        preAnimationTime: document.getElementById('preAnimationTime').value,
        finalAction: {
          type: document.getElementById('finalActionType').value,
          marketCap: parseInt(document.getElementById('finalActionMarketCap').value)
        },
        markers: {
          showFirstCandle: document.getElementById('showFirstCandle').checked,
          firstCandleType: document.getElementById('firstCandleType').value,
          firstCandleTime: parseInt(document.getElementById('firstCandleTime').value),
          showFinalCandle: document.getElementById('showFinalCandle').checked,
          finalCandleType: document.getElementById('finalCandleType').value,
          finalCandleTime: parseInt(document.getElementById('finalCandleTime').value),
          userMarkers: {
            showB: document.getElementById('showB').checked,
            bType: document.getElementById('bType').value,
            bTime: parseInt(document.getElementById('bTime').value),
            showS: document.getElementById('showS').checked,
            sType: document.getElementById('sType').value,
            sTime: parseInt(document.getElementById('sTime').value)
          }
        }
      };
    }

    // Add marks to data before animation starts
    function addMarksToData(animatedBars, config) {
      console.log('üéØ Pre-adding marks to animation data...');
      
      // Dev 1 marker
      if (config.markers.showFirstCandle && config.markers.firstCandleTime <= animatedBars.length) {
        const barIndex = config.markers.firstCandleTime - 1; // Convert to 0-based index
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'dev1',
            color: config.markers.firstCandleType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'D1',
            shape: 'circle'
          };
          console.log('üéØ Pre-added Dev 1 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      // Dev 2 marker
      if (config.markers.showFinalCandle && config.markers.finalCandleTime <= animatedBars.length) {
        const barIndex = config.markers.finalCandleTime - 1; // Convert to 0-based index
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'dev2',
            color: config.markers.finalCandleType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'D2',
            shape: 'circle'
          };
          console.log('üéØ Pre-added Dev 2 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      // User markers
      if (config.markers.showB && config.markers.bTime <= animatedBars.length) {
        const barIndex = config.markers.bTime - 1;
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'user1',
            color: config.markers.bType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'U1',
            shape: 'circle'
          };
          console.log('üéØ Pre-added User 1 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      if (config.markers.showS && config.markers.sTime <= animatedBars.length) {
        const barIndex = config.markers.sTime - 1;
        if (barIndex >= 0 && barIndex < animatedBars.length) {
          const bar = animatedBars[barIndex];
          bar.mark = {
            id: 'user2',
            color: config.markers.sType === 'buy' ? '#26a69a' : '#ef5350',
            text: 'U2',
            shape: 'circle'
          };
          console.log('üéØ Pre-added User 2 mark to bar at index', barIndex, 'time', bar.time);
        }
      }
      
      console.log('üéØ Pre-added marks complete. Bars with marks:', animatedBars.filter(bar => bar.mark).length);
    }

    // Marker management functions
    function addDevMarker() {
      const devMarkers = document.getElementById('dev-markers');
      const markerCount = devMarkers.children.length;
      const newMarker = document.createElement('div');
      newMarker.className = 'marker-item';
      newMarker.innerHTML = `
        <div class="config-item">
          <label class="tooltip">Dev ${markerCount + 1}:
            <span class="tooltiptext">Developer marker ${markerCount + 1}. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
          </label>
          <input type="checkbox" id="showDev${markerCount + 1}" checked>
        </div>
        <div class="config-item">
          <label class="tooltip">Type:
            <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
          </label>
          <select id="dev${markerCount + 1}Type">
            <option value="buy">Buy</option>
            <option value="sell">Sell</option>
          </select>
        </div>
        <div class="config-item">
          <label class="tooltip">Time:
            <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
          </label>
          <input type="number" id="dev${markerCount + 1}Time" value="${markerCount + 1}">
        </div>
        <button type="button" class="remove-marker" onclick="removeDevMarker(this)">üóëÔ∏è</button>
      `;
      devMarkers.appendChild(newMarker);
      updateRemoveButtons();
    }
    
    function removeDevMarker(button) {
      button.parentElement.remove();
      updateRemoveButtons();
    }
    
    function addUserMarker() {
      const userMarkers = document.getElementById('user-markers');
      const markerCount = userMarkers.children.length;
      const newMarker = document.createElement('div');
      newMarker.className = 'marker-item';
      newMarker.innerHTML = `
        <div class="config-item">
          <label class="tooltip">User ${markerCount + 1}:
            <span class="tooltiptext">User marker ${markerCount + 1}. Shows a marker on the chart at the specified time. Can be Buy or Sell type.</span>
          </label>
          <input type="checkbox" id="showUser${markerCount + 1}">
        </div>
        <div class="config-item">
          <label class="tooltip">Type:
            <span class="tooltiptext">Whether this marker represents a Buy (green) or Sell (red) action on the chart.</span>
          </label>
          <select id="user${markerCount + 1}Type">
            <option value="buy" selected>Buy</option>
            <option value="sell">Sell</option>
          </select>
        </div>
        <div class="config-item">
          <label class="tooltip">Time:
            <span class="tooltiptext">Time in seconds when this marker will appear on the chart during the animation.</span>
          </label>
          <input type="number" id="user${markerCount + 1}Time" value="${markerCount + 1}">
        </div>
        <button type="button" class="remove-marker" onclick="removeUserMarker(this)">üóëÔ∏è</button>
      `;
      userMarkers.appendChild(newMarker);
      updateRemoveButtons();
    }
    
    function removeUserMarker(button) {
      button.parentElement.remove();
      updateRemoveButtons();
    }
    
    function updateRemoveButtons() {
      // Show remove buttons only if there are more than 1 markers
      const devMarkers = document.querySelectorAll('#dev-markers .marker-item');
      const userMarkers = document.querySelectorAll('#user-markers .marker-item');
      
      devMarkers.forEach((marker, index) => {
        const removeBtn = marker.querySelector('.remove-marker');
        if (removeBtn) {
          const shouldShow = devMarkers.length > 1;
          removeBtn.style.display = shouldShow ? 'flex' : 'none';
        }
      });
      
      userMarkers.forEach((marker, index) => {
        const removeBtn = marker.querySelector('.remove-marker');
        if (removeBtn) {
          const shouldShow = userMarkers.length > 1;
          removeBtn.style.display = shouldShow ? 'flex' : 'none';
        }
      });
    }

    // Initialize TradingView Advanced Chart
    function initTradingView() {
      if (tvWidget) {
        tvWidget.remove();
        tvWidget = null;
      }

      // Always create a new datafeed instance for each chart
      globalDatafeed = new CustomDatafeed();
      
      console.log('üöÄ Datafeed created:', globalDatafeed);
      console.log('üöÄ addMark method available:', typeof globalDatafeed.addMark);

      console.log('üöÄ Initializing TradingView Advanced Chart...');

      tvWidget = new TradingView.widget({
        symbol: 'CUSTOM',
        interval: '1',
        container: 'tv_chart_container',
        datafeed: globalDatafeed,
        library_path: 'charting_library-master/charting_library/',
        locale: 'en',
        disabled_features: [
          'save_chart_properties_to_local_storage',
          'use_localstorage_for_settings',
          'right_bar_stays_on_scroll',
          'study_templates'
        ],
        enabled_features: [
          'move_logo_to_main_pane'
        ],
        fullscreen: false,
        autosize: true,
        theme: 'dark'
      });

      tvWidget.onChartReady(() => {
        console.log('‚úÖ TradingView Advanced Chart ready');
        document.getElementById('animation-status').textContent = 'Advanced Chart ready - click "Apply & Start" to begin';
        document.getElementById('animation-status').style.color = '#26a69a';
        
        // Store chart reference for marker support
        window.chartWidget = tvWidget;
        
        // Try to access the chart's internal API for marks
        console.log('üîç Chart widget methods:', Object.getOwnPropertyNames(tvWidget));
        console.log('üîç Chart widget prototype:', Object.getOwnPropertyNames(Object.getPrototypeOf(tvWidget)));
        
        // Try to find marks-related methods
        if (tvWidget.chart) {
          console.log('üîç Chart object methods:', Object.getOwnPropertyNames(tvWidget.chart));
        }
      });
    }

    // Start animation function
    function startAnimation() {
      // Stop any existing animation first
      if (isAnimating) {
        console.log('üõë Stopping existing animation...');
        isAnimating = false;
        if (currentAnimation) {
          clearTimeout(currentAnimation);
          currentAnimation = null;
        }
      }
      
      if (!tvWidget || !globalDatafeed) {
        console.error('‚ùå TradingView widget or datafeed not available');
        return;
      }
      
      isAnimating = true;
      const config = getConfig();
      
      console.log('üé¨ Starting TradingView Advanced Chart animation with config:', config);
      document.getElementById('animation-status').textContent = 'Generating animation data...';
      document.getElementById('animation-status').style.color = '#26a69a';
      
      // Clear existing data and reset chart
      globalDatafeed.clearData();
      
      // Force chart refresh by recreating it
      console.log('üîÑ Recreating chart for new animation...');
      initTradingView();
      
      // Wait for chart to be ready before starting animation
      setTimeout(() => {
        startAnimationData(config);
      }, 500);
    }
    
    // Separate function to start the actual animation data generation
    function startAnimationData(config) {
      // Generate data
      const totalBars = config.totalSeconds;
      const preAnimationSeconds = config.enableHistoricalData ? parseTimeToSeconds(config.preAnimationTime) : 0;
      const rng = new SeededRandom(config.seed);
      const animationStartTime = Date.now() / 1000 - totalBars;
      const historicalStartTime = animationStartTime - preAnimationSeconds;
      
      console.log(`Using seed: ${config.seed} for reproducible animation`);
      console.log(`Generating ${totalBars} bars for animation...`);
      
      const allBars = [];
      let lastClose = config.initialMarketCap;

      // Generate pre-animation historical data (if enabled)
      if (config.enableHistoricalData && preAnimationSeconds > 0) {
        console.log(`Generating ${preAnimationSeconds} seconds of pre-animation history...`);
        
        let historicalPrice = config.initialMarketCap * (0.5 + rng.next() * 1.0); // 50% to 150% of initial
        
        for (let i = 0; i < preAnimationSeconds; i++) {
          const time = Math.floor(historicalStartTime) + i * 60; // 1-minute intervals
          const open = historicalPrice;
          
          // Generate realistic price movement
          const change = (rng.next() - 0.5) * config.rangeMarketCap * 0.3;
          const close = Math.max(1, open + change);
          
          let high = Math.max(open, close);
          let low = Math.min(open, close);
          
          // Add occasional wicks
          if (rng.next() < 0.2) {
            const wickSize = Math.abs(change) * (0.3 + rng.next() * 0.7);
            if (close > open) {
              high = Math.max(open, close) + rng.next() * wickSize;
            } else {
              low = Math.min(open, close) - rng.next() * wickSize;
            }
          }
          
          allBars.push({
            time: time,
            open: open,
            high: high,
            low: low,
            close: close,
            volume: 200 + rng.next() * 1500,
            isHistorical: true
          });
          
          historicalPrice = close;
        }
        
        // Set historical data immediately
        for (const bar of allBars) {
          globalDatafeed.currentData.push(bar);
        }
        
        console.log(`Pre-animation history loaded: ${allBars.length} bars`);
      }
      
      const startTime = Math.floor(animationStartTime);
      const animatedBars = [];
      lastClose = config.initialMarketCap;
      
      // Calculate progression
      const totalChange = config.finalMarketCap - config.initialMarketCap;
      const progressPerBar = totalChange / (totalBars - 1);
      
      // Generate bars
      for (let i = 0; i < totalBars; i++) {
        const time = startTime + i * 60; // 1-minute intervals
        const open = lastClose;
        
        // Calculate target price
        const targetPrice = config.initialMarketCap + (progressPerBar * i);
        
        // Generate price movement
        const trendStrength = 0.3;
        const randomStrength = 0.7;
        
        const trendComponent = (targetPrice - open) * trendStrength;
        const randomComponent = (rng.next() - 0.5) * config.rangeMarketCap * randomStrength;
        
        let close = open + trendComponent + randomComponent;
        
        // Apply constraints
        if (close < config.minMarketCap) {
          close = config.minMarketCap;
        }
        
        // Create realistic high/low
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Add occasional wicks
        if (rng.next() < 0.2) {
          const wickSize = Math.abs(close - open) * (0.2 + rng.next() * 0.8);
          if (close > open) {
            high = Math.max(open, close) + rng.next() * wickSize;
          } else {
            low = Math.min(open, close) - rng.next() * wickSize;
          }
        }
        
        animatedBars.push({
          time: time,
          open: open,
          high: high,
          low: low,
          close: close,
          volume: 1000 + rng.next() * 2000
        });
        
        lastClose = close;
      }
      
      // Add final action
      const finalTime = startTime + totalBars * 60;
      const finalOpen = lastClose;
      const finalClose = config.finalAction.marketCap;
      
      animatedBars.push({
        time: finalTime,
        open: finalOpen,
        high: Math.max(finalOpen, finalClose),
        low: Math.min(finalOpen, finalClose),
        close: finalClose,
        volume: 5000 + rng.next() * 5000
      });
      
      console.log('Generated', animatedBars.length, 'bars for animation');
      
      // Pre-add marks to the data based on config
      addMarksToData(animatedBars, config);
      
      // Start animated display
      let currentIndex = 0;
      
      function showNextBar() {
        if (currentIndex < animatedBars.length) {
          globalDatafeed.addBar(animatedBars[currentIndex]);
          
          // Check for markers at this time
          const currentTime = currentIndex + 1; // Animation time in seconds
          const currentBar = animatedBars[currentIndex];
          
          // Check if this bar has a pre-added mark and trigger refresh
          if (currentBar.mark) {
            console.log(`üéØ Bar at time ${currentTime}s has a mark:`, currentBar.mark);
            // Trigger marks refresh to make the mark visible
            if (globalDatafeed && typeof globalDatafeed.refreshMarks === 'function') {
              globalDatafeed.refreshMarks(currentBar.time);
            }
          }
          
          currentIndex++;
          
          // Update status
          document.getElementById('animation-status').textContent = `Animating... ${currentIndex}/${animatedBars.length}`;
          
          if (currentIndex === animatedBars.length) {
            document.getElementById('animation-status').textContent = 'Animation completed!';
            document.getElementById('animation-status').style.color = '#4CAF50';
            isAnimating = false;
            console.log('‚úÖ TradingView Advanced Chart animation complete');
            
            // Force marks refresh after animation completes
            console.log('üîÑ Forcing marks refresh after animation...');
            if (globalDatafeed && globalDatafeed.refreshMarks) {
              // Refresh marks for the entire animation range
              const firstBar = globalDatafeed.currentData[0];
              const lastBar = globalDatafeed.currentData[globalDatafeed.currentData.length - 1];
              if (firstBar && lastBar) {
                globalDatafeed.refreshMarks((firstBar.time + lastBar.time) / 2);
              }
            }
          } else {
            // Schedule next bar
            const delay = 1000 / config.speedMultiplier;
            currentAnimation = setTimeout(showNextBar, delay);
          }
        }
      }
      
      // Start the animation
      document.getElementById('animation-status').textContent = 'Starting animation...';
      
      // Debug: Check if markers are enabled
      console.log('üéØ Marker config check:', {
        showFirstCandle: config.markers.showFirstCandle,
        firstCandleTime: config.markers.firstCandleTime,
        showFinalCandle: config.markers.showFinalCandle,
        finalCandleTime: config.markers.finalCandleTime,
        showB: config.markers.userMarkers.showB,
        bTime: config.markers.userMarkers.bTime,
        showS: config.markers.userMarkers.showS,
        sTime: config.markers.userMarkers.sTime
      });
      
      setTimeout(showNextBar, 500); // Small delay to let chart settle
    }

    // Event listeners
    document.getElementById('apply-config').addEventListener('click', startAnimation);
    
    // Refresh marks button
    document.getElementById('refresh-marks').addEventListener('click', () => {
      console.log('üîÑ Manual marks refresh triggered');
      if (globalDatafeed && globalDatafeed.currentData.length > 0) {
        const firstBar = globalDatafeed.currentData[0];
        const lastBar = globalDatafeed.currentData[globalDatafeed.currentData.length - 1];
        if (firstBar && lastBar) {
          globalDatafeed.refreshMarks((firstBar.time + lastBar.time) / 2);
          
          // Try to force a marks refresh by changing the visible range
          if (window.chartWidget && window.chartWidget.chart) {
            try {
              console.log('üîÑ Attempting to force marks refresh via chart API...');
              
              // Try to trigger a marks refresh by zooming out and back in
              const chart = window.chartWidget.chart();
              if (chart && chart.setVisibleRange) {
                console.log('üîÑ Found setVisibleRange method, trying to trigger marks refresh...');
                
                // Get current visible range
                const currentRange = chart.getVisibleRange();
                console.log('üîÑ Current visible range:', currentRange);
                
                // Slightly adjust the range to trigger marks refresh
                if (currentRange) {
                  const newRange = {
                    from: currentRange.from - 1000, // 1 second before
                    to: currentRange.to + 1000      // 1 second after
                  };
                  console.log('üîÑ Setting new visible range:', newRange);
                  chart.setVisibleRange(newRange);
                  
                  // Set it back after a short delay
                  setTimeout(() => {
                    console.log('üîÑ Restoring original visible range...');
                    chart.setVisibleRange(currentRange);
                  }, 100);
                }
              }
            } catch (error) {
              console.error('‚ùå Error trying to force marks refresh:', error);
            }
          }
        }
      }
    });
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initTradingView, 100);
      updateRemoveButtons(); // Hide trash cans initially
    });
  </script>
</body>
</html>