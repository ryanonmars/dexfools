<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TradingView Advanced Chart - Live Trading Simulation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
  
  <!-- TradingView Advanced Chart Library -->
  <script type="text/javascript" src="charting_library-master/charting_library/charting_library.standalone.js"></script>
  <script src="chart-config.js"></script>
  
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #000;
    }
    body {
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px 40px 40px 20px;
      gap: 20px;
      box-sizing: border-box;
    }
    #chart-container {
      flex: 1;
      height: calc(100vh - 100px);
      max-width: calc(100vw - 400px);
      min-width: 400px;
      position: relative;
      background: #000;
      box-shadow: 0 4px 32px rgba(0,0,0,0.4);
      border-radius: 12px;
    }
    
    #config-panel {
      position: relative;
      width: 320px;
      flex-shrink: 0;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 0;
      color: #d1d4dc;
      font-family: Arial, sans-serif;
      font-size: 12px;
      max-height: calc(100vh - 100px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    
    .config-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    .config-button-container {
      flex-shrink: 0;
      padding: 20px;
      border-top: 1px solid #333;
      background: #1a1a1a;
      border-radius: 0 0 8px 8px;
    }
    
    #config-panel h3 {
      margin: 0 0 15px 0;
      color: #26a69a;
      font-size: 16px;
      border-bottom: 1px solid #333;
      padding-bottom: 10px;
    }
    
    .config-group {
      margin-bottom: 20px;
    }
    
    .config-group h4 {
      margin: 0 0 10px 0;
      color: #fff;
      font-size: 14px;
    }
    
    .config-item {
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .config-item label {
      flex: 1;
      margin-right: 10px;
    }
    
    .config-item input, .config-item select {
      width: 80px;
      padding: 4px 6px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      color: #d1d4dc;
      font-size: 11px;
    }
    
    .config-item input[type="checkbox"] {
      width: auto;
    }
    
    .config-item input[type="number"] {
      width: 50px;
    }
    
    #apply-config {
      width: 100%;
      padding: 15px 24px;
      background: #26a69a;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 8px rgba(38, 166, 154, 0.3);
    }
    
    #apply-config:hover {
      background: #2bbbad;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(38, 166, 154, 0.4);
    }
    
    #apply-config:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    #animation-status {
      margin-top: 10px;
      padding: 10px;
      background: #333;
      border-radius: 4px;
      text-align: center;
      font-size: 12px;
      color: #d1d4dc;
    }
    
    #tv_chart_container {
      width: 100%;
      height: 100%;
      position: relative;
    }
  </style>
</head>
<body>
  <div id="config-panel">
    <div class="config-content">
      <h3>Chart Configuration</h3>
      
      <div class="config-group">
        <h4>Market Cap Settings</h4>
        <div class="config-item">
          <label>Initial MC:</label>
          <input type="number" id="initialMarketCap" value="10000">
        </div>
        <div class="config-item">
          <label>Final MC:</label>
          <input type="number" id="finalMarketCap" value="50000">
        </div>
        <div class="config-item">
          <label>Min MC:</label>
          <input type="number" id="minMarketCap" value="5000">
        </div>
        <div class="config-item">
          <label>Range MC:</label>
          <input type="number" id="rangeMarketCap" value="2000">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Animation Timing</h4>
        <div class="config-item">
          <label>Duration (s):</label>
          <input type="number" id="totalSeconds" value="10">
        </div>
        <div class="config-item">
          <label>Speed Multiplier:</label>
          <input type="number" id="speedMultiplier" value="1" step="0.1">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Randomness Control</h4>
        <div class="config-item">
          <label>Seed:</label>
          <input type="number" id="seed" value="1">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Historical Data</h4>
        <div class="config-item">
          <label>Enable:</label>
          <input type="checkbox" id="enableHistoricalData">
        </div>
        <div class="config-item">
          <label>Time:</label>
          <input type="text" id="preAnimationTime" value="1h" placeholder="e.g., 2h, 60s">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Final Action</h4>
        <div class="config-item">
          <label>Type:</label>
          <select id="finalActionType">
            <option value="dump">Dump</option>
            <option value="pump">Pump</option>
          </select>
        </div>
        <div class="config-item">
          <label>Target MC:</label>
          <input type="number" id="finalActionMarketCap" value="5000">
        </div>
      </div>
      
      <div class="config-group">
        <h4>Markers</h4>
        <div class="config-item">
          <label>Dev Buy:</label>
          <input type="checkbox" id="showFirstCandle" checked>
        </div>
        <div class="config-item">
          <label>Dev Buy Time:</label>
          <input type="number" id="firstCandleTime" value="1">
        </div>
        <div class="config-item">
          <label>Dev Sell:</label>
          <input type="checkbox" id="showFinalCandle" checked>
        </div>
        <div class="config-item">
          <label>Dev Sell Time:</label>
          <input type="number" id="finalCandleTime" value="10">
        </div>
        <div class="config-item">
          <label>User Buy:</label>
          <input type="checkbox" id="showB">
        </div>
        <div class="config-item">
          <label>User Buy Time:</label>
          <input type="number" id="bTime" value="5">
        </div>
        <div class="config-item">
          <label>User Sell:</label>
          <input type="checkbox" id="showS">
        </div>
        <div class="config-item">
          <label>User Sell Time:</label>
          <input type="number" id="sTime" value="8">
        </div>
      </div>
    </div>
    
    <div class="config-button-container">
      <button id="apply-config">Apply & Start Animation</button>
      <div id="animation-status">Chart ready - click "Apply & Start" to begin</div>
    </div>
  </div>
  
  <div id="chart-container">
    <div id="tv_chart_container"></div>
  </div>

  <script>
    // Global variables
    let tvWidget = null;
    let globalDatafeed = null;
    let isAnimating = false;
    let currentAnimation = null;

    // Seeded random number generator
    class SeededRandom {
      constructor(seed) {
        this.seed = seed;
      }
      
      next() {
        this.seed = (this.seed * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.seed / Math.pow(2, 32);
      }
      
      range(min, max) {
        return min + this.next() * (max - min);
      }
    }

    // Custom Datafeed for TradingView Advanced Chart
    class CustomDatafeed {
      constructor() {
        this.currentData = [];
        this.animationIndex = 0;
        this.onRealtimeCallback = null;
      }

      onReady(callback) {
        console.log('ðŸ“¡ TradingView Advanced Chart onReady called');
        setTimeout(() => callback({
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          supports_marks: false,
          supports_timescale_marks: false,
          supports_time: true,
        }), 0);
      }

      searchSymbols(userInput, exchange, symbolType, onResultReadyCallback) {
        console.log('ðŸ” searchSymbols called');
        onResultReadyCallback([]);
      }

      resolveSymbol(symbolName, onSymbolResolvedCallback, onResolveErrorCallback) {
        console.log('ðŸ”— resolveSymbol called for:', symbolName);
        
        const symbolInfo = {
          ticker: 'CUSTOM',
          name: 'Custom Token',
          description: 'Custom animated token',
          type: 'crypto',
          session: '24x7',
          timezone: 'UTC',
          exchange: 'Custom',
          minmov: 1,
          pricescale: 100,
          has_intraday: true,
          has_weekly_and_monthly: false,
          supported_resolutions: ['1', '5', '15', '30', '60', '240', '1D'],
          volume_precision: 0,
          data_status: 'streaming',
        };

        setTimeout(() => onSymbolResolvedCallback(symbolInfo), 0);
      }

      getBars(symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) {
        console.log('ðŸ“Š getBars called with:', { resolution, periodParams, dataLength: this.currentData.length });
        
        try {
          if (this.currentData.length > 0) {
            // Convert to TradingView format
            const tvData = this.currentData.map(bar => ({
              time: bar.time * 1000, // TradingView expects milliseconds
              open: bar.open,
              high: bar.high,
              low: bar.low,
              close: bar.close,
              volume: bar.volume || 1000
            }));

            console.log('âœ… Sending', tvData.length, 'bars to TradingView');
            console.log('ðŸ“ˆ Sample data:', tvData[0]);

            setTimeout(() => onHistoryCallback(tvData, { noData: false }), 0);
          } else {
            console.log('ðŸ“Š No data available, sending empty response');
            setTimeout(() => onHistoryCallback([], { noData: true }), 0);
          }
        } catch (error) {
          console.error('âŒ Error in getBars:', error);
          if (onErrorCallback) {
            onErrorCallback(error);
          }
        }
      }

      subscribeBars(symbolInfo, resolution, onRealtimeCallback, subscribeUID, onResetCacheNeededCallback) {
        console.log('ðŸ“¡ subscribeBars called');
        this.onRealtimeCallback = onRealtimeCallback;
      }

      unsubscribeBars(subscribeUID) {
        console.log('ðŸ“¡ unsubscribeBars called');
      }

      // Method to add a new bar during animation
      addBar(bar) {
        this.currentData.push(bar);
        
        if (this.onRealtimeCallback) {
          const tvBar = {
            time: bar.time * 1000,
            open: bar.open,
            high: bar.high,
            low: bar.low,
            close: bar.close,
            volume: bar.volume || 1000
          };
          
          console.log('ðŸ“Š Sending real-time bar:', tvBar);
          this.onRealtimeCallback(tvBar);
        }
      }

      // Method to clear data
      clearData() {
        this.currentData = [];
        this.animationIndex = 0;
      }
    }

    // Parse time string to seconds (from working version)
    function parseTimeToSeconds(timeString) {
      const timeStr = timeString.toLowerCase().trim();
      const match = timeStr.match(/^(\d+)([smhd])$/);
      
      if (!match) {
        console.warn(`Invalid time format: ${timeString}. Using default 1 hour.`);
        return 3600; // Default to 1 hour
      }
      
      const value = parseInt(match[1]);
      const unit = match[2];
      
      switch (unit) {
        case 's': return value; // seconds
        case 'm': return value * 60; // minutes
        case 'h': return value * 3600; // hours
        case 'd': return value * 86400; // days
        default: return 3600; // Default to 1 hour
      }
    }

    // Get config from form
    function getConfig() {
      return {
        initialMarketCap: parseInt(document.getElementById('initialMarketCap').value),
        finalMarketCap: parseInt(document.getElementById('finalMarketCap').value),
        minMarketCap: parseInt(document.getElementById('minMarketCap').value),
        rangeMarketCap: parseInt(document.getElementById('rangeMarketCap').value),
        totalSeconds: parseInt(document.getElementById('totalSeconds').value),
        speedMultiplier: parseFloat(document.getElementById('speedMultiplier').value),
        seed: parseInt(document.getElementById('seed').value),
        enableHistoricalData: document.getElementById('enableHistoricalData').checked,
        preAnimationTime: document.getElementById('preAnimationTime').value,
        finalAction: {
          type: document.getElementById('finalActionType').value,
          marketCap: parseInt(document.getElementById('finalActionMarketCap').value)
        },
        markers: {
          showFirstCandle: document.getElementById('showFirstCandle').checked,
          firstCandleTime: parseInt(document.getElementById('firstCandleTime').value),
          showFinalCandle: document.getElementById('showFinalCandle').checked,
          finalCandleTime: parseInt(document.getElementById('finalCandleTime').value),
          userMarkers: {
            showB: document.getElementById('showB').checked,
            bTime: parseInt(document.getElementById('bTime').value),
            showS: document.getElementById('showS').checked,
            sTime: parseInt(document.getElementById('sTime').value)
          }
        }
      };
    }

    // Initialize TradingView Advanced Chart
    function initTradingView() {
      if (tvWidget) {
        tvWidget.remove();
        tvWidget = null;
      }

      // Create custom datafeed if not exists
      if (!globalDatafeed) {
        globalDatafeed = new CustomDatafeed();
      }

      console.log('ðŸš€ Initializing TradingView Advanced Chart...');

      tvWidget = new TradingView.widget({
        symbol: 'CUSTOM',
        interval: '1',
        container: 'tv_chart_container',
        datafeed: globalDatafeed,
        library_path: 'charting_library-master/charting_library/',
        locale: 'en',
        disabled_features: [
          'save_chart_properties_to_local_storage',
          'use_localstorage_for_settings',
          'right_bar_stays_on_scroll',
          'study_templates'
        ],
        enabled_features: [
          'move_logo_to_main_pane'
        ],
        fullscreen: false,
        autosize: true,
        theme: 'dark'
      });

      tvWidget.onChartReady(() => {
        console.log('âœ… TradingView Advanced Chart ready');
        document.getElementById('animation-status').textContent = 'Advanced Chart ready - click "Apply & Start" to begin';
        document.getElementById('animation-status').style.color = '#26a69a';
        
        // Store chart reference for marker support
        window.chartWidget = tvWidget;
      });
    }

    // Start animation function
    function startAnimation() {
      if (isAnimating) return;
      
      if (!tvWidget || !globalDatafeed) {
        console.error('âŒ TradingView widget or datafeed not available');
        return;
      }
      
      isAnimating = true;
      const config = getConfig();
      
      console.log('ðŸŽ¬ Starting TradingView Advanced Chart animation with config:', config);
      document.getElementById('animation-status').textContent = 'Generating animation data...';
      document.getElementById('animation-status').style.color = '#26a69a';
      
      // Clear existing data
      globalDatafeed.clearData();
      
      // Generate data
      const totalBars = config.totalSeconds;
      const preAnimationSeconds = config.enableHistoricalData ? parseTimeToSeconds(config.preAnimationTime) : 0;
      const rng = new SeededRandom(config.seed);
      const animationStartTime = Date.now() / 1000 - totalBars;
      const historicalStartTime = animationStartTime - preAnimationSeconds;
      
      console.log(`Using seed: ${config.seed} for reproducible animation`);
      console.log(`Generating ${totalBars} bars for animation...`);
      
      const allBars = [];
      let lastClose = config.initialMarketCap;

      // Generate pre-animation historical data (if enabled)
      if (config.enableHistoricalData && preAnimationSeconds > 0) {
        console.log(`Generating ${preAnimationSeconds} seconds of pre-animation history...`);
        
        let historicalPrice = config.initialMarketCap * (0.5 + rng.next() * 1.0); // 50% to 150% of initial
        
        for (let i = 0; i < preAnimationSeconds; i++) {
          const time = Math.floor(historicalStartTime) + i * 60; // 1-minute intervals
          const open = historicalPrice;
          
          // Generate realistic price movement
          const change = (rng.next() - 0.5) * config.rangeMarketCap * 0.3;
          const close = Math.max(1, open + change);
          
          let high = Math.max(open, close);
          let low = Math.min(open, close);
          
          // Add occasional wicks
          if (rng.next() < 0.2) {
            const wickSize = Math.abs(change) * (0.3 + rng.next() * 0.7);
            if (close > open) {
              high = Math.max(open, close) + rng.next() * wickSize;
            } else {
              low = Math.min(open, close) - rng.next() * wickSize;
            }
          }
          
          allBars.push({
            time: time,
            open: open,
            high: high,
            low: low,
            close: close,
            volume: 200 + rng.next() * 1500,
            isHistorical: true
          });
          
          historicalPrice = close;
        }
        
        // Set historical data immediately
        for (const bar of allBars) {
          globalDatafeed.currentData.push(bar);
        }
        
        console.log(`Pre-animation history loaded: ${allBars.length} bars`);
      }
      
      const startTime = Math.floor(animationStartTime);
      const animatedBars = [];
      lastClose = config.initialMarketCap;
      
      // Calculate progression
      const totalChange = config.finalMarketCap - config.initialMarketCap;
      const progressPerBar = totalChange / (totalBars - 1);
      
      // Generate bars
      for (let i = 0; i < totalBars; i++) {
        const time = startTime + i * 60; // 1-minute intervals
        const open = lastClose;
        
        // Calculate target price
        const targetPrice = config.initialMarketCap + (progressPerBar * i);
        
        // Generate price movement
        const trendStrength = 0.3;
        const randomStrength = 0.7;
        
        const trendComponent = (targetPrice - open) * trendStrength;
        const randomComponent = (rng.next() - 0.5) * config.rangeMarketCap * randomStrength;
        
        let close = open + trendComponent + randomComponent;
        
        // Apply constraints
        if (close < config.minMarketCap) {
          close = config.minMarketCap;
        }
        
        // Create realistic high/low
        let high = Math.max(open, close);
        let low = Math.min(open, close);
        
        // Add occasional wicks
        if (rng.next() < 0.2) {
          const wickSize = Math.abs(close - open) * (0.2 + rng.next() * 0.8);
          if (close > open) {
            high = Math.max(open, close) + rng.next() * wickSize;
          } else {
            low = Math.min(open, close) - rng.next() * wickSize;
          }
        }
        
        animatedBars.push({
          time: time,
          open: open,
          high: high,
          low: low,
          close: close,
          volume: 1000 + rng.next() * 2000
        });
        
        lastClose = close;
      }
      
      // Add final action
      const finalTime = startTime + totalBars * 60;
      const finalOpen = lastClose;
      const finalClose = config.finalAction.marketCap;
      
      animatedBars.push({
        time: finalTime,
        open: finalOpen,
        high: Math.max(finalOpen, finalClose),
        low: Math.min(finalOpen, finalClose),
        close: finalClose,
        volume: 5000 + rng.next() * 5000
      });
      
      console.log('Generated', animatedBars.length, 'bars for animation');
      
      // Start animated display
      let currentIndex = 0;
      
      function showNextBar() {
        if (currentIndex < animatedBars.length) {
          globalDatafeed.addBar(animatedBars[currentIndex]);
          
          // Check for markers at this time
          const currentTime = currentIndex + 1; // Animation time in seconds
          const currentBar = animatedBars[currentIndex];
          
          // Log marker checks for debugging
          if (config.markers.showFirstCandle && currentTime === config.markers.firstCandleTime) {
            console.log(`ðŸŽ¯ Dev Buy marker triggered at time: ${currentTime}s`);
          }
          if (config.markers.showFinalCandle && currentTime === config.markers.finalCandleTime) {
            console.log(`ðŸŽ¯ Dev Sell marker triggered at time: ${currentTime}s`);
          }
          if (config.markers.userMarkers.showB && currentTime === config.markers.userMarkers.bTime) {
            console.log(`ðŸŽ¯ User Buy marker triggered at time: ${currentTime}s`);
          }
          if (config.markers.userMarkers.showS && currentTime === config.markers.userMarkers.sTime) {
            console.log(`ðŸŽ¯ User Sell marker triggered at time: ${currentTime}s`);
          }
          
          currentIndex++;
          
          // Update status
          document.getElementById('animation-status').textContent = `Animating... ${currentIndex}/${animatedBars.length}`;
          
          if (currentIndex === animatedBars.length) {
            document.getElementById('animation-status').textContent = 'Animation completed!';
            document.getElementById('animation-status').style.color = '#4CAF50';
            isAnimating = false;
            console.log('âœ… TradingView Advanced Chart animation complete');
          } else {
            // Schedule next bar
            const delay = 1000 / config.speedMultiplier;
            currentAnimation = setTimeout(showNextBar, delay);
          }
        }
      }
      
      // Start the animation
      document.getElementById('animation-status').textContent = 'Starting animation...';
      setTimeout(showNextBar, 500); // Small delay to let chart settle
    }

    // Event listeners
    document.getElementById('apply-config').addEventListener('click', startAnimation);
    
    // Initialize when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initTradingView, 100);
    });
  </script>
</body>
</html>